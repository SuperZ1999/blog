---
title: "面试题笔记 背诵版"
date: 2023-03-16T22:54:20+08:00
categories: []
tags: []
description: ""
weight:
slug: ""
draft: false
disableShare: false
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---

# 项目

## 一般问题

### 碰到的bug



### 最有技术含量的部分



## 动态代理

见：<https://juejin.cn/post/7011357346018361375>

### jdk动态代理

#### 原理

就是先实现代理接口的方法，生成一个匿名内部类，这个匿名内部类里的操作都是调用InvocationHandler的invoke方法，在invoke方法里完成代理

#### 使用步骤

1. 创建被代理类及接口（JDK代理是接口代理）
2. 创建Handle类实现 InvocationHandler接口 ，重写invoke方法
3. 通过Proxy的newProxyInstance()方法获取代理类对象
4. 通过代理类对象调用被代理类的方法

### cglib动态代理

#### 原理

就是修改需要代理的那个类的字节码，生成该类的子类并重写父类的方法，这个子类的方法都会调用回调函数intercept方法，从而完成代理

#### 使用步骤

1. new Enhancer()
2. 设置需要代理的类
3. 设置回调
4. 创建

#### jdk动态代理和cglib动态代理的区别

1. **原理不同：**JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
   CGLib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。所以jdk动态代理的方式创建代理对象效率较高，执行效率较低，CGLib创建效率较低，执行效率高。
2. **适用场景不同：**jdk动态代理目标类必须是接口类，cglib代理目标类不需要实现接口，但是不能是final类
3. **机制不同：**jdk动态代理是委托机制，因为代理类里无法直接调用被代理类的方法，所以委托InvocationHandler去调用目标类的方法，cglib动态代理是继承机制，代理类和被代理类是父子关系，所以代理类可以调用被代理类的方法，所以通过回调函数MethodInterceptor调用父类方法执行原始逻辑

### 静态代理

为需要代理的类抽象出一个接口，然后编写代理类实现这个接口，实现接口方法时就可以添加代理的逻辑

缺点：1、每个被代理类都要有一个代理类，代码比较冗余 2、一旦改动被代理类，代理类也得改动

#### 静态代理与动态代理的区别

- 静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件
- 动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成的

## Netty

### 什么是Netty

Netty就是Java里NIO的封装，让用户可以很方便的使用Java的非阻塞IO

### Netty跟Java NIO有什么不同，为什么不直接使用JDK NIO类库？

说说NIO有什么缺点吧：

1. NIO的类库和API还是有点复杂，比如Buffer的使用 Selector编写复杂，如果对某个事件注册后，业务代码过于耦合，需要了解很多多线程的知识，熟悉网络编程，面对断连重连、保丢失、粘包等，处理复杂
2. NIO存在BUG，根据网上言论说是selector空轮训导致CPU飙升

Netty主要的优点有：

1. 统一的 API，支持多种传输类型，阻塞和非阻塞的。
2. 简单而强大的线程模型。
3. 自带编解码器解决 TCP 粘包/拆包问题。
4. 自带各种协议栈。
5. 比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。
6. 安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。
7. 社区活跃
8. 成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty， 比如我们经常接触的 Dubbo、RocketMQ 等等。

### Netty 应用场景了解么？

理论上来说，NIO 可以做的事情 ，使用 Netty 都可以做并且更好。Netty 主要用来做**网络通信**：

1. **作为 RPC 框架的网络通信工具** 
2. **实现一个自己的 HTTP 服务器** 
3. **实现一个即时通讯系统** 
4. **实现消息推送系统** 

基本只要是网络通信的都可以用Netty做

### Netty的核心组件

#### EventLoop

EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。

#### Channel

**Channel** 接口是 **Netty** 对网络操作抽象类，它除了包括基本的 **I/O** 操作，如 **bind()**、**connect()**、**read()**、**write()** 等。

比较常用的**Channel**接口实现类是**NioServerSocketChannel**（服务端）和**NioSocketChannel**（客户端），这两个 **Channel** 可以和 **BIO** 编程模型中的**ServerSocket**以及**Socket**两个概念对应上。**Netty** 的 **Channel** 接口所提供的 **API**，大大地降低了直接使用 **Socket** 类的复杂性。

#### ChannelFuture

**Netty** 是异步非阻塞的，所有的 I/O 操作都为异步的。所以我们不能立刻得到操作的结果，我们可以通过 **ChannelFuture** 接口的 **addListener()** 方法注册一个 **ChannelFutureListener**，当操作执行完后，监听就会自动触发返回结果。

#### ChannelHandler 和 ChannelPipeline

ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连在一起了，连在一起形成的链就是 ChannelPipeline

### Bootstrap 和 ServerBootstrap 了解么？

1. Bootstrap是客户端，ServerBootstrap是服务端
2. Bootstrap调用connect连接，ServerBootstrap调用bind开启服务
3. Bootstrap 只需要配置一个EventLoopGroup ,而 ServerBootstrap需要配置两个线程组EventLoopGroup ，一个用于处理连接事件，一个用于处理读写事件。

### Netty的线程模型

Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。

单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。

多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。

主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作

#### Reactor模型

建立新连接和处理读写操作分开就是Reactor模型

### Netty的执行流程

#### 服务端

1. 创建ServerBootStrap实例
2. 设置并绑定Reactor线程池（线程模型）：EventLoopGroup，EventLoop就是处理所有注册到本线程的Selector上面的Channel
3. 设置并绑定服务端的channel（IO模型）
4. 创建处理网络事件的ChannelPipeline和handler
5. 绑定并启动监听端口
6. 当轮询到准备就绪的channel后，由Reactor线程：NioEventLoop执行pipline中的方法，最终调度并执行channelHandler

#### 客户端

1. 创建BootStrap实例
2. 设置并绑定Reactor线程池（线程模型）：EventLoopGroup，EventLoop就是处理所有注册到本线程的Selector上面的Channel
3. 设置并绑定服务端的channel（IO模型）
4. 创建处理网络事件的ChannelPipeline和handler
5. 发起连接

### TCP 粘包/拆包的原因及解决方法

#### 原因

**粘包：**

1. 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
2. 接收方法不及时读取套接字缓冲区数据，这将发生粘包。

**拆包：**

1. 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
2. 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。

#### 解决办法

**粘包：**

1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2. 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

### Netty 长连接、心跳机制



### Netty 的零拷贝



# 零碎

- 匿名内部类也会生成class文件

# 待做

- jdk动态代理的反射体现在什么地方？
- 主从多线程模型到底是什么

