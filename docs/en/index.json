[{"content":"思路 两种思路：\n递归 因为是判断树是否镜像对称，所以需要递归判断左子树的左子树与右子树的右子树和左子树的右子树与右子树的左子树是否镜像对称，这样就找到了递归的地方，详见代码\n迭代 创建一个队列，首先从队列中拿出两个节点(left 和 right)比较，将 left 的 left 节点和 right 的 right 节点放入队列，将 left 的 right 节点和 right 的 left 节点放入队列，再比较，循环往复即可\n代码 递归 class Solution { public boolean isSymmetric(TreeNode root) { return isSymmetric(root.left, root.right); } private boolean isSymmetric(TreeNode leftRoot, TreeNode rightRoot) { if (leftRoot == null \u0026amp;\u0026amp; rightRoot == null) { return true; } if (leftRoot == null || rightRoot == null) { return false; } if (leftRoot.val != rightRoot.val) { return false; } return isSymmetric(leftRoot.right, rightRoot.left) \u0026amp;\u0026amp; isSymmetric(leftRoot.left, rightRoot.right); } } 迭代 class Solution { public boolean isSymmetric(TreeNode root) { LinkedList\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root.left); queue.add(root.right); while (!queue.isEmpty()) { TreeNode left = queue.remove(); TreeNode right = queue.remove(); if (left == null \u0026amp;\u0026amp; right == null) { continue; } if (left == null || right == null) { return false; } if (left.val != right.val) { return false; } queue.add(left.left); queue.add(right.right); queue.add(left.right); queue.add(right.left); } return true; } } References 1. 对称二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-101/","summary":"思路 两种思路： 递归 因为是判断树是否镜像对称，所以需要递归判断左子树的左子树与右子树的右子树和左子树的右子树与右子树的左子树是否镜像对称，这样","title":"LeetCode 101"},{"content":"思路 第一题 模拟即可，直接看代码\n第二题 从左往右遍历字符串，每碰到一个数字，就计算前面mod m的余数 * 10 + 当前数字是否能整除m，然后再将除以m的余数赋值到前面mod m的余数上，看代码即可\n第三题 两种思路：\n二分查找 由于是查找能标记的最大值，由于标记数和不能成立成正比，具有单调性，所以可以使用二分查找，范围是[0, nums.lenght / 2]，每次选择中点，并判断中点能不能成立，具体判断方法就是判断最小的mid个数和最大的mid个数能否满足2*nums[i] \u0026lt;= nums[j]\n双指针 利用双指针的思想，i指向0， j指向中点，判断i 和 j是否满足条件，如果满足条件，i++，寻找下一个标记对，最后i的值就是可标记对的数目\n第四题 没做出来\n代码 第一题 class Solution { public int[] leftRigthDifference(int[] nums) { int n = nums.length; int[] res = new int[n], leftSum = new int[n], rightSum = new int[n]; for (int i = 1; i \u0026lt; n; i++) { leftSum[i] = leftSum[i - 1] + nums[i - 1]; } for (int i = n - 2; i \u0026gt;= 0; i--) { rightSum[i] = rightSum[i + 1] + nums[i + 1]; } for (int i = 0; i \u0026lt; n; i++) { res[i] = Math.abs(leftSum[i] - rightSum[i]); } return res; } } 第二题 class Solution { public int[] divisibilityArray(String word, int m) { int n = word.length(); int[] res = new int[n]; long r = 0; for (int i = 0; i \u0026lt; n; i++) { char c = word.charAt(i); r = r * 10 + c - \u0026#39;0\u0026#39;; if (r % m == 0) { res[i] = 1; } r %= m; } return res; } } 第三题 二分查找 class Solution { public int maxNumOfMarkedIndices(int[] nums) { int n = nums.length; int left = 0, right = n / 2; Arrays.sort(nums); while (left \u0026lt; right) { int mid = (right - left + 1) / 2 + left; if (canMark(nums, mid)) { left = mid; } else { right = mid - 1; } } return left * 2; } private boolean canMark(int[] nums, int n) { for (int i = 0; i \u0026lt; n; i++) { if (2 * nums[i] \u0026gt; nums[nums.length - n + i]) { return false; } } return true; } } 双指针 class Solution { public int maxNumOfMarkedIndices(int[] nums) { Arrays.sort(nums); int i = 0; for (int j = (nums.length + 1) / 2;j \u0026lt; nums.length;j++) { if (2 * nums[i] \u0026lt;= nums[j]) { i++; } } return 2 * i; } } References 1. 左右元素和的差值 2. 找出字符串的可整除数组 3. 求出最多标记下标 4. 在网格图中访问一个格子的最少时间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-334/","summary":"思路 第一题 模拟即可，直接看代码 第二题 从左往右遍历字符串，每碰到一个数字，就计算前面mod m的余数 * 10 + 当前数字是否能整除m，然后再将除以m的","title":"LeetCode 周赛 334"},{"content":"思路 三种思路：\n递归 经典二叉树中序遍历，闭着眼写，详见思想篇章\n迭代 暂时没看\nMorris 中序遍历 感觉没必要看\n代码 递归 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); inorderTraversal(root, res); return res; } private void inorderTraversal(TreeNode root, List\u0026lt;Integer\u0026gt; res) { if (root == null) { return; } inorderTraversal(root.left, res); res.add(root.val); inorderTraversal(root.right, res); } } References 1. 二叉树的中序遍历 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-94/","summary":"思路 三种思路： 递归 经典二叉树中序遍历，闭着眼写，详见思想篇章 迭代 暂时没看 Morris 中序遍历 感觉没必要看 代码 递归 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); inorderTraversal(root, res); return res; } private","title":"LeetCode 94"},{"content":"思路 利用双指针的思想即可，左指针指向0的最后一个的后一个，右指针指向2的第一个的前一个，然后遍历数组同时维护左右指针即可，注意点：\n除了刚开始的时候，左指针指向的不可能是0，因为如果是0，那么遍历的时候就肯定遍历到它了，那么就会放到左边，而不是出现在这里 交换右边的时候，i不能加一，因为交换的数字有可能是0或2，要重复判断 代码 class Solution { public void sortColors(int[] nums) { int left = 0, right = nums.length - 1; for (int i = 0; i \u0026lt;= right; i++) { if (nums[i] == 0) { nums[i] = nums[left]; nums[left] = 0; left++; } if (nums[i] == 2) { nums[i] = nums[right]; nums[right] = 2; right--; i--; } } } } References 1. 颜色分类 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-75/","summary":"思路 利用双指针的思想即可，左指针指向0的最后一个的后一个，右指针指向2的第一个的前一个，然后遍历数组同时维护左右指针即可，注意点： 除了刚开始","title":"LeetCode 75"},{"content":"思路 三种思路：\n动态规划 类似于斐波那契数列，定义一个dp数组，dp[i] = j的含义是，到达第i个台阶有j种方法，那么递推公式为：\ndp[i] = dp[i - 2] + dp[i - 1]; base case为dp[0] = dp[1] = 1，可以优化空间复杂度，但是懒得弄了\n矩阵快速幂 感觉没必要看\n通项公式 感觉没必要看\n代码 class Solution { public int climbStairs(int n) { int[] dp = new int[n + 1]; dp[0] = dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 2] + dp[i - 1]; } return dp[n]; } } References 1. 爬楼梯 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-70/","summary":"思路 三种思路： 动态规划 类似于斐波那契数列，定义一个dp数组，dp[i] = j的含义是，到达第i个台阶有j种方法，那么递推公式为： dp[i] = dp[i - 2] + dp[i","title":"LeetCode 70"},{"content":"思路 两种思路：\n动态规划 暂时没看\n数学组合 这里向下向右的步数是固定的，所以这里路径的个数等于C(向右的步数或向下的步数，总步数)，求组合详见思想篇章，注意这里必须从1和n开始乘，从1和m+n-2开始乘会溢出\n代码 class Solution { public int uniquePaths(int m, int n) { long res = 1; for (int i = n, j = 1; j \u0026lt; m; i++, j++) { res = res * i / j; } return (int) res; } } References 1. 不同路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-62/","summary":"思路 两种思路： 动态规划 暂时没看 数学组合 这里向下向右的步数是固定的，所以这里路径的个数等于C(向右的步数或向下的步数，总步数)，求组合详见思想","title":"LeetCode 62"},{"content":"思路 第一题 脑筋急转弯，直接看代码\n第二题 其实就是计算2^n - 2，用快速幂计算即可，只不过要注意：\n求的时候同时取余，模板在思想篇章 计算过程有可能超过int类型范围，所以需要用long存储 最后的结果最好写成(2^n - 2 + MOD) % MOD，因为有可能2^n - 2 \u0026lt; 0 第三题 先转换问题，可以把原问题转换为用挡板将数组分成k个子数组，那么共有k - 1个挡板，答案就是数组第一个元素加最后一个元素加挡板两边的元素，所以可以把原数组的元素两两合并，然后找出最大的k-1个数之和与最小的k-1个数之和，两数之差就是答案\n第四题 其实枚举所有四元组就可以了，但是枚举所有四元组，时间复杂度较高，所以可以使用有技巧的枚举，只枚举中间两个数，剩下两个数其实大小范围和位置范围是确定的，问题就转换为了怎么获取这些位置范围和大小范围确定的数，可以用一个数组greater[j][x]来记录位置j右边比x大的数的数量，具体看代码\n代码 第一题 class Solution { public int distinctIntegers(int n) { if (n == 1) { return 1; } return n - 1; } } 第二题 class Solution { int base = 1000000007; int mypow(int a, int k) { if (k == 0) return 1; a %= base; if (k % 2 == 1) { // k 是奇数 return (int) (((long)a * mypow(a, k - 1)) % base); } else { // k 是偶数 int sub = mypow(a, k / 2); return (int) (((long)sub * sub) % base); } } public int monkeyMove(int n) { int res = mypow(2, n); return res \u0026gt;= 2 ? res - 2 : res + base - 2; } } 第三题 class Solution { public long putMarbles(int[] weights, int k) { int n = weights.length; long[] temp = new long[n - 1]; for (int i = 0; i \u0026lt; n - 1; i++) { temp[i] = weights[i] + weights[i + 1]; } Arrays.sort(temp); long max = 0, min = 0; for (int i = 0; i \u0026lt; k - 1; i++) { max += temp[n - 2 - i]; min += temp[i]; } return max - min; } } 第四题 class Solution { public long countQuadruplets(int[] nums) { int n = nums.length; int[][] greater = new int[n][n + 1]; for (int i = n - 2; i \u0026gt; 0; i--) { greater[i] = greater[i + 1].clone(); for (int j = 1; j \u0026lt; nums[i + 1]; j++) { greater[i][j]++; } } long res = 0; for (int j = 1; j \u0026lt; n - 2; j++) { for (int k = j + 1; k \u0026lt; n - 1; k++) { int x = nums[k]; if (nums[j] \u0026gt; x) { res += (long) greater[k][nums[j]] * (x - (n - 1 - j - greater[j][x])); } } } return res; } } References 1. 统计桌面上的不同数字 2. 猴子碰撞的方法数 3. 将珠子放入背包中 4. 统计上升四元组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-330/","summary":"思路 第一题 脑筋急转弯，直接看代码 第二题 其实就是计算2^n - 2，用快速幂计算即可，只不过要注意： 求的时候同时取余，模板在思想篇章 计算过程有可能","title":"LeetCode 周赛 330"},{"content":"思路 第一题 遍历一遍即可，直接看代码\n第二题 二维数组一片区域同时增加一个数，可以使用差分数组的思想，跟一维的一样，一维的是把两头修改一下就可以了，二维的需要在以下位置修改：\n为什么要这么修改？因为差分数组的前缀和就是原数组，这么修改的话，差分数组求前缀和后刚好就是那一块被修改了，又因为差分数组的前缀和是原数组，所以把修改后的差分数组求前缀和后就得到了答案\n所以这道题的解答有三步：\n构建差分数组，注意二维差分数组的构建方式：差分值=当前位置的值-左边的-上边的+左上的，本题全是0所以可以省略 修改差分数组，具体做法如上所示 对差分数组求前缀和，获取原数组，这里因为将前缀和数组放在一个新数组里还得复制到结果数组里面，所以可以将前缀和数组放到之前的差分数组里面，然后再复制到结果数组，以此来节省时间 第三题 利用滑动窗口的思想，时刻保持当前窗口是以right为底，窗口内是好数组的最短数组，那么以当前right为底的好数组个数就是left+1个，我的代码和标准解法的区别是，我的left比标准解答往后挪了1\n第四题 没看\n代码 第一题 class Solution { public int differenceOfSum(int[] nums) { int sum1 = 0, sum2 = 0; for (int num : nums) { sum1 += num; sum2 += getVal(num); } return Math.abs(sum1 - sum2); } private int getVal(int num) { int sum = 0; while (num != 0) { sum += num % 10; num /= 10; } return sum; } } 第二题 class Solution { public int[][] rangeAddQueries(int n, int[][] queries) { int[][] diff = new int[n + 2][n + 2]; for (int[] query : queries) { diff[query[0] + 1][query[1] + 1]++; diff[query[0] + 1][query[3] + 2]--; diff[query[2] + 2][query[1] + 1]--; diff[query[2] + 2][query[3] + 2]++; } int[][] res = new int[n][n]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { diff[i][j] = diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1] + diff[i][j]; res[i - 1][j - 1] = diff[i][j]; } } return res; } } 第三题 class Solution { public long countGood(int[] nums, int k) { long res = 0; int n = nums.length; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, count = 0; while (right \u0026lt; n) { map.put(nums[right], map.getOrDefault(nums[right], 0) + 1); count += map.get(nums[right]) - 1; right++; while (count - map.get(nums[left]) + 1 \u0026gt;= k) { map.put(nums[left], map.get(nums[left]) - 1); count -= map.get(nums[left]); left++; } if (count \u0026gt;= k) { res += left + 1; } } return res; } } References 1. 数组元素和与数字和的绝对差 2. 子矩阵元素加 1 3. 统计好子数组的数目 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-328/","summary":"思路 第一题 遍历一遍即可，直接看代码 第二题 二维数组一片区域同时增加一个数，可以使用差分数组的思想，跟一维的一样，一维的是把两头修改一下就可以了","title":"LeetCode 周赛 328"},{"content":"思路 使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。\n由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。\n还可以对字符串的字符进行计数，然后将这些数字拼接成字符串作为key，比如abc可以计数为a1b1c1\n代码 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String str : strs) { char[] chars = str.toCharArray(); Arrays.sort(chars); String sortedStr = new String(chars); if (!map.containsKey(sortedStr)) { map.put(sortedStr, new LinkedList\u0026lt;\u0026gt;()); } map.get(sortedStr).add(str); } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } References 1. 字母异位词分组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-49/","summary":"思路 使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。遍历每个字符串，对于每个字符串，得到该","title":"LeetCode 49"},{"content":"思路 看到「最大化最小值」或者「最小化最大值」（其实就是那种要求一堆数字尽量平均的题）就要想到二分答案，这是一个固定的套路。\n这里求小孩最多能拿到多少糖果，其实就是尽量平均的问题，那么可以二分搜索答案，每次选定一个答案都要验证这个答案，根据验证结果去选择在左区间还是右区间继续二分查找，不过要注意每次二分要排除不可能的情况，也就是说可能的情况要全部保留，不要将可能的情况扔掉，相关代码如下所示：\nif (count \u0026gt;= k) { left = mid; } else { right = mid - 1; } 代码 class Solution { public int maximumCandies(int[] candies, long k) { int left = 0, right = 10000000; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; long count = 0; for (int i = 0; i \u0026lt; candies.length; i++) { count += candies[i] / mid; } if (count \u0026gt;= k) { left = mid; } else { right = mid - 1; } } return left; } } References 1. 每个小孩最多能分到多少糖果 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-2226/","summary":"思路 看到「最大化最小值」或者「最小化最大值」（其实就是那种要求一堆数字尽量平均的题）就要想到二分答案，这是一个固定的套路。 这里求小孩最多能拿","title":"LeetCode 2226"},{"content":"思路 第一题 两种思路：\n暴力解法 遍历一遍并统计\n二分查找 因为数组是有序的，分别查找0的左边界和右边界就可以得到正数负数的范围了，注意左边界是第一个大于等于target的数，右边界是从右往左第一个小于等于target的数，python里自带了二分查找左边界和右边界的函数，Java里有基本版的二分查找\n第二题 利用贪心算法的思想，每次取最大的，所以用最大堆即可，向上取整可以用(val + 2) / 3，即(val + n - 1) / n\n第三题 将两个字符串转为两个map，然后将两个map里的字母交换，同时判断交换后map的entry数目是否相等即可，因为总共就26个字母，所以不会超时，而且其实不用真的交换，直接通过数学计算就好了\n第四题 模拟题，没什么好说的，就是想办法用代码模拟这个过程，这个答案比较简洁，我写的就是一坨屎山\n代码 第一题 暴力解法 class Solution { public int maximumCount(int[] nums) { int a = 0, b = 0; for (int num : nums) { if (num \u0026lt; 0) { a++; } else if (num \u0026gt; 0) { b++; } } return Math.max(a, b); } } 二分查找 class Solution { public int maximumCount(int[] nums) { int a = searchLeft(nums, 0); int b = searchRight(nums, 0); return Math.max(a, nums.length - b - 1); } private int searchLeft(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026lt;= nums[mid]) { right = mid; } else { left = mid + 1; } } return nums[left] \u0026lt; target ? nums.length : left; } private int searchRight(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if (target \u0026gt;= nums[mid]) { left = mid; } else { right = mid - 1; } } return nums[left] \u0026gt; target ? -1 : left; } } 第二题 class Solution { public long maxKelements(int[] nums, int k) { Queue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b - a; }); for (int num : nums) { pq.offer(num); } long res = 0; while (k-- != 0) { res += pq.peek(); pq.offer((pq.poll() + 2) / 3); } return res; } } 第三题 class Solution { public boolean isItPossible(String word1, String word2) { Map\u0026lt;Character, Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); for (char c : word1.toCharArray()) { map1.put(c, map1.getOrDefault(c, 0) + 1); } for (char c : word2.toCharArray()) { map2.put(c, map2.getOrDefault(c, 0) + 1); } Set\u0026lt;Character\u0026gt; keySet1 = new HashSet\u0026lt;\u0026gt;(map1.keySet()); Set\u0026lt;Character\u0026gt; keySet2 = new HashSet\u0026lt;\u0026gt;(map2.keySet()); for (Character c1 : keySet1) { for (Character c2 : keySet2) { swap(map1, map2, c1, c2); if (map1.size() == map2.size()) { return true; } swap(map1, map2, c2, c1); } } return false; } private void swap(Map\u0026lt;Character, Integer\u0026gt; map1, Map\u0026lt;Character, Integer\u0026gt; map2, char c1, char c2) { Integer v1 = map1.get(c1); Integer v2 = map2.get(c2); if (v1 == 1) { map1.remove(c1); } else { map1.put(c1, map1.get(c1) - 1); } if (v2 == 1) { map2.remove(c2); } else { map2.put(c2, map2.get(c2) - 1); } map1.put(c2, map1.getOrDefault(c2, 0) + 1); map2.put(c1, map2.getOrDefault(c1, 0) + 1); } } 第四题 class Solution { public int findCrossingTime(int n, int k, int[][] time) { Queue\u0026lt;Worker\u0026gt; pq1 = new PriorityQueue\u0026lt;Worker\u0026gt;((a, b) -\u0026gt; { if (a.time[0] + a.time[2] \u0026gt; b.time[0] + b.time[2] || a.time[0] + a.time[2] == b.time[0] + b.time[2] \u0026amp;\u0026amp; a.index \u0026gt; b.index) { return -1; } else { return 1; } }); Queue\u0026lt;Worker\u0026gt; pq2 = new PriorityQueue\u0026lt;Worker\u0026gt;((a, b) -\u0026gt; { if (a.time[0] + a.time[2] \u0026gt; b.time[0] + b.time[2] || a.time[0] + a.time[2] == b.time[0] + b.time[2] \u0026amp;\u0026amp; a.index \u0026gt; b.index) { return -1; } else { return 1; } }); for (int i = 0; i \u0026lt; time.length; i++) { pq1.offer(new Worker(\u0026#34;waitBridge\u0026#34;, 0, i, time[i])); } boolean bridgeIsUsed = false; List\u0026lt;Worker\u0026gt; workerList = new ArrayList\u0026lt;\u0026gt;(); int t = -1, pickOldCount = 0, minTime = 1; while (true) { t += minTime; int newMinTime = Integer.MAX_VALUE; // 工作 for (int i = 0; i \u0026lt; workerList.size(); i++) { Worker worker = workerList.get(i); switch (worker.state) { case \u0026#34;leftToRight\u0026#34;: worker.leftTime -= minTime; if (worker.leftTime == 0) { worker.state = \u0026#34;pickOld\u0026#34;; worker.leftTime = worker.time[1]; bridgeIsUsed = false; pickOldCount++; } newMinTime = Math.min(newMinTime, worker.leftTime); break; case \u0026#34;rightToLeft\u0026#34;: worker.leftTime -= minTime; if (worker.leftTime == 0) { worker.state = \u0026#34;putNew\u0026#34;; worker.leftTime = worker.time[3]; bridgeIsUsed = false; if (n == 0 \u0026amp;\u0026amp; pickOldCount == 0) { return t; } } newMinTime = Math.min(newMinTime, worker.leftTime); break; case \u0026#34;pickOld\u0026#34;: worker.leftTime -= minTime; if (worker.leftTime == 0) { worker.state = \u0026#34;waitBridge\u0026#34;; pq2.offer(worker); workerList.remove(i); i--; } else { newMinTime = Math.min(newMinTime, worker.leftTime); } break; case \u0026#34;putNew\u0026#34;: worker.leftTime -= minTime; if (worker.leftTime == 0) { worker.state = \u0026#34;waitBridge\u0026#34;; pq1.offer(worker); workerList.remove(i); i--; } else { newMinTime = Math.min(newMinTime, worker.leftTime); } break; } } if (!bridgeIsUsed \u0026amp;\u0026amp; !pq2.isEmpty()) { Worker poll = pq2.poll(); poll.state = \u0026#34;rightToLeft\u0026#34;; poll.leftTime = poll.time[2]; workerList.add(poll); newMinTime = Math.min(newMinTime, poll.leftTime); bridgeIsUsed = true; pickOldCount--; } if (!bridgeIsUsed \u0026amp;\u0026amp; n != 0 \u0026amp;\u0026amp; !pq1.isEmpty()) { Worker poll = pq1.poll(); poll.state = \u0026#34;leftToRight\u0026#34;; poll.leftTime = poll.time[0]; workerList.add(poll); newMinTime = Math.min(newMinTime, poll.leftTime); bridgeIsUsed = true; n--; } minTime = newMinTime; } } class Worker { String state; int leftTime, index; int[] time; public Worker(String state, int leftTime, int index, int[] time) { this.state = state; this.leftTime = leftTime; this.index = index; this.time = time; } } } References 1. 正整数和负整数的最大计数 2. 执行 K 次操作后的最大分数 3. 使字符串总不同字符的数目相等 4. 过桥的时间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-327/","summary":"思路 第一题 两种思路： 暴力解法 遍历一遍并统计 二分查找 因为数组是有序的，分别查找0的左边界和右边界就可以得到正数负数的范围了，注意左边界是第一个","title":"LeetCode 周赛 327"},{"content":"思路 第一题 不解释\n第二题 用count记录一下末尾有几个value，直接看代码\n第三题 其实就是计算数组各元素的异或，证明详见：https://leetcode.cn/problems/find-xor-beauty-of-array/solutions/2050337/no6289-cha-xun-shu-zu-xor-mei-li-zhi-by-d5ylk/\n第四题 利用二分查找的思想，从答案可能的区间里取中间的数，然后验证答案需要额外建造多少个供电站，最后判断修建的供电站是否超过 k ，如果超过说明选择的答案偏大，否则说明偏小，然后根据偏大还是偏小再进行二分就可以了\n看到「最大化最小值」或者「最小化最大值」（其实就是那种要求一堆数字尽量平均的题）就要想到二分答案，这是一个固定的套路。\n为什么？一般来说，二分的值越大，越能/不能满足要求；二分的值越小，越不能/能满足要求，有单调性，可以二分。\n这道题使用前缀和来确定各个城市的电量，然后二分搜索答案，验证答案时用到了差分数组\n因为没做出来就不贴代码了，详见：https://leetcode.cn/problems/maximize-the-minimum-powered-city/solutions/2050272/er-fen-da-an-qian-zhui-he-chai-fen-shu-z-jnyv/\n代码 第一题 class Solution { public String categorizeBox(int length, int width, int height, int mass) { long v = (long) length * width * height; boolean Bulky = length \u0026gt;= 10000 || width \u0026gt;= 10000 || height \u0026gt;= 10000 || v \u0026gt;= 1000000000; boolean Heavy = mass \u0026gt;= 100; if (Bulky \u0026amp;\u0026amp; Heavy) { return \u0026#34;Both\u0026#34;; } if (Bulky) { return \u0026#34;Bulky\u0026#34;; } if (Heavy) { return \u0026#34;Heavy\u0026#34;; } return \u0026#34;Neither\u0026#34;; } } 第二题 class DataStream { private int value, k, count; public DataStream(int value, int k) { this.value = value; this.k = k; this.count = 0; } public boolean consec(int num) { if (num == value) { count++; } else { count = 0; } return count \u0026gt;= k; } } 第三题 class Solution { public int xorBeauty(int[] nums) { int res = 0; for (int num : nums) { res ^= num; } return res; } } References 1. 根据规则将箱子分类 2. 找到数据流中的连续整数 3. 查询数组 Xor 美丽值 4. 最大化城市的最小供电站数目 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%8F%8C%E5%91%A8%E8%B5%9B-95/","summary":"思路 第一题 不解释 第二题 用count记录一下末尾有几个value，直接看代码 第三题 其实就是计算数组各元素的异或，证明详见：https://le","title":"LeetCode 双周赛 95"},{"content":"思路 利用二分查找的思路，每次选出一个中间元素，对于这个中间元素来说，左边和右边必有一个有序序列，那么我们可以分情况讨论，如果左边是有序序列，那么target \u0026lt; nums[mid] \u0026amp;\u0026amp; target \u0026gt;= nums[0]的情况target一定在左边，否则在右边，以此类推直到找到target\n代码 官方解答 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (target == nums[mid]) { return mid; } if (nums[mid] \u0026gt;= nums[0]) { if (target \u0026lt; nums[mid] \u0026amp;\u0026amp; target \u0026gt;= nums[0]) { right = mid - 1; } else { left = mid + 1; } } else { if (target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt; nums[0]) { left = mid + 1; } else { right = mid - 1; } } } return -1; } } 我的解法 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (target == nums[mid]) { return mid; } else if (target \u0026gt; nums[mid]) { if (target \u0026gt;= nums[0]) { if (nums[mid] \u0026lt; nums[0]) { right = mid - 1; } else { left = mid + 1; } } else { left = mid + 1; } } else if (target \u0026lt; nums[mid]) { if (target \u0026gt;= nums[0]) { right = mid - 1; } else { if (nums[mid] \u0026lt; nums[0]) { right = mid - 1; } else { left = mid + 1; } } } } return -1; } } References 1. 搜索旋转排序数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-33/","summary":"思路 利用二分查找的思路，每次选出一个中间元素，对于这个中间元素来说，左边和右边必有一个有序序列，那么我们可以分情况讨论，如果左边是有序序列，","title":"LeetCode 33"},{"content":"思路 三种思路：\n栈 定义一个栈，保证栈底为最后一个不匹配的右括号的下标，然后碰到左括号就入栈，碰到右括号就出栈，如果出栈后栈为空，说明当前的右括号没有相对应的左括号，那么此右括号就是最后一个不匹配的右括号，将其下标入栈，如果出栈后栈不为空，说明有相应的左括号，那么更新res最大值即可，为什么这样是正确的呢？因为栈里存的是最后一个不匹配的右括号和尚未匹配的左括号，任何一个有效括号序列一定是以这些元素开头，所以可以通过这种方式获取有效括号序列的长度\n动态规划 构建dp数组，数组里存放以该元素结尾的最长有效括号，状态转移方程为：\nif (s.charAt(i) == \u0026#39;(\u0026#39;) { dp[i] = 0; } else { if (s.charAt(i - 1) == \u0026#39;(\u0026#39;) { dp[i] = i - 2 \u0026gt;= 0 ? dp[i - 2] + 2 : 2; } else { if (i - dp[i - 1] - 1 \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i - dp[i - 1] - 1) == \u0026#39;(\u0026#39;) { dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2 \u0026gt;= 0 ? dp[i - dp[i - 1] - 2] : 0); } else { dp[i] = 0; } } } 当该元素为右括号，前面元素也是右括号时，先根据前面元素的有效括号长度找到有可能与该元素匹配的左括号，如果i - dp[i - 1] - 1位置的元素是左括号，那么就匹配上了dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2 \u0026gt;= 0 ? dp[i - dp[i - 1] - 2] : 0);，如果i - dp[i - 1] - 1位置的元素是右括号，则该元素的最长有效括号为0，生成dp数组元素的同时维护大值即可\nbase case为dp[-1] = dp[0] = 0，不能优化空间复杂度\n两次遍历 从左往右遍历一次，统计碰到的左括号的数量（left）和右括号的数量（right），如果left == right就记录长度，如果right\u0026gt;left，就让left和right归零，因为此时前面的元素都可以扔掉不考虑，但是这种情况无法判断(()这种情况，此时从右往左遍历一遍就可以了，如果right\u0026lt;left，就让left和right归零，遍历的同时维护最大值即可\n代码 栈 class Solution { public int longestValidParentheses(String s) { int n = s.length(), res = 0; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(-1); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { stack.push(i); } else { stack.pop(); if (stack.isEmpty()) { stack.push(i); } else { res = Math.max(res, i - stack.peek()); } } } return res; } } 动态规划 class Solution { public int longestValidParentheses(String s) { int n = s.length(), res = 0; int[] dp = new int[n]; for (int i = 1; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { dp[i] = 0; } else { if (s.charAt(i - 1) == \u0026#39;(\u0026#39;) { dp[i] = i - 2 \u0026gt;= 0 ? dp[i - 2] + 2 : 2; } else { if (i - dp[i - 1] - 1 \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i - dp[i - 1] - 1) == \u0026#39;(\u0026#39;) { dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2 \u0026gt;= 0 ? dp[i - dp[i - 1] - 2] : 0); } else { dp[i] = 0; } } } res = Math.max(res, dp[i]); } return res; } } 两次遍历 class Solution { public int longestValidParentheses(String s) { int left = 0, right = 0, res = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { left++; } else { right++; } if (left == right) { res = Math.max(res, left + right); } else if (left \u0026lt; right) { left = right = 0; } } left = right = 0; for (int i = s.length() - 1; i \u0026gt;= 0; i--) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { left++; } else { right++; } if (left == right) { res = Math.max(res, left + right); } else if (left \u0026gt; right) { left = right = 0; } } return res; } } References 1. 最长有效括号 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-32/","summary":"思路 三种思路： 栈 定义一个栈，保证栈底为最后一个不匹配的右括号的下标，然后碰到左括号就入栈，碰到右括号就出栈，如果出栈后栈为空，说明当前的右括","title":"LeetCode 32"},{"content":"思路 因为是下一个排列，所以更改的元素尽量靠右，并且需要变大，那么我们可以从右往左遍历，找到右侧存在比自己大的元素的元素（找这种元素可以从左往右遍历，第一个比后面元素小的元素就是要找的元素），更改的时候需要将该元素右侧比该元素大的最小元素替换到该位置，然后后面的元素从大到小排列，以保证变大的幅度尽可能小\n代码 class Solution { public void nextPermutation(int[] nums) { int n = nums.length, i = n - 2; while (i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i + 1]) { i--; } if (i \u0026gt;= 0) { int j = n - 1; while (nums[j] \u0026lt;= nums[i]) { j--; } swap(nums, i, j); } reverse(nums, i + 1); } private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } private void reverse(int[] nums, int begin) { int left = begin, right = nums.length - 1; while (left \u0026lt; right) { swap(nums, left, right); left++; right--; } } } References 1. 下一个排列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-31/","summary":"思路 因为是下一个排列，所以更改的元素尽量靠右，并且需要变大，那么我们可以从右往左遍历，找到右侧存在比自己大的元素的元素（找这种元素可以从左往","title":"LeetCode 31"},{"content":"思路 经典回溯问题，对于每个数字都有几种选择，套模板即可\n代码 class Solution { private List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); private char[][] table = new char[][]{ {}, {}, {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}, {\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;}, {\u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;}, {\u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;}, {\u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;v\u0026#39;}, {\u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;} }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits.isEmpty()) { return res; } backtrack(\u0026#34;\u0026#34;, digits, 0); return res; } private void backtrack(String s, String digits, int start) { if (start == digits.length()) { res.add(s); return; } char[] choices = table[digits.charAt(start) - \u0026#39;0\u0026#39;]; for (char c : choices) { backtrack(s + c, digits, start + 1); } } } References 1. 电话号码的字母组合 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-17/","summary":"思路 经典回溯问题，对于每个数字都有几种选择，套模板即可 代码 class Solution { private List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); private char[][] table = new char[][]{ {}, {}, {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}, {\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;}, {\u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;}, {\u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;}, {\u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;v\u0026#39;}, {\u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;,","title":"LeetCode 17"},{"content":"思路 利用双指针的思想，这道题不是想象中的那样使用Map，而是使用双指针，这题的难点在于去重，可以先排序，然后遍历每一个元素，同时根据遍历的这个元素找相对应的两个元素，为了去重，从该元素后面找（否则会有重复解），寻找这两个元素的时候就可以使用双指针，如果加起来过大，就right\u0026ndash;，过小就left++，遍历完所有元素即可\n代码 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { int n = nums.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; n; i++) { if (nums[i] \u0026gt; 0) { break; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1, right = n - 1, target = -nums[i]; while (left \u0026lt; right) { if (nums[left] + nums[right] == target) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); left++; right--; while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left - 1]) { left++; } while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right + 1]) { right--; } } else if (nums[left] + nums[right] \u0026gt; target) { right--; } else { left++; } } } return res; } } References 1. 三数之和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-15/","summary":"思路 利用双指针的思想，这道题不是想象中的那样使用Map，而是使用双指针，这题的难点在于去重，可以先排序，然后遍历每一个元素，同时根据遍历的这","title":"LeetCode 15"},{"content":"思路 简单粗暴版 将数字翻转过来，然后判断与翻转前的数字是否相等\n巧妙解法 只翻转一半即可，见代码\n代码 简单粗暴版 class Solution { public boolean isPalindrome(int x) { if (x \u0026lt; 0) { return false; } long res = 0, num = x; while (num != 0) { res = res * 10 + (num % 10); num /= 10; } return res == x; } } 巧妙解法 class Solution { public boolean isPalindrome(int x) { if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int num = 0; while (x \u0026gt; num) { num = num * 10 + (x % 10); x /= 10; } return num == x || num / 10 == x; } } References 1. 回文数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-9/","summary":"思路 简单粗暴版 将数字翻转过来，然后判断与翻转前的数字是否相等 巧妙解法 只翻转一半即可，见代码 代码 简单粗暴版 class Solution { public boolean isPalindrome(int x) { if (x \u0026lt; 0) { return false; } long res","title":"LeetCode 9"},{"content":"思路 两种思路：\n一次遍历 先去除前导空格，然后判断符号位，最后读取数字，注意溢出判断可以通过res除以10是否等于之前的res来判断，详见代码\n自动机 详见：https://leetcode.cn/problems/string-to-integer-atoi/solutions/183164/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/\n可以把这个当成模板\n代码 一次遍历 class Solution { public int myAtoi(String s) { int res = 0, sign = 1, i = 0, n = s.length(); for (; i \u0026lt; n; i++) { if (s.charAt(i) != \u0026#39; \u0026#39;) { break; } } if (i \u0026lt; n \u0026amp;\u0026amp; (s.charAt(i) == \u0026#39;+\u0026#39; || s.charAt(i) == \u0026#39;-\u0026#39;)) { if (s.charAt(i) == \u0026#39;-\u0026#39;) { sign = -1; } i++; } for (; i \u0026lt; n; i++) { if (s.charAt(i) \u0026lt; \u0026#39;0\u0026#39; || s.charAt(i) \u0026gt; \u0026#39;9\u0026#39;) { break; } int pre = res; res = res * 10 + s.charAt(i) - \u0026#39;0\u0026#39;; if (res / 10 != pre) { return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; } } return sign * res; } } 自动机 class Solution { public int myAtoi(String s) { Automaton automaton = new Automaton(); for (char c : s.toCharArray()) { automaton.get(c); } return (int) (automaton.sign * automaton.res); } class Automaton { int sign = 1; long res = 0; String state = \u0026#34;start\u0026#34;; Map\u0026lt;String, String[]\u0026gt; table = new HashMap\u0026lt;\u0026gt;() { { put(\u0026#34;start\u0026#34;, new String[]{\u0026#34;start\u0026#34;, \u0026#34;signed\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;signed\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;in_number\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;end\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;}); } }; public void get(char c) { state = table.get(state)[getCol(c)]; if (state == \u0026#34;in_number\u0026#34;) { res = res * 10 + c - \u0026#39;0\u0026#39;; res = sign == 1 ? Math.min(res, Integer.MAX_VALUE) : Math.min(res, -(long) Integer.MIN_VALUE); } else if (state == \u0026#34;signed\u0026#34;) { sign = c == \u0026#39;+\u0026#39; ? 1 : -1; } } private int getCol(char c) { if (c == \u0026#39; \u0026#39;) { return 0; } if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) { return 1; } if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return 2; } return 3; } } } References 1. 字符串转换整数 (atoi) ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-8/","summary":"思路 两种思路： 一次遍历 先去除前导空格，然后判断符号位，最后读取数字，注意溢出判断可以通过res除以10是否等于之前的res来判断，详见代码 自","title":"LeetCode 8"},{"content":"思路 每次取最后一位然后加到res上即可，需要注意这里的判断是否溢出：\nif (res \u0026gt; Integer.MAX_VALUE / 10 || res == Integer.MAX_VALUE / 10 \u0026amp;\u0026amp; num \u0026gt; 7) { return 0; } if (res \u0026lt; Integer.MIN_VALUE / 10 || res == Integer.MIN_VALUE / 10 \u0026amp;\u0026amp; num \u0026lt; -8) { return 0; } 但判断是否溢出还可以优化，res每次更新后除10，然后跟上一次的res比较一下，如果不相等，就是溢出：\nint pre = res; res = res * 10 + num; if (res / 10 != pre) { return 0; } 并且需要知道负数取余得到的结果还是负数\n代码 基本版 class Solution { public int reverse(int x) { int res = 0; while (x != 0) { int num = x % 10; if (res \u0026gt; Integer.MAX_VALUE / 10 || res == Integer.MAX_VALUE / 10 \u0026amp;\u0026amp; num \u0026gt; 7) { return 0; } if (res \u0026lt; Integer.MIN_VALUE / 10 || res == Integer.MIN_VALUE / 10 \u0026amp;\u0026amp; num \u0026lt; -8) { return 0; } res = res * 10 + num; x /= 10; } return res; } } 优化溢出判断 class Solution { public int reverse(int x) { int res = 0; while (x != 0) { int num = x % 10; int pre = res; res = res * 10 + num; if (res / 10 != pre) { return 0; } x /= 10; } return res; } } References 1. 整数反转 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-7/","summary":"思路 每次取最后一位然后加到res上即可，需要注意这里的判断是否溢出： if (res \u0026gt; Integer.MAX_VALUE / 10 || res == Integer.MAX_VALUE / 10 \u0026amp;\u0026amp; num \u0026gt; 7) { return 0; } if (res \u0026lt; Integer.MIN_VALUE / 10 || res == Integer.MIN_VALUE / 10 \u0026amp;\u0026amp; num \u0026lt; -8)","title":"LeetCode 7"},{"content":"思路 设置几个行，遍历字符串，每次将遍历到的字符加入行中，然后指针指向下一行，当指针到头之后，倒着改变指针就可以了\n代码 class Solution { public String convert(String s, int numRows) { if (numRows == 1) { return s; } StringBuilder[] rows = new StringBuilder[numRows]; for (int i = 0; i \u0026lt; numRows; i++) { rows[i] = new StringBuilder(); } int i = 0, flag = -1; for (char c : s.toCharArray()) { rows[i].append(c); if (i == 0 || i == numRows - 1) { flag = -flag; } i += flag; } StringBuilder res = new StringBuilder(); for (int j = 0; j \u0026lt; numRows; j++) { res.append(rows[j]); } return res.toString(); } } References 1. Z 字形变换 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-6/","summary":"思路 设置几个行，遍历字符串，每次将遍历到的字符加入行中，然后指针指向下一行，当指针到头之后，倒着改变指针就可以了 代码 class Solution { public String convert(String s, int numRows) { if (numRows","title":"LeetCode 6"},{"content":"思路 直接按位相加就可以了\n代码 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode res = new ListNode(), p = res; int c = 0; while (l1 != null || l2 != null) { int v1 = l1 == null ? 0 : l1.val; int v2 = l2 == null ? 0 : l2.val; p.next = new ListNode((v1 + v2 + c) % 10); p = p.next; c = (v1 + v2 + c) / 10; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; } if (c != 0) { p.next = new ListNode(c); } return res.next; } } References 1. 两数相加 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-2/","summary":"思路 直接按位相加就可以了 代码 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode res = new ListNode(), p = res; int c = 0; while (l1 != null || l2 != null) { int v1 = l1 == null ? 0 : l1.val; int v2 = l2 == null ? 0 : l2.val; p.next = new ListNode((v1 +","title":"LeetCode 2"},{"content":"思路 用map存一下，然后找有没有target - nums[i]即可，直接看代码\n代码 class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int n = nums.length; for (int i = 0; i \u0026lt; n; i++) { if (map.containsKey(target - nums[i])) { return new int[]{map.get(target - nums[i]), i}; } map.put(nums[i], i); } return null; } } References 1. 两数之和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1/","summary":"思路 用map存一下，然后找有没有target - nums[i]即可，直接看代码 代码 class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int n = nums.length; for (int i = 0; i \u0026lt; n; i++) {","title":"LeetCode 1"},{"content":"思路 第一题 挨个除就完事了，直接看代码\n第二题 遍历每个元素，并求出他们的质因数加入到set集合，最后统计set里的元素即可\n第三题 贪心算法，从左往右求出刚好小于k的数，统计数量即可\n第四题 用素数筛法求出所有素数，然后根据素数之差求出最接近的两个素数\n总结 这次比较简单，半小时结束战斗\n代码 第一题 class Solution { public int countDigits(int num) { int n = num, res = 0; while (n != 0) { if (num % (n % 10) == 0) { res++; } n = n / 10; } return res; } } 第二题 class Solution { public int distinctPrimeFactors(int[] nums) { Set\u0026lt;Integer\u0026gt; res = new HashSet\u0026lt;\u0026gt;(); for (int num : nums) { for (int i = 2; i \u0026lt;= num;) { if (num % i == 0) { res.add(i); num /= i; } else { i++; } } } return res.size(); } } 第三题 class Solution { public int minimumPartition(String s, int k) { int i = 0, j = 1, res = 0; while (i \u0026lt; s.length()) { long num = Long.parseLong(s.substring(i, j)); if (num \u0026gt; k) { if (j == i + 1) { return -1; } else { res++; i = j - 1; } } else { if (j == s.length()) { res++; break; } j++; } } return res; } } 第四题 class Solution { public int[] closestPrimes(int left, int right) { boolean[] isPrime = new boolean[right + 1]; Arrays.fill(isPrime, true); for (int i = 2; i \u0026lt;= right; i++) { if (!isPrime[i]) { continue; } for (int j = i + i; j \u0026lt;= right; j += i) { isPrime[j] = false; } } isPrime[0] = isPrime[1] = false; int[] res = new int[]{0, 1000000}; int pre = -1; for (int i = left; i \u0026lt;= right; i++) { if (!isPrime[i]) { continue; } if (pre == -1) { pre = i; } else { if (i - pre \u0026lt; res[1] - res[0]) { res[0] = pre; res[1] = i; } pre = i; } } return res[0] == 0 \u0026amp;\u0026amp; res[1] == 1000000 ? new int[]{-1, -1} : res; } } References 1. 统计能整除数字的位数 2. 数组乘积中的不同质因数数目 3. 将字符串分割成值不超过 K 的子字符串 4. 范围内最接近的两个质数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-326/","summary":"思路 第一题 挨个除就完事了，直接看代码 第二题 遍历每个元素，并求出他们的质因数加入到set集合，最后统计set里的元素即可 第三题 贪心算法，从左往","title":"LeetCode 周赛 326"},{"content":"思路 利用并查集的思想，有倍数关系的变量通过并查集连接起来，并且将边的权值设为边两头的结点的倍数大小，当求两个变量的倍数关系时，判断这两个结点是否连通，并且求出两个结点到根节点的权值相除即可，要特别注意路径压缩时权值的更新，详见：https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/\n代码 class Solution { public double[] calcEquation(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; equations, double[] values, List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; queries) { int equationSize = values.length; UF uf = new UF(2 * equationSize); int id = 0; Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; equationSize; i++) { String v1 = equations.get(i).get(0); String v2 = equations.get(i).get(1); if (!map.containsKey(v1)) { map.put(v1, id); id++; } if (!map.containsKey(v2)) { map.put(v2, id); id++; } uf.union(map.get(v1), map.get(v2), values[i]); } int queriesSize = queries.size(); double[] res = new double[queriesSize]; for (int i = 0; i \u0026lt; queriesSize; i++) { Integer id1 = map.get(queries.get(i).get(0)); Integer id2 = map.get(queries.get(i).get(1)); if (id1 == null || id2 == null) { res[i] = -1; } else { res[i] = uf.isConnected(id1, id2); } } return res; } class UF { private int[] parent; private double[] weight; public UF(int n) { parent = new int[n]; weight = new double[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; weight[i] = 1; } } public void union(int p, int q, double value) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) { return; } parent[rootP] = rootQ; weight[rootP] = value * weight[q] / weight[p]; } public double isConnected(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP != rootQ) { return -1; } else { return weight[p] / weight[q]; } } public int find(int x) { if (x != parent[x]) { int origin = parent[x]; parent[x] = find(parent[x]); weight[x] *= weight[origin]; } return parent[x]; } } } References 1. 除法求值 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-399/","summary":"思路 利用并查集的思想，有倍数关系的变量通过并查集连接起来，并且将边的权值设为边两头的结点的倍数大小，当求两个变量的倍数关系时，判断这两个结点","title":"LeetCode 399"},{"content":"思路 三种思路：\n简单朴素版 跟两个有序的数组合并思路一样，谁小就取谁，这样找到中间的那个就行了\n二分查找 其实这道题就是查找第k小的元素，那么我们每次从两个数组各取k/2个元素，比较第k/2个元素的大小，小的那个数组可以排除前k/2个元素了，然后再在剩下的元素里找第k/2小元素，循环往复，直到找第1小元素即可\n划分数组 就是每次对较短的那个数组二分，同时根据元素总数计算另一个数组应该怎么划分，保证左边的元素数量等于右边的，为了找到中位数，所以必须保证左边的最大值小于右边的最小值，如果不满足就根据左边右边的大小关系对较短数组再次二分，直到满足左边与右边元素数量相等，并且左边元素都小于右边元素，此时就找到了中位数\n代码 简单朴素版 class Solution { public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length; int n = B.length; int len = m + n; int left = -1, right = -1; int aStart = 0, bStart = 0; for (int i = 0; i \u0026lt;= len / 2; i++) { left = right; if (aStart \u0026lt; m \u0026amp;\u0026amp; (bStart \u0026gt;= n || A[aStart] \u0026lt; B[bStart])) { right = A[aStart++]; } else { right = B[bStart++]; } } if ((len \u0026amp; 1) == 0) return (left + right) / 2.0; else return right; } } 二分查找 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length, n = nums2.length; if ((m + n) % 2 == 0) { return (getKth(nums1, 0, nums2, 0, (m + n) / 2) + getKth(nums1, 0, nums2, 0, (m + n) / 2 + 1)) / 2.0; } else { return getKth(nums1, 0, nums2, 0, (m + n) / 2 + 1); } } private int getKth(int[] nums1, int start1, int[] nums2, int start2, int k) { if (start1 == nums1.length) { return nums2[start2 + k - 1]; } if (start2 == nums2.length) { return nums1[start1 + k - 1]; } if (k == 1) { return Math.min(nums1[start1], nums2[start2]); } int i = Math.min(nums1.length - 1, start1 + k / 2 - 1); int j = Math.min(nums2.length - 1, start2 + k / 2 - 1); if (nums1[i] \u0026gt; nums2[j]) { return getKth(nums1, start1, nums2, j + 1, k - (j - start2 + 1)); } else { return getKth(nums1, i + 1, nums2, start2, k - (i - start1 + 1)); } } } 划分数组 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length, n = nums2.length; if (m \u0026gt; n) { return findMedianSortedArrays(nums2, nums1); } int iMin = 0, iMax = m; while (iMin \u0026lt;= iMax) { int i = (iMax + iMin) / 2; int j = (m + n + 1) / 2 - i; if (j != 0 \u0026amp;\u0026amp; i != m \u0026amp;\u0026amp; nums1[i] \u0026lt; nums2[j - 1]) { iMin = i + 1; } else if (i != 0 \u0026amp;\u0026amp; j != n \u0026amp;\u0026amp; nums1[i - 1] \u0026gt; nums2[j]) { iMax = i - 1; } else { int maxLeft = 0; if (i == 0) { maxLeft = nums2[j - 1]; } else if (j == 0) { maxLeft = nums1[i - 1]; } else { maxLeft = Math.max(nums1[i - 1], nums2[j - 1]); } if ((m + n) % 2 == 1) { return maxLeft; } int minRight = 0; if (i == m) { minRight = nums2[j]; } else if (j == n) { minRight = nums1[i]; } else { minRight = Math.min(nums1[i], nums2[j]); } return (maxLeft + minRight) / 2.0; } } return -1; } } References 1. 寻找两个正序数组的中位数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-4/","summary":"思路 三种思路： 简单朴素版 跟两个有序的数组合并思路一样，谁小就取谁，这样找到中间的那个就行了 二分查找 其实这道题就是查找第k小的元素，那么我们每","title":"LeetCode 4"},{"content":"思路 两种思路：\n暴力解法 遍历数组，将每个元素当成正方形的左上角，并检查此时正方形的面积，计算最大值即可，代码略\n动态规划 同LeetCode-85，只不过85是矩形，这里是正方形，计算面积的时候注意长宽一致即可，其实也可以不用85这种思路，也可以建立dp数组，dp[i][j] = x表示以[i][j]元素为正方形右下角的正方形边长最长为x，状态转移方程为：\ndp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; 为什么状态转移方程是这样的，想象一下就知道了，base case为第一行和第一列，可以优化空间复杂度，通过动态规划计算最长边长就行了\n代码 class Solution { public int maximalSquare(char[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] dp_left = new int[m + 1][n + 1], dp_up = new int[m + 1][n + 1]; int res = 0; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (matrix[i - 1][j - 1] == \u0026#39;0\u0026#39;) { continue; } dp_left[i][j] = dp_left[i][j - 1] + 1; dp_up[i][j] = dp_up[i - 1][j] + 1; int up = Integer.MAX_VALUE; for (int left = 1; left \u0026lt;= dp_left[i][j]; left++) { up = Math.min(up, dp_up[i][j + 1 - left]); if (up \u0026lt; left) { break; } res = Math.max(res, left * left); } } } return res; } } References 1. 最大正方形 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-221/","summary":"思路 两种思路： 暴力解法 遍历数组，将每个元素当成正方形的左上角，并检查此时正方形的面积，计算最大值即可，代码略 动态规划 同LeetCode-85","title":"LeetCode 221"},{"content":"思路 两种思路：\n动态规划 构造两个dp数组，分别存放当前元素上面有几个连续的1和左边有几个连续的1，状态转移方程为：\ndp_left[i][j] = dp_left[i][j - 1] + 1; dp_up[i][j] = dp_up[i - 1][j] + 1; base case为第一行和第一列，怎么根据这两个dp数组计算面积才是重点，可以将竖着连续的1看成一个个柱体，然后把当前遍历的元素当成矩阵的右下角，从当前元素往左遍历，同时根据柱体的高度，计算面积，取面积最大值即可\n单调栈 感觉没什么看的必要，没看\n代码 动态规划 class Solution { public int maximalRectangle(char[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] dp_left = new int[m + 1][n + 1], dp_up = new int[m + 1][n + 1]; int res = 0; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (matrix[i - 1][j - 1] == \u0026#39;0\u0026#39;) { continue; } dp_left[i][j] = dp_left[i][j - 1] + 1; dp_up[i][j] = dp_up[i - 1][j] + 1; int up = Integer.MAX_VALUE; for (int left = 1; left \u0026lt;= dp_left[i][j]; left++) { up = Math.min(up, dp_up[i][j + 1 - left]); res = Math.max(res, left * up); } } } return res; } } References 1. 最大矩形 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-85/","summary":"思路 两种思路： 动态规划 构造两个dp数组，分别存放当前元素上面有几个连续的1和左边有几个连续的1，状态转移方程为： dp_left[i][j] = dp_left[i][j - 1] + 1; dp_up[i][j] = dp_up[i - 1][j] + 1;","title":"LeetCode 85"},{"content":"思路 根本思想就是将字符串删去字符的所有情况都找出来，所以可以用DFS爆搜，就是对于每个括号字符，要么删，要么不删，并且在搜索过程中将不合理的情况剪枝（直接return即可），比如右括号比左括号多的情况，左括号或者右括号删多了的情况，如此一来只对合理情况进行判断，如果字符串是合理的，并且删除的左右括号数量也正确，那这个字符串就是结果之一，将这些字符串加入Set去重即可\n详见：https://leetcode.cn/problems/remove-invalid-parentheses/solutions/1068652/gong-shui-san-xie-jiang-gua-hao-de-shi-f-asu8/\n代码 class Solution { private Set\u0026lt;String\u0026gt; res = new HashSet\u0026lt;\u0026gt;(); private int max, n, len = -1; private String str; public List\u0026lt;String\u0026gt; removeInvalidParentheses(String s) { str = s; n = s.length(); int left = 0, right = 0; int deleteLeft = 0, deleteRight = 0; for (char c : s.toCharArray()) { if (c == \u0026#39;(\u0026#39;) { left++; deleteLeft++; } else if (c == \u0026#39;)\u0026#39;) { right++; if (deleteLeft == 0) { deleteRight++; } else { deleteLeft--; } } } len = n - deleteLeft - deleteRight; max = Math.min(left, right); dfs(0, \u0026#34;\u0026#34;, deleteLeft, deleteRight, 0); return new ArrayList\u0026lt;\u0026gt;(res); } private void dfs(int start, String curr, int deleteLeft, int deleteRight, int score) { if (score \u0026lt; 0 || score \u0026gt; max || deleteLeft \u0026lt; 0 || deleteRight \u0026lt; 0) { return; } if (deleteLeft == 0 \u0026amp;\u0026amp; deleteRight == 0 \u0026amp;\u0026amp; curr.length() == len) { res.add(curr); } if (start == n) { return; } char c = str.charAt(start); if (c == \u0026#39;(\u0026#39;) { dfs(start + 1, curr + c, deleteLeft, deleteRight, score + 1); dfs(start + 1, curr,deleteLeft - 1, deleteRight, score); } else if (c == \u0026#39;)\u0026#39;) { dfs(start + 1, curr + c, deleteLeft, deleteRight, score - 1); dfs(start + 1, curr, deleteLeft, deleteRight - 1, score); } else { dfs(start + 1, curr + c, deleteLeft, deleteRight, score); } } } References 1. 删除无效的括号 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-301/","summary":"思路 根本思想就是将字符串删去字符的所有情况都找出来，所以可以用DFS爆搜，就是对于每个括号字符，要么删，要么不删，并且在搜索过程中将不合理的","title":"LeetCode 301"},{"content":"思路 两种思路：\n排序+检测位置不对的元素 先复制数组，然后排序，再比较排序后的数组和原数组，看看哪些位置不对即可\nO(N)时间复杂度 由于无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界，所以遍历两次确定这两个边界就可以了，详见代码\n代码 排序+检测位置不对的元素 public int findUnsortedSubarray(int[] nums) { int[] sortNums = Arrays.copyOf(nums, nums.length); Arrays.sort(sortNums); int left = -1, right = -2; for (int i = 0; i \u0026lt; nums.length; i++) { if (sortNums[i] != nums[i]) { if (left == -1) { left = i; right = i; } else { right = i; } } } return right - left + 1; } O(N)时间复杂度 class Solution { public int findUnsortedSubarray(int[] nums) { int n = nums.length, max = Integer.MIN_VALUE, right = -2; for (int i = 0; i \u0026lt; n; i++) { if (nums[i] \u0026lt; max) { right = i; } else { max = nums[i]; } } int min = Integer.MAX_VALUE, left = -1; for (int i = n - 1; i \u0026gt;= 0; i--) { if (nums[i] \u0026gt; min) { left = i; } else { min = nums[i]; } } return right - left + 1; } } References 1. 最短无序连续子数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-581/","summary":"思路 两种思路： 排序+检测位置不对的元素 先复制数组，然后排序，再比较排序后的数组和原数组，看看哪些位置不对即可 O(N)时间复杂度 由于无序子数组","title":"LeetCode 581"},{"content":"思路 两种思路：\n暴力枚举 把所有情况都列举出来，直接看代码\n动态规划 这里需要构建两个dp数组，因为以当前元素结尾的乘积最大子数组不一定是由前面元素结尾的乘积最大子数组推出来的，也有可能是由乘积最小子数组推出来的，所以需要dp_min和dp_max连个数组，里面存放以当前元素结尾的乘积最小子数组和乘积最大子数组，状态转移方程为：\ndp_max[i] = Math.max(nums[i], Math.max(nums[i] * dp_max[i - 1], nums[i] * dp_min[i - 1])); dp_min[i] = Math.min(nums[i], Math.min(nums[i] * dp_max[i - 1], nums[i] * dp_min[i - 1])); base case为dp_min[0] = dp_max[0] = nums[0];，可以优化空间复杂度\n代码 暴力枚举 class Solution { public int maxProduct(int[] nums) { int res = Integer.MIN_VALUE, n = nums.length; for (int i = 0; i \u0026lt; n; i++) { int mul = 1; for (int j = i; j \u0026lt; n; j++) { mul *= nums[j]; res = Math.max(res, mul); } } return res; } } 动态规划 class Solution { public int maxProduct(int[] nums) { int n = nums.length; int[] dp_min = new int[n], dp_max = new int[n]; dp_min[0] = dp_max[0] = nums[0]; int res = dp_max[0]; for (int i = 1; i \u0026lt; n; i++) { dp_max[i] = Math.max(nums[i], Math.max(nums[i] * dp_max[i - 1], nums[i] * dp_min[i - 1])); dp_min[i] = Math.min(nums[i], Math.min(nums[i] * dp_max[i - 1], nums[i] * dp_min[i - 1])); res = Math.max(res, dp_max[i]); } return res; } } References 1. 乘积最大子数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-152/","summary":"思路 两种思路： 暴力枚举 把所有情况都列举出来，直接看代码 动态规划 这里需要构建两个dp数组，因为以当前元素结尾的乘积最大子数组不一定是由前面元素","title":"LeetCode 152"},{"content":"思路 两种思路：\nDFS 遍历二叉树的所有结点，遍历到每个结点同时计算以此结点为头部，往下拓展有几个路径之和为target的情况，求和即可\n前缀和 基本思想同LeetCode-560，我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 curr 减去 targetSum，其实跟LeetCode-560一样，就是变成了二叉树的前缀和，而且要注意需要提前记录前缀和0，遍历完当前结点记得从map中去除当前的前缀和\n代码 DFS class Solution { public int pathSum(TreeNode root, int targetSum) { if (root == null) { return 0; } int res = 0; res += rootSum(root, targetSum); res += pathSum(root.left, targetSum); res += pathSum(root.right, targetSum); return res; } private int rootSum(TreeNode root, long targetSum) { if (root == null) { return 0; } int res = 0; if (targetSum == root.val) { res++; } return rootSum(root.left, targetSum - root.val) + rootSum(root.right, targetSum - root.val) + res; } } 前缀和 class Solution { private Map\u0026lt;Long, Integer\u0026gt; preSumMap = new HashMap\u0026lt;\u0026gt;(); public int pathSum(TreeNode root, int targetSum) { preSumMap.put(0L, 1); return dfs(root, 0, targetSum); } private int dfs(TreeNode root, long preSum, int targetSum) { if (root == null) { return 0; } preSum += root.val; int res = 0; res += preSumMap.getOrDefault(preSum - targetSum, 0); preSumMap.put(preSum, preSumMap.getOrDefault(preSum, 0) + 1); res += dfs(root.left, preSum, targetSum); res += dfs(root.right, preSum, targetSum); preSumMap.put(preSum, preSumMap.get(preSum) - 1); return res; } } References 1. 路径总和 III ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-437/","summary":"思路 两种思路： DFS 遍历二叉树的所有结点，遍历到每个结点同时计算以此结点为头部，往下拓展有几个路径之和为target的情况，求和即可 前缀和 基本思","title":"LeetCode 437"},{"content":"思路 从右上角看成一颗二叉搜索树即可，如果当前元素大于target说明整列都大于target，所以这一列可以忽略，去掉这一列的矩阵还是一个矩阵，如果当前元素小于target说明整行都小于target，所以这一行可以忽略，去掉这一行的矩阵还是一个矩阵，循环往复，其实就是一个Z字形查找，如果能找到，那就返回，如果查找时超过了边界，那就是查找失败\n代码 class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int i = 0, j = n - 1; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0) { if (matrix[i][j] == target) { return true; } else if (matrix[i][j] \u0026gt; target) { j--; } else if (matrix[i][j] \u0026lt; target) { i++; } } return false; } } References 1. 搜索二维矩阵 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-240/","summary":"思路 从右上角看成一颗二叉搜索树即可，如果当前元素大于target说明整列都大于target，所以这一列可以忽略，去掉这一列的矩阵还是一个矩阵","title":"LeetCode 240"},{"content":"思路 三种思路：\n中心扩展法 遍历字符串，然后从中心扩展，同时统计回文串的数量\n动态规划 设置dp数组，dp[i][j] = x代表[i\u0026hellip;j]字符串是否是回文串，状态转移方程为：dp[i][j] = s.charAt(i) == s.charAt(j) \u0026amp;\u0026amp; (j - i \u0026lt; 2 || dp[i + 1][j - 1])，base case为下半个三角都是true，可以优化空间复杂度\n马拉车算法 没看太懂，感觉不太重要，大致来说就是中心扩展法的优化，可以在O(N)时间内完成中心扩展法这个流程，基本思想就是假如已知一个回文串，那么在这个回文串中左右对称的那两个字符，中心扩展的回文串是一样的（如果扩展的范围没有超过原回文串的范围）\n代码 中心扩展法 class Solution { public int countSubstrings(String s) { int n = s.length(), res = 0; res += countSubstrings(s, 0, 0); for (int i = 1; i \u0026lt; n; i++) { res += countSubstrings(s, i, i); res += countSubstrings(s, i - 1, i); } return res; } private int countSubstrings(String s, int i, int j) { int res = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(i) == s.charAt(j)) { res++; i--; j++; } return res; } } 动态规划 class Solution { public int countSubstrings(String s) { int n = s.length(), res = 0; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = i; j \u0026lt; n; j++) { if (s.charAt(i) == s.charAt(j) \u0026amp;\u0026amp; (j - i \u0026lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; res++; } } } return res; } } References 1. 回文子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-647/","summary":"思路 三种思路： 中心扩展法 遍历字符串，然后从中心扩展，同时统计回文串的数量 动态规划 设置dp数组，dp[i][j] = x代表[i\u0026hellip;j","title":"LeetCode 647"},{"content":"思路 利用前缀和的思想，从左往右遍历一遍，从右往左遍历一遍同时记录该数组的左右乘积，每个元素的左乘积乘以右乘积就是答案，还可以优化空间复杂度，把返回数组res当成左乘积数组，同时用一个变量充当右乘积，详见代码\n代码 前缀和 class Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] L = new int[n], R = new int[n]; L[0] = 1; for (int i = 1; i \u0026lt; n; i++) { L[i] = L[i - 1] * nums[i - 1]; } R[n - 1] = 1; for (int i = n - 2; i \u0026gt;= 0; i--) { R[i] = R[i + 1] * nums[i + 1]; } int[] res = new int[n]; for (int i = 0; i \u0026lt; n; i++) { res[i] = L[i] * R[i]; } return res; } } 前缀和+空间复杂度优化 class Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] res = new int[n]; res[0] = 1; for (int i = 1; i \u0026lt; n; i++) { res[i] = res[i - 1] * nums[i - 1]; } int R = 1; for (int i = n - 1; i \u0026gt;= 0; i--) { res[i] = res[i] * R; R *= nums[i]; } return res; } } References 1. 除自身以外数组的乘积 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-238/","summary":"思路 利用前缀和的思想，从左往右遍历一遍，从右往左遍历一遍同时记录该数组的左右乘积，每个元素的左乘积乘以右乘积就是答案，还可以优化空间复杂度，","title":"LeetCode 238"},{"content":"思路 这道题明显符合贪心性质，即每次选择需要执行次数最多的且可以执行的任务，这样执行完任务所需的时间就是最优解，以此为根据有两种思路：\n模拟 建立一个大根堆，里面放各种任务所需的执行次数，每次弹出min(queue.size(),n)这么多个元素，每个元素都让他都减一，然后再把元素放回去，res += n，最终得到的res就是答案\n脑筋急转弯-构造（桶思想） 如下图，把一轮任务的执行想象成一个桶即可，如果能把桶填满，那所需时间就是tasks.length，如果不能那就是桶所占的空间，会不会出现C这个任务在第四行开始，然后排到下一列的第三行呢？这样的话C的执行就冲突了，答：不会，因为我们是按照降序的顺序将任务排列的，如果这样的话C就有5个了，一定会单独占一列，从中间开始排，说明C肯定是小于5的\n详见：https://leetcode.cn/problems/task-scheduler/solutions/196302/tong-zi-by-popopop/\n代码 模拟 class Solution { public int leastInterval(char[] tasks, int n) { Map\u0026lt;Character, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (char task : tasks) { counter.put(task, counter.getOrDefault(task, 0) + 1); } Queue\u0026lt;Integer\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b - a; }); for (Integer value : counter.values()) { queue.offer(value); } int res = 0; while (!queue.isEmpty()) { int count = n + 1; List\u0026lt;Integer\u0026gt; temp = new LinkedList\u0026lt;\u0026gt;(); while (!queue.isEmpty() \u0026amp;\u0026amp; count != 0) { int i = queue.poll() - 1; res++; count--; if (i != 0) { temp.add(i); } } if (!temp.isEmpty()) { res += count; } queue.addAll(temp); } return res; } } 脑筋急转弯-构造（桶思想） class Solution { public int leastInterval(char[] tasks, int n) { int max = Integer.MIN_VALUE; Map\u0026lt;Character, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (char task : tasks) { counter.put(task, counter.getOrDefault(task, 0) + 1); max = Math.max(max, counter.get(task)); } int count = 0; for (Integer value : counter.values()) { if (value == max) { count++; } } return Math.max(tasks.length, (max - 1) * (n + 1) + count); } } References 1. 任务调度器 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-621/","summary":"思路 这道题明显符合贪心性质，即每次选择需要执行次数最多的且可以执行的任务，这样执行完任务所需的时间就是最优解，以此为根据有两种思路： 模拟 建立","title":"LeetCode 621"},{"content":"思路 两种思路：\n递归（DFS） 直接看代码\n迭代（BFS） 构建三个队列，分别存放需要合并子结点的合并后的结点、相应的第一颗树的结点、相应的第二颗树的结点，然后每次从三个队列里各取一个，然后看看应该怎么合并他们的子结点，详见：https://leetcode.cn/problems/merge-two-binary-trees/solutions/424201/he-bing-er-cha-shu-by-leetcode-solution/\n代码 递归（DFS） class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null \u0026amp;\u0026amp; root2 == null) { return null; } if (root1 != null \u0026amp;\u0026amp; root2 != null) { root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left, root2.left); root1.right = mergeTrees(root1.right, root2.right); return root1; } return root1 != null ? root1 : root2; } } 迭代（BFS） class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) { return root2; } if (root2 == null) { return root1; } TreeNode root = new TreeNode(root1.val + root2.val); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue1 = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue2 = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root);queue1.offer(root1);queue2.offer(root2); while (!queue.isEmpty()) { TreeNode node = queue.poll(), node1 = queue1.poll(), node2 = queue2.poll(); TreeNode left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right; if (left1 != null || left2 != null) { if (left1 != null \u0026amp;\u0026amp; left2 != null) { TreeNode left = new TreeNode(left1.val + left2.val); node.left = left; queue.offer(left); queue1.offer(left1); queue2.offer(left2); } else { node.left = left1 != null ? left1 : left2; } } if (right1 != null || right2 != null) { if (right1 != null \u0026amp;\u0026amp; right2 != null) { TreeNode right = new TreeNode(right1.val + right2.val); node.right = right; queue.offer(right); queue1.offer(right1); queue2.offer(right2); } else { node.right = right1 != null ? right1 : right2; } } } return root; } } References 1. 合并二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-617/","summary":"思路 两种思路： 递归（DFS） 直接看代码 迭代（BFS） 构建三个队列，分别存放需要合并子结点的合并后的结点、相应的第一颗树的结点、相应的第二颗树","title":"LeetCode 617"},{"content":"思路 两种思路：\n枚举 把所有情况都求出来，简单粗暴\n前缀和+哈希表优化 利用前缀和的思想，假如[i\u0026hellip;j]的和为k，那么就是preSum[j] - preSum[i - 1] == k -\u0026gt; preSum[j] - k == preSum[i - 1]，那么遍历到preSum[j]时，只要判断一下preSum[j]前有没有元素等于preSum[j] - k就可以了，为了加快查找速度，可以设置map，key为preSum里的元素，value为该元素值的个数，详见：https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/\n代码 枚举 class Solution { public int subarraySum(int[] nums, int k) { int n = nums.length, res = 0; for (int i = 0; i \u0026lt; n; i++) { int sum = 0; for (int j = i; j \u0026lt; n; j++) { sum += nums[j]; if (sum == k) { res++; } } } return res; } } 前缀和+哈希表优化 class Solution { public int subarraySum(int[] nums, int k) { int n = nums.length, pre = 0, res = 0; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, 1); for (int i = 0; i \u0026lt; n; i++) { pre += nums[i]; if (map.containsKey(pre - k)) { res += map.get(pre - k); } map.put(pre, map.getOrDefault(pre, 0) + 1); } return res; } } References 1. 和为 K 的子数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-560/","summary":"思路 两种思路： 枚举 把所有情况都求出来，简单粗暴 前缀和+哈希表优化 利用前缀和的思想，假如[i\u0026hellip;j]的和为k，那么就是preSum","title":"LeetCode 560"},{"content":"思路 先将x和y异或，再运用x \u0026amp; (x - 1)去除x最右侧的1（即Brian Kernighan算法），即可统计1的数目\n代码 class Solution { public int hammingDistance(int x, int y) { int z = x ^ y, res = 0; while (z != 0) { z = z \u0026amp; (z - 1); res++; } return res; } } References ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-461/","summary":"思路 先将x和y异或，再运用x \u0026amp; (x - 1)去除x最右侧的1（即Brian Kernighan算法），即可统计1的数目 代码 class Solution { public int hammingDistance(int x, int y) { int z =","title":"LeetCode 461"},{"content":"思路 原地哈希即可，同LeetCode-41\n代码 class Solution { public List\u0026lt;Integer\u0026gt; findDisappearedNumbers(int[] nums) { int n = nums.length, i = 0; while (i \u0026lt; n) { if (nums[i] == nums[nums[i] - 1]) { i++; continue; } swap(nums, i, nums[i] - 1); } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); for (int j = 0; j \u0026lt; n; j++) { if (nums[j] != j + 1) { res.add(j + 1); } } return res; } private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } References 1. 找到所有数组中消失的数字 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-448/","summary":"思路 原地哈希即可，同LeetCode-41 代码 class Solution { public List\u0026lt;Integer\u0026gt; findDisappearedNumbers(int[] nums) { int n = nums.length, i = 0; while (i \u0026lt; n) { if (nums[i] == nums[nums[i] - 1]) { i++; continue; } swap(nums, i, nums[i] - 1); } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); for (int j = 0; j","title":"LeetCode 448"},{"content":"思路 我们可以将每个人按照身高从大到小进行排序，然后依次将每个人放入队列中，那么当我们放入第 i 个人时，由于之后的人都比 i 矮，所以不会对 i 当前的插入位置产生影响，所以此时 i 插入的位置其实已经确定了，就是people[i][1]个人后面\n代码 class Solution { public int[][] reconstructQueue(int[][] people) { List\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); Arrays.sort(people, (a, b) -\u0026gt; { if (a[0] == b[0]) { return a[1] - b[1]; } return b[0] - a[0]; }); for (int i = 0; i \u0026lt; people.length; i++) { queue.add(people[i][1], people[i]); } queue.toArray(people); return people; } } References 1. 根据身高重建队列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-406/","summary":"思路 我们可以将每个人按照身高从大到小进行排序，然后依次将每个人放入队列中，那么当我们放入第 i 个人时，由于之后的人都比 i 矮，所以不会对 i 当前的","title":"LeetCode 406"},{"content":"思路 两种思路：\n递归 一种是模拟递归（就是我写的），一种是利用文法（见：https://leetcode.cn/problems/decode-string/solutions/264391/zi-fu-chuan-jie-ma-by-leetcode-solution/）\n模拟递归就是从左往右遍历字符串，碰到字母就加入结果中，碰到数字就读取数字，碰到\u0026rsquo;[\u0026lsquo;就递归获取中括号里面的字符串用于拼接，碰到\u0026rsquo;]\u0026lsquo;就直接返回，因为这里碰到\u0026rsquo;]\u0026lsquo;就说明本次调用是求[]里面的字符串，正常情况下是不会碰到\u0026rsquo;]\u0026lsquo;的，遍历完字符串就得到了结果\n栈 遍历这个字符串：\n如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈 如果当前的字符为字母或者左括号，直接进栈 如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈 重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。\n代码 递归 class Solution { public String decodeString(String s) { StringBuilder sb = new StringBuilder(); int num = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) { sb.append(c); } else if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { num = num * 10 + c - \u0026#39;0\u0026#39;; } else if (c == \u0026#39;[\u0026#39;) { String str = decodeString(s.substring(i + 1)); while (num != 0) { sb.append(str); num--; } int needRight = 0; while (needRight != -1) { i++; c = s.charAt(i); if (c == \u0026#39;[\u0026#39;) { needRight++; } if (c == \u0026#39;]\u0026#39;) { needRight--; } } } else if (c == \u0026#39;]\u0026#39;) { return sb.toString(); } } return sb.toString(); } } 栈 class Solution { public String decodeString(String s) { int n = s.length(), i = 0; Deque\u0026lt;String\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); while (i \u0026lt; n) { char c = s.charAt(i); if (Character.isLetter(c) || c == \u0026#39;[\u0026#39;) { stack.push(String.valueOf(c)); i++; } else if (Character.isDigit(c)) { int num = 0; while (Character.isDigit(s.charAt(i))) { num = num * 10 + s.charAt(i) - \u0026#39;0\u0026#39;; i++; } stack.push(String.valueOf(num)); } else if (c == \u0026#39;]\u0026#39;) { i++; String sub = \u0026#34;\u0026#34;; while (!stack.peek().equals(\u0026#34;[\u0026#34;)) { sub = stack.pop() + sub; } stack.pop(); int num = Integer.parseInt(stack.pop()); String t = \u0026#34;\u0026#34;; while (num != 0) { t = t + sub; num--; } stack.push(t); } } String res = \u0026#34;\u0026#34;; while (!stack.isEmpty()) { res = stack.pop() + res; } return res; } } References 1. 字符串解码 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-394/","summary":"思路 两种思路： 递归 一种是模拟递归（就是我写的），一种是利用文法（见：https://leetcode.cn/problems/decode-","title":"LeetCode 394"},{"content":"思路 简单粗暴版 用map统计次数，用优先队列根据次数选择前k个，具体看代码\n最小堆 用map统计次数，然后将map转为entry数组，原问题就转换为了求数组里的前 k 大的值，这个问题用最小堆即可解决，同LeetCode-215\n快速选择 用map统计次数，然后将map转为entry数组，原问题就转换为了求数组里的前 k 大的值，利用快速选择的思想，每次随机确定一个中枢的位置，如果比中枢大的元素等于k个，那就找到了这k个元素，如果小于k个，那么就确定了比中枢大的几个元素，其他元素在中枢左边，对左边继续这个过程，如果大于k个，对右边继续这个过程\n代码 简单粗暴版 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { counter.put(num, counter.getOrDefault(num, 0) + 1); } Queue\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b.getValue() - a.getValue(); }); pq.addAll(counter.entrySet()); int[] res = new int[k]; for (int i = 0; i \u0026lt; k; i++) { res[i] = pq.poll().getKey(); } return res; } } 最小堆 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { counter.put(num, counter.getOrDefault(num, 0) + 1); } Queue\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(k, (a, b) -\u0026gt; { return a.getValue() - b.getValue(); }); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : counter.entrySet()) { if (pq.size() \u0026lt; k) { pq.offer(entry); } else { if (entry.getValue() \u0026gt; pq.peek().getValue()) { pq.poll(); pq.offer(entry); } } } int[] res = new int[k]; for (int i = 0; i \u0026lt; k; i++) { res[i] = pq.poll().getKey(); } return res; } } 快速选择 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { counter.put(num, counter.getOrDefault(num, 0) + 1); } Map.Entry\u0026lt;Integer, Integer\u0026gt;[] entries = new Map.Entry[counter.size()]; counter.entrySet().toArray(entries); int[] res = new int[k]; quickSort(entries, 0, entries.length - 1, res, 0, k); return res; } private void quickSort(Map.Entry\u0026lt;Integer, Integer\u0026gt;[] entries, int left, int right, int[] res, int resIndex, int k) { int picked = new Random().nextInt(right - left + 1) + left; swap(entries, left, picked); int pivot = entries[left].getValue(); int index = left; for (int i = left + 1; i \u0026lt;= right; i++) { if (entries[i].getValue() \u0026gt; pivot) { swap(entries, index + 1, i); index++; } } swap(entries, left, index); if (index - left \u0026gt; k) { quickSort(entries, left, index - 1, res, resIndex, k); } else { for (int i = left; i \u0026lt; index; i++) { res[resIndex++] = entries[i].getKey(); } if (index - left \u0026lt;= k -1) { res[resIndex++] = entries[index].getKey(); if (index - left \u0026lt; k -1) { quickSort(entries, index + 1, right, res, resIndex, k - index + left - 1); } } } } private void swap(Map.Entry\u0026lt;Integer, Integer\u0026gt;[] entries, int a, int b) { Map.Entry\u0026lt;Integer, Integer\u0026gt; temp = entries[a]; entries[a] = entries[b]; entries[b] = temp; } } References 1. 前 K 个高频元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-347/","summary":"思路 简单粗暴版 用map统计次数，用优先队列根据次数选择前k个，具体看代码 最小堆 用map统计次数，然后将map转为entry数组，原问题就转换","title":"LeetCode 347"},{"content":"思路 两种思路：\n常规思路 可以使用i \u0026amp; (i - 1)可以去掉i最右边的一个1这个技巧，提升计算一个数比特1数目的速度\n动态规划 对于所有的数字，只有两类：\n奇数，二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1 偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的 另外，0 的 1 个数为 0，这就是base case，动态规划即可，dp定义与状态转移方程详见代码\n还有其他动态规划的方式，详见：https://leetcode.cn/problems/counting-bits/solutions/627418/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/\n代码 常规思路 class Solution { public int[] countBits(int n) { int[] res = new int[n + 1]; for (int i = 0; i \u0026lt;= n; i++) { res[i] = getCount(i); } return res; } private int getCount(int n) { int count = 0; while (n != 0) { n = n \u0026amp; (n - 1); count++; } return count; } } 动态规划 class Solution { public int[] countBits(int n) { int[] dp = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { if (i % 2 == 1) { dp[i] = dp[i - 1] + 1; } else { dp[i] = dp[i / 2]; } } return dp; } } References 1. 比特位计数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-338/","summary":"思路 两种思路： 常规思路 可以使用i \u0026amp; (i - 1)可以去掉i最右边的一个1这个技巧，提升计算一个数比特1数目的速度 动态规划 对于所有的数字，只有两类：","title":"LeetCode 338"},{"content":"思路 原地哈希即可，将1-n的数字放在索引0-n-1里面，这样最后再遍历一遍，不满足这个规则的就是缺失的第一个正数\n代码 class Solution { public int firstMissingPositive(int[] nums) { int n = nums.length, i = 0; while (i \u0026lt; n) { if (nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= n \u0026amp;\u0026amp; nums[nums[i] - 1] != nums[i]) { swap(nums, i, nums[i] - 1); } else { i++; } } for (int j = 0; j \u0026lt; n; j++) { if (nums[j] != j + 1) { return j + 1; } } return n + 1; } private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } References 1. 缺失的第一个正数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-41/","summary":"思路 原地哈希即可，将1-n的数字放在索引0-n-1里面，这样最后再遍历一遍，不满足这个规则的就是缺失的第一个正数 代码 class Solution { public int firstMissingPositive(int[] nums) { int n = nums.length,","title":"LeetCode 41"},{"content":"思路 原地哈希 将元素和索引一一对应，不对应的交换元素使其对应，当碰到对应索引已经有相应的元素时，就找到了重复的元素\n快慢指针 将索引对应的元素当成下一个索引，按照这个逻辑把数组转换为链表，由于肯定存在重复元素，所以肯定会有多对一的映射，所以该链表一定会有环，那么这个问题就转换为了存在环的链表中寻找环起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置，直接返回即可，详见：https://leetcode.cn/problems/find-the-duplicate-number/solutions/58841/287xun-zhao-zhong-fu-shu-by-kirsche/\n二分查找 可以在1-n中取中点mid，遍历一边nums，如果小于等于mid的元素\u0026gt;mid说明重复元素一定在mid的左边，然后二分查找即可，这样比1-n一个一个查找要快，因为一次可以排除一半\n二进制 没看，感觉没什么卵用\n代码 原地哈希 class Solution { public int findDuplicate(int[] nums) { int n = nums.length, i = 0; while (i \u0026lt; n) { if (nums[i] == i + 1) { i++; continue; } if (nums[nums[i] - 1] == nums[i]) { return nums[i]; } swap(nums, i, nums[i] - 1); } return -1; } private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } 快慢指针 class Solution { public int findDuplicate(int[] nums) { int slow = 0, fast = 0; slow = nums[slow]; fast = nums[nums[fast]]; while (slow != fast) { slow = nums[slow]; fast = nums[nums[fast]]; } fast = 0; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } } 二分查找 class Solution { public int findDuplicate(int[] nums) { int left = 1, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; int count = 0; for (int num : nums) { if (num \u0026lt;= mid) { count++; } } if (count \u0026gt; mid) { right = mid; } else { left = mid + 1; } } return left; } } References 1. 寻找重复数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-287/","summary":"思路 原地哈希 将元素和索引一一对应，不对应的交换元素使其对应，当碰到对应索引已经有相应的元素时，就找到了重复的元素 快慢指针 将索引对应的元素当成","title":"LeetCode 287"},{"content":"思路 记忆化回溯 就是带备忘录的暴力算法，numSquares函数的定义为给定一个数n，返回n的完全平方数，具体做法就是将一个数有可能的平方数一个一个试，看看用哪个数最终答案会比较小，然后存进备忘录并返回，由于记忆化回溯等价于动态规划，所以还有动态规划的做法\n动态规划 设置dp数组，dp数组李存放当前索引的完全平方数，状态转移方程为：\nfor (int j = 1; j \u0026lt;= sqrt; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } base case为dp[0] = 0，不能优化空间复杂度\n数学 四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。详见：https://leetcode.cn/problems/perfect-squares/solutions/822940/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/\n代码 记忆化回溯 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int numSquares(int n) { if (n == 0) { return 0; } if (memo.containsKey(n)) { return memo.get(n); } int sqrt = (int) Math.sqrt(n); int min = Integer.MAX_VALUE; for (int i = sqrt; i \u0026gt;= 1; i--) { min = Math.min(min, numSquares( n - i * i)); } memo.put(n, min + 1); return min + 1; } } 动态规划 class Solution { public int numSquares(int n) { int[] dp = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { int sqrt = (int) Math.sqrt(i); dp[i] = Integer.MAX_VALUE; for (int j = 1; j \u0026lt;= sqrt; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } } return dp[n]; } } 数学 class Solution { public int numSquares(int n) { if (isPerfectSquare(n)) { return 1; } if (isAnswer4(n)) { return 4; } int sqrt = (int) Math.sqrt(n); for (int i = 1; i \u0026lt;= sqrt; i++) { if (isPerfectSquare(n - i * i)) { return 2; } } return 3; } private boolean isPerfectSquare(int n) { int sqrt = (int) Math.sqrt(n); return n == sqrt * sqrt; } private boolean isAnswer4(int n) { while (n % 4 == 0) { n /= 4; } return n % 8 == 7; } } References 1. 完全平方数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-279/","summary":"思路 记忆化回溯 就是带备忘录的暴力算法，numSquares函数的定义为给定一个数n，返回n的完全平方数，具体做法就是将一个数有可能的平方数一","title":"LeetCode 279"},{"content":"思路 两种思路：\n记忆化回溯 回溯算法暴力求解，一个一个单词试，不行就回溯，由于存在大量重叠子问题，所以可以用备忘录消除重叠子问题，又因为带备忘录的回溯就相当于动态规划，所以有了第二种思路\n动态规划 构建dp数组，数组元素为从当前索引元素开始的字符串，是否能被表示，状态转移方程为：\nfor (String word : wordList) { if (match(s, i, word) \u0026amp;\u0026amp; dp[i + word.length()]) { dp[i] = true; break; } } base case为dp数组最后一个元素设为true，不能优化空间复杂度\n代码 记忆化回溯 class Solution { private Map\u0026lt;Character, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private Map\u0026lt;Integer, Boolean\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { if (!map.containsKey(word.charAt(0))) { map.put(word.charAt(0), new LinkedList\u0026lt;\u0026gt;()); } map.get(word.charAt(0)).add(word); } return backtrack(s, 0); } private boolean backtrack(String s, int start) { if (start == s.length()) { return true; } if (memo.containsKey(start)) { return memo.get(start); } List\u0026lt;String\u0026gt; wordList = map.get(s.charAt(start)); if (wordList == null) { memo.put(start, false); return false; } for (String word : wordList) { if (!match(s, start, word)) { continue; } if (backtrack(s, start + word.length())) { return true; } } memo.put(start, false); return false; } private boolean match(String s, int start, String p) { if (p.length() \u0026gt; s.length() - start) { return false; } for (int i = 0; i \u0026lt; p.length(); i++) { if (s.charAt(start + i) != p.charAt(i)) { return false; } } return true; } } 动态规划 class Solution { private Map\u0026lt;Character, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { if (!map.containsKey(word.charAt(0))) { map.put(word.charAt(0), new LinkedList\u0026lt;\u0026gt;()); } map.get(word.charAt(0)).add(word); } boolean[] dp = new boolean[s.length() + 1]; dp[s.length()] = true; for (int i = s.length() - 1; i \u0026gt;= 0; i--) { List\u0026lt;String\u0026gt; wordList = map.get(s.charAt(i)); if (wordList == null) { continue; } for (String word : wordList) { if (match(s, i, word) \u0026amp;\u0026amp; dp[i + word.length()]) { dp[i] = true; break; } } } return dp[0]; } private boolean match(String s, int start, String p) { if (p.length() \u0026gt; s.length() - start) { return false; } for (int i = 0; i \u0026lt; p.length(); i++) { if (s.charAt(start + i) != p.charAt(i)) { return false; } } return true; } } References 1. 单词拆分 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-139/","summary":"思路 两种思路： 记忆化回溯 回溯算法暴力求解，一个一个单词试，不行就回溯，由于存在大量重叠子问题，所以可以用备忘录消除重叠子问题，又因为带备忘录","title":"LeetCode 139"},{"content":"思路 两种思路：\n最小堆 维护一个有 K 个元素的最小堆：\n如果当前堆不满，直接添加；\n堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新遍历到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。\n数组遍历完之后堆顶就是要找的元素\n快速选择 像快排一样随机确定一个中枢所在的位置，如果这个位置刚好就是要求的第k大的元素，就直接返回，否则根据中枢与target的大小关系选择是中枢左边还是右边继续随机确定一个中枢所在的位置，直到找到target，详见思想篇章\n代码 最小堆 class Solution { public int findKthLargest(int[] nums, int k) { Queue\u0026lt;Integer\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; k; i++) { queue.offer(nums[i]); } for (int i = k; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; queue.peek()) { queue.poll(); queue.offer(nums[i]); } } return queue.peek(); } } 快速选择 class Solution { public int findKthLargest(int[] nums, int k) { int target = nums.length - k, left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int pivotIndex = partition(nums, left, right); if (pivotIndex \u0026gt; target) { right = pivotIndex - 1; } else if (pivotIndex \u0026lt; target) { left = pivotIndex + 1; } else { return nums[target]; } } return -1; } private int partition(int[] nums, int left, int right) { int randomIndex = new Random().nextInt(right - left + 1) + left; swap(nums, left, randomIndex); int pivot = nums[left]; while (left \u0026lt; right) { while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) { right--; } nums[left] = nums[right]; while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt;= pivot) { left++; } nums[right] = nums[left]; } nums[left] = pivot; return left; } private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } References 1. 数组中的第K个最大元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-215/","summary":"思路 两种思路： 最小堆 维护一个有 K 个元素的最小堆： 如果当前堆不满，直接添加； 堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只","title":"LeetCode 215"},{"content":"思路 值得学习的就两种思路：\n哈希 遍历一遍统计出现次数，并同时判断有没有超过n/2\nBoyer-Moore 投票算法 设置一个count变量和候选数字，遍历数组，如果当前遍历的元素是候选数字count++，否则count\u0026ndash;，如果count变量为0就将候选数字设置为当前遍历的元素，这样遍历到最后，候选数字就是众数，可以这样理解，因为众数一定比其他数字加一块还多，所以最后众数一定会超过其他数字，那么一定会在某一个时刻候选数字变成众数，详见题解：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/\n代码 哈希 class Solution { public int majorityElement(int[] nums) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int n = nums.length; for (int i = 0; i \u0026lt; n; i++) { map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); if (map.get(nums[i]) \u0026gt; n / 2) { return nums[i]; } } return -1; } } Boyer-Moore 投票算法 class Solution { public int majorityElement(int[] nums) { int candidate = 0, count = 0; for (int num : nums) { if (count == 0) { candidate = num; } count += candidate == num ? 1 : -1; } return candidate; } } References 1. 多数元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-169/","summary":"思路 值得学习的就两种思路： 哈希 遍历一遍统计出现次数，并同时判断有没有超过n/2 Boyer-Moore 投票算法 设置一个count变量和候选数字，遍历数组，如果当前","title":"LeetCode 169"},{"content":"思路 这道题的关键是getMin的实现，可以用一个辅助栈来存储每个元素入栈时的最小值，这样的话当元素出栈时也可以很容易的获取最小值\n代码 class MinStack { private Deque\u0026lt;Integer\u0026gt; stack, minStack; public MinStack() { this.stack = new ArrayDeque\u0026lt;\u0026gt;(); this.minStack = new ArrayDeque\u0026lt;\u0026gt;(); minStack.push(Integer.MAX_VALUE); } public void push(int val) { stack.push(val); minStack.push(val \u0026lt; minStack.peek() ? val : minStack.peek()); } public void pop() { stack.pop(); minStack.pop(); } public int top() { return stack.peek(); } public int getMin() { return minStack.peek(); } } References 1. 最小栈 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-155/","summary":"思路 这道题的关键是getMin的实现，可以用一个辅助栈来存储每个元素入栈时的最小值，这样的话当元素出栈时也可以很容易的获取最小值 代码 class MinStack { private","title":"LeetCode 155"},{"content":"思路 逆向思维，利用滑动窗口的思想，从两头删去k+个abc，相当于中间的区间中abc的数目小于其总数减去k，这样就可以使用滑动窗口解决了，模板见思想篇章\n代码 class Solution { public int takeCharacters(String s, int k) { int ka = 0, kb = 0, kc = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;a\u0026#39;) { ka++; } if (c == \u0026#39;b\u0026#39;) { kb++; } if (c == \u0026#39;c\u0026#39;) { kc++; } } ka -= k; kb -= k; kc -= k; if (ka \u0026lt; 0 || kb \u0026lt; 0 || kc \u0026lt; 0) { return -1; } int left = 0, right = 0, res = Integer.MIN_VALUE; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (c == \u0026#39;a\u0026#39;) { ka--; } if (c == \u0026#39;b\u0026#39;) { kb--; } if (c == \u0026#39;c\u0026#39;) { kc--; } while (ka \u0026lt; 0 || kb \u0026lt; 0 || kc \u0026lt; 0) { char d = s.charAt(left); left++; if (d == \u0026#39;a\u0026#39;) { ka++; } if (d == \u0026#39;b\u0026#39;) { kb++; } if (d == \u0026#39;c\u0026#39;) { kc++; } } res = Math.max(res, right - left); } return s.length() - res; } } References 1. 每种字符至少取 K 个 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-6270/","summary":"思路 逆向思维，利用滑动窗口的思想，从两头删去k+个abc，相当于中间的区间中abc的数目小于其总数减去k，这样就可以使用滑动窗口解决了，模板","title":"LeetCode 6270"},{"content":"思路 贪心算法，每次选择字典序较大的字符串的第一个字符拼接到merge后即可，唯一要记住的点是字符串比较大小的方式，见零碎部分\n代码 class Solution { public String largestMerge(String word1, String word2) { StringBuilder sb1 = new StringBuilder(word1); StringBuilder sb2 = new StringBuilder(word2); StringBuilder merge = new StringBuilder(); while (sb1.length() != 0 || sb2.length() != 0) { if (sb1.toString().compareTo(sb2.toString()) \u0026gt; 0) { merge.append(sb1.charAt(0)); sb1.deleteCharAt(0); } else { merge.append(sb2.charAt(0)); sb2.deleteCharAt(0); } } return merge.toString(); } } References 1. 构造字典序最大的合并字符串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1754/","summary":"思路 贪心算法，每次选择字典序较大的字符串的第一个字符拼接到merge后即可，唯一要记住的点是字符串比较大小的方式，见零碎部分 代码 class Solution { public String largestMerge(String","title":"LeetCode 1754"},{"content":"思路 同LeetCode-392，就是比较多个字符串\n代码 class Solution { public int numMatchingSubseq(String s, String[] words) { int n = s.length(); Map\u0026lt;Character, List\u0026lt;Integer\u0026gt;\u0026gt; index = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { char c = s.charAt(i); if (!index.containsKey(c)) { index.put(c, new ArrayList\u0026lt;\u0026gt;()); } index.get(c).add(i); } int res = 0; for (String word : words) { int j = 0, i = 0; for (; i \u0026lt; word.length(); i++) { char c = word.charAt(i); List\u0026lt;Integer\u0026gt; arr = index.get(c); if (arr == null) { break; } int pos = left_bound(arr, j); if (pos == -1) { break; } j = arr.get(pos) + 1; } if (i == word.length()) { res++; } } return res; } private int left_bound(List\u0026lt;Integer\u0026gt; nums, int target) { int left = 0, right = nums.size() - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026lt;= nums.get(mid)) { right = mid; } else { left = mid + 1; } } if (nums.get(left) \u0026lt; target) { return -1; } return left; } } References 1. 匹配子序列的单词数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-792/","summary":"思路 同LeetCode-392，就是比较多个字符串 代码 class Solution { public int numMatchingSubseq(String s, String[] words) { int n = s.length(); Map\u0026lt;Character, List\u0026lt;Integer\u0026gt;\u0026gt; index = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { char c = s.charAt(i); if (!index.containsKey(c)) { index.put(c, new ArrayList\u0026lt;\u0026gt;()); } index.get(c).add(i); }","title":"LeetCode 792"},{"content":"思路 将t中的字符及其位置都存到一个map中去，然后判断s中的字符是否都存在于该map中，并且该字符在t中的位置在前一个字符在t中的位置的后面，为了快速找到该位置的字符，可以用二分查找，因为位置在数组中是递增有序的，详见代码\n代码 class Solution { public boolean isSubsequence(String s, String t) { int m = s.length(), n = t.length(); Map\u0026lt;Character, List\u0026lt;Integer\u0026gt;\u0026gt; index = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { char c = t.charAt(i); if (!index.containsKey(c)) { index.put(c, new ArrayList\u0026lt;\u0026gt;()); } index.get(c).add(i); } int j = 0; for (int i = 0; i \u0026lt; m; i++) { char c = s.charAt(i); List\u0026lt;Integer\u0026gt; arr = index.get(c); if (arr == null) { return false; } int pos = left_bound(arr, j); if (pos == -1) { return false; } j = arr.get(pos) + 1; } return true; } private int left_bound(List\u0026lt;Integer\u0026gt; nums, int target) { int left = 0, right = nums.size() - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026lt;= nums.get(mid)) { right = mid; } else { left = mid + 1; } } if (nums.get(left) \u0026lt; target) { return -1; } return left; } } References 1. 判断子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-392/","summary":"思路 将t中的字符及其位置都存到一个map中去，然后判断s中的字符是否都存在于该map中，并且该字符在t中的位置在前一个字符在t中的位置的后面","title":"LeetCode 392"},{"content":"思路 从「面积」和「顶点」两个维度来判断：\n1、判断面积，通过完美矩形的理论坐标计算出一个理论面积，然后和 rectangles 中小矩形的实际面积和做对比。\n2、判断顶点，points 集合中应该只剩下 4 个顶点且剩下的顶点必须都是完美矩形的理论顶点。\n详见代码\n代码 class Solution { public boolean isRectangleCover(int[][] rectangles) { int n = rectangles.length; Set\u0026lt;String\u0026gt; points = new HashSet\u0026lt;\u0026gt;(); int X1 = Integer.MAX_VALUE, X2 = Integer.MIN_VALUE, Y1 = Integer.MAX_VALUE, Y2 = Integer.MIN_VALUE, area = 0; for (int i = 0; i \u0026lt; n; i++) { X1 = Math.min(X1, rectangles[i][0]); X2 = Math.max(X2, rectangles[i][2]); Y1 = Math.min(Y1, rectangles[i][1]); Y2 = Math.max(Y2, rectangles[i][3]); area += (rectangles[i][2] - rectangles[i][0]) * (rectangles[i][3] - rectangles[i][1]); String p1 = rectangles[i][0] + \u0026#34;,\u0026#34; + rectangles[i][1]; String p2 = rectangles[i][2] + \u0026#34;,\u0026#34; + rectangles[i][3]; String p3 = rectangles[i][0] + \u0026#34;,\u0026#34; + rectangles[i][3]; String p4 = rectangles[i][2] + \u0026#34;,\u0026#34; + rectangles[i][1]; for (String p : new String[]{p1, p2, p3, p4}) { if (points.contains(p)) { points.remove(p); } else { points.add(p); } } } if (area != (X2 - X1) * (Y2 - Y1)) { return false; } if (points.size() != 4) { return false; } if (!points.contains(X1 + \u0026#34;,\u0026#34; + Y1)) { return false; } if (!points.contains(X1 + \u0026#34;,\u0026#34; + Y2)) { return false; } if (!points.contains(X2 + \u0026#34;,\u0026#34; + Y1)) { return false; } if (!points.contains(X2 + \u0026#34;,\u0026#34; + Y2)) { return false; } return true; } } References 1. 完美矩形 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-391/","summary":"思路 从「面积」和「顶点」两个维度来判断： 1、判断面积，通过完美矩形的理论坐标计算出一个理论面积，然后和 rectangles 中小矩形的实际面积和做对比。 2、判断","title":"LeetCode 391"},{"content":"思路 利用双指针的思想，每次移动比较小的那个，同时维护左右指针之间的盛水最大值即可\n代码 class Solution { public int maxArea(int[] height) { int left = 0, right = height.length - 1; int res = 0; while (left \u0026lt; right) { int area = Math.min(height[left], height[right]) * (right - left); res = Math.max(res, area); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return res; } } References 1. 盛最多水的容器 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-11/","summary":"思路 利用双指针的思想，每次移动比较小的那个，同时维护左右指针之间的盛水最大值即可 代码 class Solution { public int maxArea(int[] height) { int left = 0, right = height.length - 1; int res = 0; while (left \u0026lt; right) { int area","title":"LeetCode 11"},{"content":"思路 四种思路：\n按列求 只需要找到每一列左边最大值和右边最大值的较小值，就可以求出这一列可以接多少雨水\n动态规划 按列求中，求左边右边的最大值是一个一个遍历的，这个过程可以优化一下，构建dp_left和dp_right数组，里面存放当前元素左边的最大值（右边的最大值），状态转移方程为：dp_left[i] = Math.max(height[i - 1], dp_left[i - 1])，base case为dp[0] = 0，可以优化空间复杂度\n双指针 其实就是动态规划的优化空间复杂度版本，每个格子能装多少水取决于这个格子左边最高的格子和右边最高的格子，所以可以使用双指针，分别指向左边和右边的格子，遍历这个数组，当左边最大值小于右边最大值时就可以确定左指针的元素能装多少水，因为能装多少水取决于这个格子左边最高的格子和右边最高的格子，而左边最大值小于右边最大值，即使右边有更大的也对结果没影响，然后移动左指针，并且更新左边的最大值即可\n单调栈 维护一个单调不增栈，当碰到元素大于栈顶时，出栈，然后取新栈顶和当前元素的较小值，将较小值减去出栈元素就是接的雨水的高度，再乘以新栈顶和当前元素的距离就是接的雨水，直到碰到比当前元素大的栈顶，将当前元素入栈，维护栈为单调不减栈的作用是保证每次计算的雨水都是一层或多层的雨水，详见：https://leetcode.cn/problems/trapping-rain-water/solutions/9112/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/\n代码 按列求 略\n动态规划 class Solution { public int trap(int[] height) { int n = height.length, max = 0; int[] left = new int[n], right = new int[n]; for (int i = 0; i \u0026lt; n; i++) { left[i] = max; max = Math.max(max, height[i]); } max = 0; for (int i = n - 1; i \u0026gt;= 0; i--) { right[i] = max; max = Math.max(max, height[i]); } int res = 0; for (int i = 0; i \u0026lt; n; i++) { if (Math.min(left[i], right[i]) \u0026gt; height[i]) { res += Math.min(left[i], right[i]) - height[i]; } } return res; } } 双指针 class Solution { public int trap(int[] height) { int left = 0, right = height.length - 1; int l_max = height[left], r_max = height[right]; int res = 0; while (left \u0026lt;= right) { l_max = Math.max(l_max, height[left]); r_max = Math.max(r_max, height[right]); if (l_max \u0026lt; r_max) { res += l_max - height[left]; left++; } else { res += r_max - height[right]; right--; } } return res; } } 单调栈 class Solution { public int trap(int[] height) { Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int i = 0, n = height.length, res = 0; while (i \u0026lt; n) { while (!stack.isEmpty() \u0026amp;\u0026amp; height[i] \u0026gt; height[stack.peek()]) { int h = height[stack.pop()]; if (stack.isEmpty()) { break; } int distance = i - stack.peek() - 1; res += (Math.min(height[i], height[stack.peek()]) - h) * distance; } stack.push(i); i++; } return res; } } References 1. 接雨水 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-42/","summary":"思路 四种思路： 按列求 只需要找到每一列左边最大值和右边最大值的较小值，就可以求出这一列可以接多少雨水 动态规划 按列求中，求左边右边的最大值是一个","title":"LeetCode 42"},{"content":"思路 利用双指针遍历两个区间集合，谁的终点小，谁往前走，同时判断两个指针指向的区间是否有交集，详见代码\n代码 class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { int m = firstList.length, n = secondList.length; int i = 0, j = 0; List\u0026lt;int[]\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026lt; n) { if (firstList[i][1] \u0026gt;= secondList[j][0] \u0026amp;\u0026amp; firstList[i][0] \u0026lt;= secondList[j][1]) { res.add(new int[]{Math.max(firstList[i][0], secondList[j][0]), Math.min(firstList[i][1], secondList[j][1])}); } if (firstList[i][1] \u0026gt; secondList[j][1]) { j++; } else { i++; } } int[][] ans = new int[res.size()][]; return res.toArray(ans); } } References 1. 区间列表的交集 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-986/","summary":"思路 利用双指针遍历两个区间集合，谁的终点小，谁往前走，同时判断两个指针指向的区间是否有交集，详见代码 代码 class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { int m = firstList.length, n = secondList.length; int","title":"LeetCode 986"},{"content":"思路 先按起点排序，然后寻找可以合并的最大终点即可\n代码 class Solution { public int[][] merge(int[][] intervals) { int n = intervals.length; Arrays.sort(intervals, (a, b) -\u0026gt; { return a[0] - b[0]; }); List\u0026lt;int[]\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); res.add(intervals[0]); for (int i = 1; i \u0026lt; n; i++) { int[] last = res.get(res.size() - 1); if (intervals[i][0] \u0026lt;= last[1]) { last[1] = Math.max(intervals[i][1], last[1]); } else { res.add(intervals[i]); } } int[][] ans = new int[res.size()][]; return res.toArray(ans); } } References 1. 合并区间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-56/","summary":"思路 先按起点排序，然后寻找可以合并的最大终点即可 代码 class Solution { public int[][] merge(int[][] intervals) { int n = intervals.length; Arrays.sort(intervals, (a, b) -\u0026gt; { return a[0] - b[0]; }); List\u0026lt;int[]\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); res.add(intervals[0]); for (int i = 1; i \u0026lt; n; i++) { int[] last = res.get(res.size() - 1);","title":"LeetCode 56"},{"content":"思路 先按起点排序，然后遍历，如果终点小于之前最大的终点，那这个区间就可以被覆盖\n代码 class Solution { public int removeCoveredIntervals(int[][] intervals) { int n = intervals.length; Arrays.sort(intervals, (a, b) -\u0026gt; { if (a[0] == b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); int res = n, right = intervals[0][1]; for (int i = 1; i \u0026lt; n; i++) { if (intervals[i][1] \u0026lt;= right) { res--; } else { right = intervals[i][1]; } } return res; } } References 1. 删除被覆盖区间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1288/","summary":"思路 先按起点排序，然后遍历，如果终点小于之前最大的终点，那这个区间就可以被覆盖 代码 class Solution { public int removeCoveredIntervals(int[][] intervals) { int n = intervals.length; Arrays.sort(intervals, (a, b) -\u0026gt; { if (a[0] == b[0]) { return b[1] - a[1]; } return a[0]","title":"LeetCode 1288"},{"content":"思路 同LeetCode-921，只不过需要注意当右括号差一个的时候需要补齐右括号\n代码 class Solution { public int minInsertions(String s) { int res = 0, need = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39;) { need += 2; if (need % 2 == 1) { res++; need--; } } else { need--; if (need == -1) { need = 1; res++; } } } return res + need; } } References 1. 平衡括号字符串的最少插入次数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1541/","summary":"思路 同LeetCode-921，只不过需要注意当右括号差一个的时候需要补齐右括号 代码 class Solution { public int minInsertions(String s) { int res = 0, need = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c =","title":"LeetCode 1541"},{"content":"思路 设置left和right变量，代表需要的左括号数量和右括号数量，从左往右遍历一遍，碰到左括号right++，碰到右括号right\u0026ndash;，当right\u0026lt;0时，说明左括号不够了，那就left++，最后left+right就是需要的左右括号数量\n代码 class Solution { public int minAddToMakeValid(String s) { int left = 0, right = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39;) { right++; } else { right--; if (right == -1) { right = 0; left++; } } } return left + right; } } References 1. 使括号有效的最少添加 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-921/","summary":"思路 设置left和right变量，代表需要的左括号数量和右括号数量，从左往右遍历一遍，碰到左括号right++，碰到右括号right\u0026nda","title":"LeetCode 921"},{"content":"思路 用栈即可，直接看代码\n代码 class Solution { public boolean isValid(String s) { Deque\u0026lt;Character\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } else { if (stack.isEmpty() || stack.pop() != leftOf(c)) { return false; } } } return stack.isEmpty(); } private char leftOf(char c) { if (c == \u0026#39;)\u0026#39;) { return \u0026#39;(\u0026#39;; } if (c == \u0026#39;]\u0026#39;) { return \u0026#39;[\u0026#39;; } if (c == \u0026#39;}\u0026#39;) { return \u0026#39;{\u0026#39;; } return \u0026#39; \u0026#39;; } } References 1. 有效的括号 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-20/","summary":"思路 用栈即可，直接看代码 代码 class Solution { public boolean isValid(String s) { Deque\u0026lt;Character\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } else { if (stack.isEmpty() || stack.pop() != leftOf(c)) { return false; } } }","title":"LeetCode 20"},{"content":"思路 根本思想是建立一个栈，栈里存放目前遍历到的数字，比如1-2+3，栈里存放1、-2、3，最后将栈里的数字相加即可，详见：https://labuladong.gitee.io/algo/4/33/127/\n代码 class Solution { private int calculate(StringBuilder sb) { Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int num = 0; char sign = \u0026#39;+\u0026#39;; while (sb.length() \u0026gt; 0) { char c = sb.charAt(0); sb.deleteCharAt(0); if (isDigit(c)) { num = num * 10 + c - \u0026#39;0\u0026#39;; } if (c == \u0026#39;(\u0026#39;) { num = calculate(sb); } if (!isDigit(c) \u0026amp;\u0026amp; c != \u0026#39; \u0026#39; || sb.length() == 0) { switch (sign) { case \u0026#39;+\u0026#39;: stack.push(num); break; case \u0026#39;-\u0026#39;: stack.push(-num); break; case \u0026#39;*\u0026#39;: stack.push(stack.pop() * num); break; case \u0026#39;/\u0026#39;: stack.push(stack.pop() / num); break; } sign = c; num = 0; } if (c == \u0026#39;)\u0026#39;) { break; } } int res = 0; while (!stack.isEmpty()) { res += stack.pop(); } return res; } public int calculate(String s) { return calculate(new StringBuilder(s)); } private boolean isDigit(char c) { if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return true; } return false; } } References 1. 基本计算器 2. 基本计算器 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-224+227/","summary":"思路 根本思想是建立一个栈，栈里存放目前遍历到的数字，比如1-2+3，栈里存放1、-2、3，最后将栈里的数字相加即可，详见：https://l","title":"LeetCode 224+227"},{"content":"思路 就是大整数乘法，用列式计算的方式计算两个字符串的乘积，如下图所示：\n详见：https://labuladong.gitee.io/algo/4/33/126/\n代码 class Solution { public String multiply(String num1, String num2) { char[] n1 = num1.toCharArray(); char[] n2 = num2.toCharArray(); int l1 = n1.length, l2 = n2.length; int[] res = new int[l1 + l2]; for (int i = l1 - 1; i \u0026gt;= 0; i--) { for (int j = l2 - 1; j \u0026gt;= 0; j--) { int mul = (n1[i] - \u0026#39;0\u0026#39;) * (n2[j] - \u0026#39;0\u0026#39;); int sum = mul + res[i + j + 1]; res[i + j + 1] = sum % 10; res[i + j] += sum / 10; } } int offset = 0; while (offset \u0026lt; res.length \u0026amp;\u0026amp; res[offset] == 0) { offset++; } StringBuilder sb = new StringBuilder(); for (int i = offset; i \u0026lt; res.length; i++) { sb.append(res[i]); } return sb.length() == 0 ? \u0026#34;0\u0026#34; : sb.toString(); } } References 1. 字符串相乘 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-43/","summary":"思路 就是大整数乘法，用列式计算的方式计算两个字符串的乘积，如下图所示： 详见：https://labuladong.gitee.io/algo","title":"LeetCode 43"},{"content":"思路 从前往后遍历，遍历到一个元素v，只要能将所有元素分配到一个序列中即可，关键在于，我们怎么知道当前元素 v 如何进行分配呢？\n肯定得分情况讨论，把情况讨论清楚了，题目也就做出来了。\n总共有两种情况：\n1、当前元素 v 自成一派，「以自己开头」构成一个长度至少为 3 的序列。\n2、当前元素 v 接到已经存在的子序列后面。\n如果这两种情况都可以，应该优先判断自己是否能够接到其他序列后面，因为只要能自成一派，那接在其他序列后面肯定没问题，接在其他序列后面没问题，不一定能自成一派，用两个hash表即可实现这个过程，详见代码\n代码 class Solution { public boolean isPossible(int[] nums) { Map\u0026lt;Integer, Integer\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { freq.put(num, freq.getOrDefault(num, 0) + 1); } for (int num : nums) { if (freq.get(num) == 0) { continue; } if (need.getOrDefault(num, 0) \u0026gt; 0) { freq.put(num, freq.get(num) - 1); need.put(num, need.get(num) - 1); need.put(num + 1, need.getOrDefault(num + 1, 0) + 1); } else if (freq.getOrDefault(num, 0) \u0026gt; 0 \u0026amp;\u0026amp; freq.getOrDefault(num + 1, 0) \u0026gt; 0 \u0026amp;\u0026amp; freq.getOrDefault(num + 2, 0) \u0026gt; 0) { freq.put(num, freq.get(num) - 1); freq.put(num + 1, freq.get(num + 1) - 1); freq.put(num + 2, freq.get(num + 2) - 1); need.put(num + 3, need.getOrDefault(num + 3, 0) + 1); } else { return false; } } return true; } } References 1. 分割数组为连续子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-659/","summary":"思路 从前往后遍历，遍历到一个元素v，只要能将所有元素分配到一个序列中即可，关键在于，我们怎么知道当前元素 v 如何进行分配呢？ 肯定得分情况讨论，","title":"LeetCode 659"},{"content":"思路 经典分治思想，根据式子的运算符分成左右两个子问题，然后将两个子问题合并，就得到了原问题的答案，详见思想篇章\n代码 class Solution { private Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; diffWaysToCompute(String expression) { if (memo.containsKey(expression)) { return memo.get(expression); } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; expression.length(); i++) { char c = expression.charAt(i); if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39;) { List\u0026lt;Integer\u0026gt; left = diffWaysToCompute(expression.substring(0, i)); List\u0026lt;Integer\u0026gt; right = diffWaysToCompute(expression.substring(i + 1)); for (Integer l : left) { for (Integer r : right) { if (c == \u0026#39;+\u0026#39;) { res.add(l + r); } else if (c == \u0026#39;*\u0026#39;) { res.add(l * r); } else if (c == \u0026#39;-\u0026#39;) { res.add(l - r); } } } } } if (res.isEmpty()) { res.add(Integer.parseInt(expression)); } memo.put(expression, res); return res; } } References 1. 为运算表达式设计优先级 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-241/","summary":"思路 经典分治思想，根据式子的运算符分成左右两个子问题，然后将两个子问题合并，就得到了原问题的答案，详见思想篇章 代码 class Solution { private Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; diffWaysToCompute(String","title":"LeetCode 241"},{"content":"思路 幂可以转换为以下形式：\n这样就可以运用递归了，至于模幂运算运用(a * b) % k = ((a % k) * (b % k)) % k即可，详见思想篇章\n还可以运用高效求幂，详见思想\n代码 基本版 class Solution { private int base = 1337; public int superPow(int a, int[] b) { return superPow(a, b, b.length); } private int superPow(int a, int[] b, int len) { if (len == 0) { return 1; } int last = b[len - 1]; int p1 = myPow(a, last); int p2 = myPow(superPow(a, b, len - 1), 10); return (p1 * p2) % base; } private int myPow(int a, int b) { a %= base; int res = 1; while (b != 0) { res = (res * a) % base; b--; } return res; } } 高效版 class Solution { private int base = 1337; public int superPow(int a, int[] b) { return superPow(a, b, b.length); } private int superPow(int a, int[] b, int len) { if (len == 0) { return 1; } int last = b[len - 1]; int p1 = myPow(a, last); int p2 = myPow(superPow(a, b, len - 1), 10); return (p1 * p2) % base; } private int myPow(int a, int b) { if (b == 0) { return 1; } a %= base; if (b % 2 == 1) { return (a * myPow(a, b - 1)) % base; } else { int res = myPow(a, b / 2); return (res * res) % base; } } } References 1. 超级次方 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-372/","summary":"思路 幂可以转换为以下形式： 这样就可以运用递归了，至于模幂运算运用(a * b) % k = ((a % k) * (b % k)) % k即可，详见思想篇章 还可以运用高效求幂，详见思","title":"LeetCode 372"},{"content":"思路 经典素数筛选法，详见思想篇章\n代码 class Solution { public int countPrimes(int n) { boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); double sqrtn = Math.sqrt(n); for (int i = 2; i \u0026lt; sqrtn; i++) { if (isPrime[i]) { for (int j = i * i; j \u0026lt; n; j += i) { isPrime[j] = false; } } } int count = 0; for (int i = 2; i \u0026lt; n; i++) { if (isPrime[i]) { count++; } } return count; } } References 1. 计数质数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-204/","summary":"思路 经典素数筛选法，详见思想篇章 代码 class Solution { public int countPrimes(int n) { boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); double sqrtn = Math.sqrt(n); for (int i = 2; i \u0026lt; sqrtn; i++) { if (isPrime[i]) { for (int j = i * i; j \u0026lt; n; j += i) { isPrime[j] = false; } } }","title":"LeetCode 204"},{"content":"思路 这道题可以复用LeetCode-172的函数，从0-Long.MAX_VALUE之间寻找trailingZeroes(n) == k的值，由于trailingZeroes(n)是单调的，所以可以用二分查找确定左右边界（这点不容易想到），这样比穷举快多了，二分查找相关细节见思想篇章\n代码 class Solution { public int preimageSizeFZF(int k) { return (int) (rightBound(k) - leftBound(k) + 1); } private long leftBound(int target) { long left = 0, right = Long.MAX_VALUE; while (left \u0026lt; right) { long mid = left + (right - left) / 2; if (target \u0026lt;= trailingZeroes(mid)) { right = mid; } else { left = mid + 1; } } return left; } private long rightBound(int target) { long left = 0, right = Long.MAX_VALUE; while (left \u0026lt; right) { long mid = left + (right - left) / 2 + (right - left) % 2; if (target \u0026gt;= trailingZeroes(mid)) { left = mid; } else { right = mid - 1; } } return left; } private long trailingZeroes(long n) { long res = 0; while (n \u0026gt;= 5) { res += n / 5; n /= 5; } return res; } } References 1. 阶乘函数后 K 个零 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-793/","summary":"思路 这道题可以复用LeetCode-172的函数，从0-Long.MAX_VALUE之间寻找trailingZeroes(n) == k的值，由于","title":"LeetCode 793"},{"content":"思路 其实求阶乘结果有几个零就是求阶乘式子里可以分解出来几个因数5，其实就是n/5 + n/25 + n/125 + \u0026hellip;.\n代码 class Solution { public int trailingZeroes(int n) { int res = 0, divisor = 5; while (divisor \u0026lt;= n) { res += n / divisor; divisor *= 5; } return res; } } References 1. 阶乘后的零 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-172/","summary":"思路 其实求阶乘结果有几个零就是求阶乘式子里可以分解出来几个因数5，其实就是n/5 + n/25 + n/125 + \u0026hellip;. 代码 class Solution { public int trailingZeroes(int n) { int res = 0, divisor = 5; while (divisor \u0026lt;= n) { res +=","title":"LeetCode 172"},{"content":"思路 利用并查集的思想即可\n代码 class Solution { public boolean validPath(int n, int[][] edges, int source, int destination) { UF uf = new UF(n); for (int[] edge : edges) { uf.union(edge[0], edge[1]); } return uf.isConnected(source, destination); } class UF { private int[] parent; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } private int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } private void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) { return; } parent[rootP] = rootQ; } private boolean isConnected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } } } References 1. 寻找图中是否存在路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1971/","summary":"思路 利用并查集的思想即可 代码 class Solution { public boolean validPath(int n, int[][] edges, int source, int destination) { UF uf = new UF(n); for (int[] edge : edges) { uf.union(edge[0], edge[1]); } return uf.isConnected(source, destination); } class UF { private int[] parent; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) {","title":"LeetCode 1971"},{"content":"思路 两种思路：\n常规思路 求[0\u0026hellip;n]的前n项和然后减去nums的数之和，就得到了缺失的数组\n位运算思路 由于异或的性质，只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下，注意需要先异或n\n代码 常规思路 class Solution { public int missingNumber(int[] nums) { int n = nums.length; long except = (0 + n) * (n + 1) / 2; long sum = 0; for (int num : nums) { sum += num; } return (int) (except - sum); } } 位运算思路 class Solution { public int missingNumber(int[] nums) { int n = nums.length; int res = n; for (int i = 0; i \u0026lt; n; i++) { res ^= i ^ nums[i]; } return res; } } References 1. 丢失的数字 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-268/","summary":"思路 两种思路： 常规思路 求[0\u0026hellip;n]的前n项和然后减去nums的数之和，就得到了缺失的数组 位运算思路 由于异或的性质，只要把所有的","title":"LeetCode 268"},{"content":"思路 由于一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。那么这道题将所有数异或就得到了结果，在这种场景下可以认为两个相同的数异或后就抵消了\n代码 class Solution { public int singleNumber(int[] nums) { int len = nums.length, result = 0; for (int i = 0; i \u0026lt; len; i++) { result ^= nums[i]; } return result; } } References 1. 只出现一次的数字 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-136/","summary":"思路 由于一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。那么这道题将所有数异或就得到了结果","title":"LeetCode 136"},{"content":"思路 用 n \u0026amp; (n-1) 的技巧来判断n的二进制表示是不是只有一个1\n代码 class Solution { public boolean isPowerOfTwo(int n) { if (n \u0026lt;= 0) { return false; } return (n \u0026amp; (n - 1)) == 0; } } References 1. 2 的幂 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-231/","summary":"思路 用 n \u0026amp; (n-1) 的技巧来判断n的二进制表示是不是只有一个1 代码 class Solution { public boolean isPowerOfTwo(int n) { if (n \u0026lt;= 0) { return false; } return (n \u0026amp; (n - 1)) == 0; } } References 1. 2 的幂","title":"LeetCode 231"},{"content":"思路 需要知道 n \u0026amp; (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。\n代码 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int res = 0; while (n != 0) { n = n \u0026amp; (n - 1); res++; } return res; } } References 1. 位 1 的个数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-191/","summary":"思路 需要知道 n \u0026amp; (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。 代码 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n)","title":"LeetCode 191"},{"content":"思路 不解释了，直接看代码\n代码 class Solution { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map; public Solution(int[] nums) { map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (!map.containsKey(nums[i])) { map.put(nums[i], new LinkedList\u0026lt;\u0026gt;()); } map.get(nums[i]).add(i); } } public int pick(int target) { List\u0026lt;Integer\u0026gt; list = map.get(target); return list.get(new Random().nextInt(list.size())); } } References 1. 随机数索引 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-398/","summary":"思路 不解释了，直接看代码 代码 class Solution { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map; public Solution(int[] nums) { map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (!map.containsKey(nums[i])) { map.put(nums[i], new LinkedList\u0026lt;\u0026gt;()); } map.get(nums[i]).add(i); } } public int pick(int target) { List\u0026lt;Integer\u0026gt; list = map.get(target); return list.get(new Random().nextInt(list.size())); } } References 1. 随机数索引","title":"LeetCode 398"},{"content":"思路 从一堆数据里随机取出一个数据，可以使用蓄水池抽样算法，详见思想篇章\n代码 class Solution { private ListNode head; public Solution(ListNode head) { this.head = head; } public int getRandom() { Random random = new Random(); int i = 0, res = 0; ListNode p = head; while (p != null) { i++; if (random.nextInt(i) == 0) { res = p.val; } p = p.next; } return res; } } References 1. 链表随机节点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-382/","summary":"思路 从一堆数据里随机取出一个数据，可以使用蓄水池抽样算法，详见思想篇章 代码 class Solution { private ListNode head; public Solution(ListNode head) { this.head = head; } public int getRandom() { Random random = new Random(); int i = 0, res = 0; ListNode p =","title":"LeetCode 382"},{"content":"思路 随机算法问题，使用洗牌算法即可，详见思想篇章\n代码 class Solution { private int[] nums; private Random random; public Solution(int[] nums) { this.nums = nums; this.random = new Random(); } public int[] reset() { return nums; } public int[] shuffle() { int n = nums.length; int[] copy = Arrays.copyOf(nums, n); for (int i = 0; i \u0026lt; n; i++) { int r = random.nextInt(n - i) + i; int temp = copy[i]; copy[i] = copy[r]; copy[r] = temp; } return copy; } } References 1. 打乱数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-384/","summary":"思路 随机算法问题，使用洗牌算法即可，详见思想篇章 代码 class Solution { private int[] nums; private Random random; public Solution(int[] nums) { this.nums = nums; this.random = new Random(); } public int[] reset() { return nums; } public int[] shuffle() { int n = nums.length; int[] copy = Arrays.copyOf(nums, n); for (int i","title":"LeetCode 384"},{"content":"思路 四个拨轮，每个都可以向上或者向下，所以有8种选择，由此可以抽象为一个图，BFS算法第一次碰到target时走过的长度就是开锁的最少操作次数，注意deadends可以当成已经访问过的结点\n代码 class Solution { public int openLock(String[] deadends, String target) { Queue\u0026lt;String\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); for (String deadend : deadends) { visited.add(deadend); } if (visited.contains(\u0026#34;0000\u0026#34;)) { return -1; } queue.offer(\u0026#34;0000\u0026#34;); visited.add(\u0026#34;0000\u0026#34;); int step = 0; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { String cur = queue.poll(); if (cur.equals(target)) { return step; } for (int j = 0; j \u0026lt; 4; j++) { String minus = minusOne(cur, j); if (!visited.contains(minus)) { queue.offer(minus); visited.add(minus); } String plus = plusOne(cur, j); if (!visited.contains(plus)) { queue.offer(plus); visited.add(plus); } } } step++; } return -1; } private String minusOne(String s, int i) { char[] chars = s.toCharArray(); chars[i] = (char) ((chars[i] - \u0026#39;0\u0026#39; + 9) % 10 + \u0026#39;0\u0026#39;); return new String(chars); } private String plusOne(String s, int i) { char[] chars = s.toCharArray(); chars[i] = (char) ((chars[i] - \u0026#39;0\u0026#39; + 1) % 10 + \u0026#39;0\u0026#39;); return new String(chars); } } References 1. 打开转盘锁 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-752/","summary":"思路 四个拨轮，每个都可以向上或者向下，所以有8种选择，由此可以抽象为一个图，BFS算法第一次碰到target时走过的长度就是开锁的最少操作次","title":"LeetCode 752"},{"content":"思路 经典BFS问题，BFS同时看是不是叶子节点，是叶子结点就返回深度\n代码 class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); int depth = 1; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode cur = queue.poll(); if (cur.left == null \u0026amp;\u0026amp; cur.right == null) { return depth; } if (cur.left != null) { queue.offer(cur.left); } if (cur.right != null) { queue.offer(cur.right); } } depth++; } return -1; } } References 1. 二叉树的最小深度 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-111/","summary":"思路 经典BFS问题，BFS同时看是不是叶子节点，是叶子结点就返回深度 代码 class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); int depth = 1; while (!queue.isEmpty()) { int size = queue.size(); for","title":"LeetCode 111"},{"content":"思路 经典回溯问题，穷举所有可能并且对不合理的情况剪枝即可，剪枝代码如下：\nif (right \u0026lt; left) { return; } if (right \u0026lt; 0 || left \u0026lt; 0) { return; } 代码 class Solution { public List\u0026lt;String\u0026gt; generateParenthesis(int n) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); StringBuilder track = new StringBuilder(); backtrack(track, n, n, res); return res; } private void backtrack(StringBuilder track, int left, int right, List\u0026lt;String\u0026gt; res) { if (right \u0026lt; left) { return; } if (right \u0026lt; 0 || left \u0026lt; 0) { return; } if (right == 0 \u0026amp;\u0026amp; left == 0) { res.add(track.toString()); } track.append(\u0026#39;(\u0026#39;); backtrack(track, left - 1, right, res); track.deleteCharAt(track.length() - 1); track.append(\u0026#39;)\u0026#39;); backtrack(track, left, right - 1, res); track.deleteCharAt(track.length() - 1); } } References 1. 括号生成 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-22/","summary":"思路 经典回溯问题，穷举所有可能并且对不合理的情况剪枝即可，剪枝代码如下： if (right \u0026lt; left) { return; } if (right \u0026lt; 0 || left \u0026lt; 0) { return; } 代码 class Solution { public List\u0026lt;String\u0026gt; generateParenthesis(int n) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); StringBuilder","title":"LeetCode 22"},{"content":"思路 经典回溯问题，暴力求解即可\n代码 class Solution { public void solveSudoku(char[][] board) { backtrack(board, 0, 0); } private boolean backtrack(char[][] board, int i, int j) { if (j == 9) { i++; j = 0; } if (i == 9) { return true; } if (board[i][j] != \u0026#39;.\u0026#39;) { return backtrack(board, i, j + 1); } boolean[] isValid = getValidNum(board, i, j); for (int k = 1; k \u0026lt;= 9; k++) { if (!isValid[k - 1]) { continue; } board[i][j] = (char) (\u0026#39;0\u0026#39; + k); if (backtrack(board, i, j + 1)) { return true; } board[i][j] = \u0026#39;.\u0026#39;; } return false; } private boolean[] getValidNum(char[][] board, int i, int j) { boolean[] isValid = new boolean[9]; Arrays.fill(isValid, true); for (int k = 0; k \u0026lt; 9; k++) { if (board[i][k] != \u0026#39;.\u0026#39;) { isValid[board[i][k] - \u0026#39;0\u0026#39; - 1] = false; } if (board[k][j] != \u0026#39;.\u0026#39;) { isValid[board[k][j] - \u0026#39;0\u0026#39;- 1] = false; } if (board[i / 3 * 3 + k / 3][j / 3 * 3 + k % 3] != \u0026#39;.\u0026#39;) { isValid[board[i / 3 * 3 + k / 3][j / 3 * 3 + k % 3] - \u0026#39;0\u0026#39; - 1] = false; } } return isValid; } } References 1. 解数独 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-37/","summary":"思路 经典回溯问题，暴力求解即可 代码 class Solution { public void solveSudoku(char[][] board) { backtrack(board, 0, 0); } private boolean backtrack(char[][] board, int i, int j) { if (j == 9) { i++; j = 0; } if (i == 9) { return true; } if (board[i][j] != \u0026#39;.\u0026#39;) { return backtrack(board, i, j + 1); } boolean[] isValid","title":"LeetCode 37"},{"content":"思路 第一题 暴力解法即可，见代码\n第二题 需要知道一个数一定能被分解为质数之积，且是唯一的，分解质数的方法是从2开始除，没法整除就将2加一，再除，直到将原数除成1，这道题需要把数分解同时求和，然后循环这个过程，直到求的和\u0026gt;=上次求的和，那么上次求的和就是答案\n第三题 把度数为奇数的节点记到 odd 中，记 m 为 odd 的长度，分类讨论：\n如果 m=0，那么已经符合要求。 如果 m=2，记 x=odd[0],y=odd[1]： 如果 x 和 y 之间没有边，那么连边之后就符合要求了。 如果 x 和 y 之间有边，那么枚举 [1,n] 的所有不为 x 和 y 的点 i，由于 i 的度数一定是偶数，如果 i 和 x 以及 i 和 y 之间没有边，那么连边之后就符合要求了。 如果 m=4，记 a=odd[0],b=odd[1],c=odd[2],d=odd[3]： 如果 a 和 b 以及 c 和 d 之间没有边，那么连边之后就符合要求了。 如果 a 和 c 以及 b 和 d 之间没有边，那么连边之后就符合要求了。 如果 a 和 d 以及 b 和 c 之间没有边，那么连边之后就符合要求了。 其余情况无法满足要求。 第四题 设 LCA 为 a 和 b 的最近公共祖先，那么环长等于 LCA 到 a 的距离加 LCA 到 b 的距离加一。怎么求LCA？可以这样：\n不断循环，每次循环比较 a 和 b 的大小：\n如果 a\u0026gt;b，则 a 的深度大于等于 b 的深度，那么把 a 移动到其父节点，即 a=a/2； 如果 a\u0026lt;b，则 a 的深度小于等于 b 的深度，那么把 b 移动到其父节点，即 b=b/2； 如果 a=b，则找到了 LCA ，退出循环。 循环次数加一即为环长。\n我的这种做法不够优雅\n代码 第一题 class Solution { private boolean isSimilar(String word1, String word2) { HashSet\u0026lt;Character\u0026gt; set1 = new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Character\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; word1.length(); i++) { set1.add(word1.charAt(i)); } for (int i = 0; i \u0026lt; word2.length(); i++) { set2.add(word2.charAt(i)); } if (set1.size() != set2.size()) { return false; } for (Character character : set2) { if (!set1.contains(character)) { return false; } } return true; } public int similarPairs(String[] words) { int n = words.length, res = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (isSimilar(words[i], words[j])) { res++; } } } return res; } } 第二题 class Solution { public int smallestValue(int n) { int i = 2, res = 0, preRes = Integer.MAX_VALUE; while (i \u0026lt;= n) { if (n % i == 0) { n /= i; res += i; if (n == 1) { if (preRes \u0026lt;= res) { return preRes; } n = res; preRes = res; i = 2; res = 0; } } else { i++; } } return res; } } 第三题 class Solution { private Set\u0026lt;String\u0026gt; edgeSet = new HashSet\u0026lt;\u0026gt;(); public boolean isPossible(int n, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges) { int[] degree = new int[n + 1]; for (List\u0026lt;Integer\u0026gt; edge : edges) { edgeSet.add(edge.get(0) + \u0026#34;,\u0026#34; + edge.get(1)); edgeSet.add(edge.get(1) + \u0026#34;,\u0026#34; + edge.get(0)); degree[edge.get(0)]++; degree[edge.get(1)]++; } ArrayList\u0026lt;Integer\u0026gt; nodes = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= n; i++) { if (degree[i] % 2 == 1) { nodes.add(i); } } int count = nodes.size(); if (count == 0) { return true; } if (count == 2) { if (!edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + nodes.get(1))) { return true; } for (int i = 1; i \u0026lt;= n; i++) { if (i == nodes.get(0) || i == nodes.get(1)) { continue; } if (!edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + i) \u0026amp;\u0026amp; !edgeSet.contains(i + \u0026#34;,\u0026#34; + nodes.get(1))) { return true; } } } if (count == 4) { if (!edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + nodes.get(1)) \u0026amp;\u0026amp; !edgeSet.contains(nodes.get(2) + \u0026#34;,\u0026#34; + nodes.get(3)) || !edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + nodes.get(2)) \u0026amp;\u0026amp; !edgeSet.contains(nodes.get(1) + \u0026#34;,\u0026#34; + nodes.get(3)) || !edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + nodes.get(3)) \u0026amp;\u0026amp; !edgeSet.contains(nodes.get(1) + \u0026#34;,\u0026#34; + nodes.get(2))) { return true; } } return false; } } 第四题 class Solution { private int getLen(int node1, int node2) { int len1 = 0, len2 = 0, n1 = node1, n2 = node2; while (n1 != 1) { n1 /= 2; len1++; } while (n2 != 1) { n2 /= 2; len2++; } n1 = node1; n2 = node2; int l1 = len1; int l2 = len2; while (n1 != n2) { if (l1 \u0026gt; l2) { n1 /= 2; l1--; } else if (l1 \u0026lt; l2) { n2 /= 2; l2--; } else { n1 /= 2; n2 /= 2; l1--; l2--; } } return len1 - l1 + len2 - l2 + 1; } public int[] cycleLengthQueries(int n, int[][] queries) { int[] answer = new int[queries.length]; for (int i = 0; i \u0026lt; queries.length; i++) { answer[i] = getLen(queries[i][0], queries[i][1]); } return answer; } } References ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-324/","summary":"思路 第一题 暴力解法即可，见代码 第二题 需要知道一个数一定能被分解为质数之积，且是唯一的，分解质数的方法是从2开始除，没法整除就将2加一，再除，","title":"LeetCode 周赛-324"},{"content":"思路 标准KMP算法，套模板即可，详见思想篇章\n代码 class Solution { public int strStr(String haystack, String needle) { return new KMP(needle).search(haystack); } class KMP { private String pat; private int[][] dp; public KMP(String pat) { this.pat = pat; int M = pat.length(); this.dp = new int[M][256]; dp[0][pat.charAt(0)] = 1; int X = 0; for (int j = 1; j \u0026lt; M; j++) { for (int c = 0; c \u0026lt; 256; c++) { dp[j][c] = dp[X][c]; } dp[j][pat.charAt(j)] = j + 1; X = dp[X][pat.charAt(j)]; } } public int search(String str) { int M = pat.length(); int N = str.length(); int j = 0; for (int i = 0; i \u0026lt; N; i++) { j = dp[j][str.charAt(i)]; if (j == M) { return i - M + 1; } } return -1; } } } References 1. 实现 strStr() ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-28/","summary":"思路 标准KMP算法，套模板即可，详见思想篇章 代码 class Solution { public int strStr(String haystack, String needle) { return new KMP(needle).search(haystack); } class KMP { private String pat; private int[][] dp; public KMP(String pat) { this.pat = pat; int M = pat.length(); this.dp = new int[M][256]; dp[0][pat.charAt(0)] = 1; int X = 0; for","title":"LeetCode 28"},{"content":"思路 用双指针逐行比较即可，可以用KMP优化\n代码 class Solution { private boolean isMatch(int[] group, int[] nums, int start) { if (group.length \u0026gt; nums.length - start) { return false; } for (int i = 0; i \u0026lt; group.length; i++) { if (group[i] != nums[start + i]) { return false; } } return true; } public boolean canChoose(int[][] groups, int[] nums) { int i = 0, k = 0; while (i \u0026lt; groups.length \u0026amp;\u0026amp; k \u0026lt; nums.length){ if (isMatch(groups[i], nums, k)) { k += groups[i].length; i++; } else { k++; } } return i == groups.length; } } References 1. 通过连接另一个数组的子数组得到一个数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1764/","summary":"思路 用双指针逐行比较即可，可以用KMP优化 代码 class Solution { private boolean isMatch(int[] group, int[] nums, int start) { if (group.length \u0026gt; nums.length - start) { return false; } for (int i = 0; i \u0026lt; group.length; i++) { if (group[i] != nums[start + i]) { return false; } } return true; } public","title":"LeetCode 1764"},{"content":"思路 和其他岛屿类似，但是需要判断形状是否相同，解决办法也比较巧妙，通过遍历岛屿单元格的顺序来判断形状是否相同，还要把这些顺序序列化成字符串方便去重\n代码 public class Solution { private void dfs(int[][] grid, int i, int j, StringBuilder sb, int dir) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == 0) { return; } grid[i][j] = 0; sb.append(dir).append(\u0026#39;,\u0026#39;); dfs(grid, i + 1, j, sb, 1); dfs(grid, i - 1, j, sb, 2); dfs(grid, i, j + 1, sb, 3); dfs(grid, i, j - 1, sb, 4); sb.append(-dir).append(\u0026#39;,\u0026#39;); } public int numberofDistinctIslands(int[][] grid) { int m = grid.length, n = grid[0].length; Set\u0026lt;String\u0026gt; res = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { StringBuilder sb = new StringBuilder(); dfs(grid, i, j, sb, 666); res.add(sb.toString()); } } } return res.size(); } } References 1. 不同岛屿的数量 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-694/","summary":"思路 和其他岛屿类似，但是需要判断形状是否相同，解决办法也比较巧妙，通过遍历岛屿单元格的顺序来判断形状是否相同，还要把这些顺序序列化成字符串方","title":"LeetCode 694"},{"content":"思路 同LeetCode-1254，只不过需要提前把不可能是子岛屿的岛屿淹掉，剩下的就是子岛屿了\n代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == 0) { return; } grid[i][j] = 0; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); } public int countSubIslands(int[][] grid1, int[][] grid2) { int m = grid1.length, n = grid1[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid1[i][j] == 0 \u0026amp;\u0026amp; grid2[i][j] == 1) { dfs(grid2, i, j); } } } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid2[i][j] == 1) { res++; dfs(grid2, i, j); } } } return res; } } References 1. 统计子岛屿 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1905/","summary":"思路 同LeetCode-1254，只不过需要提前把不可能是子岛屿的岛屿淹掉，剩下的就是子岛屿了 代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i","title":"LeetCode 1905"},{"content":"思路 同LeetCode-200，把返回值改成淹没陆地的数量即可\n代码 class Solution { private int dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return 0; } if (grid[i][j] == 0) { return 0; } grid[i][j] = 0; return 1 + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1); } public int maxAreaOfIsland(int[][] grid) { int m = grid.length, n = grid[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { res = Math.max(res, dfs(grid, i, j)); } } return res; } } References 1. 岛屿的最大面积 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-695/","summary":"思路 同LeetCode-200，把返回值改成淹没陆地的数量即可 代码 class Solution { private int dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return","title":"LeetCode 695"},{"content":"思路 同LeetCode-1254，将边界淹没后，直接统计单元格即可\n代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == 0) { return; } grid[i][j] = 0; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); } public int numEnclaves(int[][] grid) { int m = grid.length, n = grid[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { dfs(grid, i, 0); dfs(grid, i, n - 1); } for (int i = 0; i \u0026lt; n; i++) { dfs(grid, 0, i); dfs(grid, m - 1, i); } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { res++; } } } return res; } } References 1. 飞地的数量 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1020/","summary":"思路 同LeetCode-1254，将边界淹没后，直接统计单元格即可 代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n)","title":"LeetCode 1020"},{"content":"思路 同LeetCode-200，只不过需要提前把边界的岛屿淹没\n代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == 1) { return; } grid[i][j] = 1; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); } public int closedIsland(int[][] grid) { int m = grid.length, n = grid[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { dfs(grid, i, 0); dfs(grid, i, n - 1); } for (int i = 0; i \u0026lt; n; i++) { dfs(grid, 0, i); dfs(grid, m - 1, i); } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 0) { res++; dfs(grid, i, j); } } } return res; } } References 1. 统计封闭岛屿的数目 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1254/","summary":"思路 同LeetCode-200，只不过需要提前把边界的岛屿淹没 代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return;","title":"LeetCode 1254"},{"content":"思路 利用dfs的思想，遍历矩阵，如果碰到陆地就从这个元素开始dfs，同时将陆地全部变为海水，同时统计岛屿的个数\n代码 class Solution { public int numIslands(char[][] grid) { int m = grid.length, n = grid[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { res++; dfs(grid, i, j); } } } return res; } private void dfs(char[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == \u0026#39;0\u0026#39;) { return; } grid[i][j] = \u0026#39;0\u0026#39;; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); } } References 1. 岛屿数量 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-200/","summary":"思路 利用dfs的思想，遍历矩阵，如果碰到陆地就从这个元素开始dfs，同时将陆地全部变为海水，同时统计岛屿的个数 代码 class Solution { public int numIslands(char[][] grid) { int m = grid.length, n","title":"LeetCode 200"},{"content":"思路 经典可复选组合问题，保证递归的时候还能选择已经选择的元素即可\n代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; private void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if (trackSum \u0026gt; target) { return; } for (int i = start; i \u0026lt; nums.length; i++) { track.add(nums[i]); trackSum += nums[i]; backtrack(nums, i, target); track.remove(track.size() - 1); trackSum -= nums[i]; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { backtrack(candidates, 0, target); return res; } } References 1. 组合总和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-39/","summary":"思路 经典可复选组合问题，保证递归的时候还能选择已经选择的元素即可 代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; private void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if","title":"LeetCode 39"},{"content":"思路 经典有重复元素的全排列问题，需要注意怎么去重，可以固定相同元素在全排列里的相对位置来去重，代码如下：\nif (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } 代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); private void backtrack(List\u0026lt;Integer\u0026gt; track, int[] nums, boolean[] used) { if (track.size() == nums.length) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } track.add(nums[i]); used[i] = true; backtrack(track, nums, used); used[i] = false; track.remove(track.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { int n = nums.length; Arrays.sort(nums); boolean[] used = new boolean[n]; List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(track, nums, used); return res; } } References 1. 全排列 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-47/","summary":"思路 经典有重复元素的全排列问题，需要注意怎么去重，可以固定相同元素在全排列里的相对位置来去重，代码如下： if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } 代","title":"LeetCode 47"},{"content":"思路 经典带重复元素的组合问题，详见思想篇章\n代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; private void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if (trackSum \u0026gt; target) { return; } for (int i = start; i \u0026lt; nums.length; i++) { if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } track.add(nums[i]); trackSum += nums[i]; backtrack(nums, i + 1, target); track.remove(track.size() - 1); trackSum -= nums[i]; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); backtrack(candidates, 0, target); return res; } } References 1. 组合总和 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-40/","summary":"思路 经典带重复元素的组合问题，详见思想篇章 代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; private void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if (trackSum \u0026gt; target) { return; } for (int i = start;","title":"LeetCode 40"},{"content":"思路 经典带重复元素的子集问题，详见思想篇章\n代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); private void backtrack(int[] nums, int start) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); for (int i = start; i \u0026lt; nums.length; i++) { if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } track.add(nums[i]); backtrack(nums, i + 1); track.remove(track.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); backtrack(nums, 0); return res; } } References 1. 子集 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-90/","summary":"思路 经典带重复元素的子集问题，详见思想篇章 代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); private void backtrack(int[] nums, int start) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); for (int i = start; i \u0026lt; nums.length; i++) { if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } track.add(nums[i]); backtrack(nums,","title":"LeetCode 90"},{"content":"思路 经典组合问题，不解释了，详见思想篇章\n代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { backtrack(n, 1, k); return res; } private void backtrack(int n, int start, int k) { if (track.size() == k) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i = start; i \u0026lt;= n; i++) { track.add(i); backtrack(n, i + 1, k); track.remove(track.size() - 1); } } } References 1. 组合 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-77/","summary":"思路 经典组合问题，不解释了，详见思想篇章 代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { backtrack(n, 1, k); return res; } private void backtrack(int n, int start, int k) { if (track.size() == k) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i =","title":"LeetCode 77"},{"content":"思路 两种思路：\n回溯 经典子集问题，不解释了，详见思想篇章\n迭代 因为每一个元素要么选要么不选，所以可以看成有n个盒子n个数，每个数要么放进盒子，要么不放，可以把放进盒子看成1，不放盒子看成0，那么所有的2^n个情况就是[0, 2^n - 1]。\n代码 回溯 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { backtrack(nums, 0); return res; } private void backtrack(int[] nums, int start) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); for (int i = start; i \u0026lt; nums.length; i++) { track.add(nums[i]); backtrack(nums, i + 1); track.remove(track.size() - 1); } } } 迭代 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;Integer\u0026gt; track = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); int n = nums.length; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask++) { track.clear(); for (int i = 0; i \u0026lt; n; i++) { if ((mask \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0) { track.add(nums[i]); } } res.add(new ArrayList\u0026lt;\u0026gt;(track)); } return res; } } References 1. 子集 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-78/","summary":"思路 两种思路： 回溯 经典子集问题，不解释了，详见思想篇章 迭代 因为每一个元素要么选要么不选，所以可以看成有n个盒子n个数，每个数要么放进盒子，要","title":"LeetCode 78"},{"content":"思路 利用回溯算法，这种排列组合问题的各种变体都可以抽象成「球盒模型」，将子集看成盒子，那么每个盒子遍历一遍数组，要么将元素放盒子里面要么不放，就这样回溯，只不过代码有点难写\n代码 class Solution { private Map\u0026lt;Integer, Boolean\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public boolean canPartitionKSubsets(int[] nums, int k) { int n = nums.length, sum = 0; if (k \u0026gt; n) { return false; } for (int num : nums) { sum += num; } if (sum % k != 0) { return false; } int used = 0; return backtrack(nums, used, 0, 0, sum / k, k); } private boolean backtrack(int[] nums, int used, int bucket, int start ,int target, int k) { if (k == 0) { return true; } if (bucket == target) { boolean res = backtrack(nums, used, 0, 0, target, k - 1); memo.put(used, res); return res; } if (memo.containsKey(used)) { return memo.get(used); } for (int i = start; i \u0026lt; nums.length; i++) { if (((used \u0026gt;\u0026gt; i) \u0026amp; 1) == 1) { continue; } if (bucket + nums[i] \u0026gt; target) { continue; } bucket += nums[i]; used |= 1 \u0026lt;\u0026lt; i; if (backtrack(nums, used, bucket, i + 1, target, k)) { return true; } bucket -= nums[i]; used ^= 1 \u0026lt;\u0026lt; i; } return false; } } References 1. 划分为k个相等的子集 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-698/","summary":"思路 利用回溯算法，这种排列组合问题的各种变体都可以抽象成「球盒模型」，将子集看成盒子，那么每个盒子遍历一遍数组，要么将元素放盒子里面要么不放","title":"LeetCode 698"},{"content":"思路 利用回溯算法，在棋盘上从上往下下棋子，如果不能下就换个格子，如果一整行都不能下，就回溯到上一行换下一个格子\n代码 class Solution { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;StringBuilder\u0026gt; board = new ArrayList\u0026lt;\u0026gt;(); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; n; i++) { sb.append(\u0026#39;.\u0026#39;); } for (int i = 0; i \u0026lt; n; i++) { board.add(new StringBuilder(sb.toString())); } backtrack(board, 0); return res; } private void backtrack(List\u0026lt;StringBuilder\u0026gt; board, int row) { if (row == board.size()) { List\u0026lt;String\u0026gt; r = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; board.size(); i++) { r.add(board.get(i).toString()); } res.add(r); return; } for (int col = 0; col \u0026lt; board.get(row).length(); col++) { if (!canPlace(board, row, col)) { continue; } board.get(row).replace(col, col + 1, \u0026#34;Q\u0026#34;); backtrack(board, row + 1); board.get(row).replace(col, col + 1, \u0026#34;.\u0026#34;); } } private boolean canPlace(List\u0026lt;StringBuilder\u0026gt; board, int row, int col) { int n = board.size(); for (int i = 0; i \u0026lt; row; i++) { if (board.get(i).charAt(col) == \u0026#39;Q\u0026#39;) { return false; } } for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board.get(i).charAt(j) == \u0026#39;Q\u0026#39;) { return false; } } for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board.get(i).charAt(j) == \u0026#39;Q\u0026#39;) { return false; } } return true; } } References 1. N 皇后 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-51/","summary":"思路 利用回溯算法，在棋盘上从上往下下棋子，如果不能下就换个格子，如果一整行都不能下，就回溯到上一行换下一个格子 代码 class Solution { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) {","title":"LeetCode 51"},{"content":"思路 经典回溯问题，直接套模板即可，决策树如下：\n代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { int n = nums.length; boolean[] used = new boolean[n]; List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(track, nums, used); return res; } private void backtrack(List\u0026lt;Integer\u0026gt; track, int[] nums, boolean[] used) { if (track.size() == nums.length) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) { continue; } track.add(nums[i]); used[i] = true; backtrack(track, nums, used); track.remove(track.size() - 1); used[i] = false; } } } References 1. 全排列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-46/","summary":"思路 经典回溯问题，直接套模板即可，决策树如下： 代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { int n = nums.length; boolean[] used = new boolean[n]; List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(track, nums, used); return res; } private void backtrack(List\u0026lt;Integer\u0026gt; track, int[] nums, boolean[] used) { if (track.size()","title":"LeetCode 46"},{"content":"思路 其实就是求同一时刻最多有多少重叠区间，其实投影到x轴然后看看有几个区间重合到一起了就可以，有两种代码思路：\n用数组表示x轴+差分数组优化 举例来说，如果输入 meetings = [[0,30],[5,10],[15,20]]，那么我们就给数组中 [0,30],[5,10],[15,20] 这几个索引区间分别加一，最后遍历数组，求个最大值就行了。\n扫描法 只记录start和end时间，然后扫描这些时间点，碰到start，count++，碰到end，count\u0026ndash;，记录count的最大值即可\n代码 class Solution { public int minMeetingRooms(List\u0026lt;Interval\u0026gt; intervals) { int n = intervals.size(); int[] start = new int[n]; int[] end = new int[n]; for (int i = 0; i \u0026lt; n; i++) { start[i] = intervals.get(i).start; end[i] = intervals.get(i).end; } Arrays.sort(start); Arrays.sort(end); int i = 0, j = 0, res = 0, count = 0; while (i \u0026lt; n) { if (start[i] \u0026lt; end[j]) { count++; i++; } else { count--; j++; } res = Math.max(res, count); } return res; } } References 1. 会议室 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-253/","summary":"思路 其实就是求同一时刻最多有多少重叠区间，其实投影到x轴然后看看有几个区间重合到一起了就可以，有两种代码思路： 用数组表示x轴+差分数组优化 举","title":"LeetCode 253"},{"content":"思路 利用贪心算法，每次跳的时候选择一个最有潜力的结点跳，只不过代码有点难写\n代码 class Solution { public int jump(int[] nums) { int n = nums.length, farthest = 0, jumps = 0, end = 0; for (int i = 0; i \u0026lt; n - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i == end) { jumps++; end = farthest; } } return jumps; } } References 1. 跳跃游戏 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-45/","summary":"思路 利用贪心算法，每次跳的时候选择一个最有潜力的结点跳，只不过代码有点难写 代码 class Solution { public int jump(int[] nums) { int n = nums.length, farthest = 0, jumps = 0, end = 0; for (int i = 0; i \u0026lt; n - 1;","title":"LeetCode 45"},{"content":"思路 利用贪心算法，每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 farthest 做对比，通过每一步的最优解，更新全局最优解\n代码 class Solution { public boolean canJump(int[] nums) { int farthest = 0; for (int i = 0; i \u0026lt;= farthest \u0026amp;\u0026amp; i \u0026lt; nums.length; i++) { farthest = Math.max(farthest, i + nums[i]); } return farthest \u0026gt;= nums.length - 1; } } References 1. 跳跃游戏 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-55/","summary":"思路 利用贪心算法，每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 farthest 做对比，通过每一步的最优解，更新全局最优解 代码 class","title":"LeetCode 55"},{"content":"思路 利用贪心算法，思路很简单，先按start排序，遍历区间，找end最大的区间，然后再遍历区间找start小于前一个end，end最大的区间，就是代码有点难写，算法过程见下图：\n代码 class Solution { public int videoStitching(int[][] clips, int time) { Arrays.sort(clips, (a, b) -\u0026gt; { return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]; }); int n = clips.length, i = 0, curEnd = 0, nextEnd = 0, res = 0; while (i \u0026lt; n \u0026amp;\u0026amp; clips[i][0] \u0026lt;= curEnd) { while (i \u0026lt; n \u0026amp;\u0026amp; clips[i][0] \u0026lt;= curEnd) { nextEnd = Math.max(nextEnd, clips[i][1]); i++; } res++; curEnd = nextEnd; if (curEnd \u0026gt;= time) { return res; } } return -1; } } References 1. 视频拼接 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1024/","summary":"思路 利用贪心算法，思路很简单，先按start排序，遍历区间，找end最大的区间，然后再遍历区间找start小于前一个end，end最大的区间","title":"LeetCode 1024"},{"content":"思路 其实就是求解无重叠区间最多有几个，同LeetCode-435，因为可以每一发都打在无重叠区间中每个区间的最右边，这样下一个区间之前的区间都被贯穿，如下图所示：\n只不过这道题相邻的两个区间边界触碰也算是重叠区间，interval[0] \u0026gt;= x_end改成interval[0] \u0026gt; x_end就可以了\n代码 class Solution { private int intervalSchedule(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u0026gt; { if (a[1] \u0026gt; b[1]) { return 1; } else if (a[1] \u0026lt; b[1]) { return -1; } else { return 0; } }); int count = 1, x_end = intervals[0][1]; for (int[] interval : intervals) { if (interval[0] \u0026gt; x_end) { count++; x_end = interval[1]; } } return count; } public int findMinArrowShots(int[][] points) { return intervalSchedule(points); } } References 1. 用最少数量的箭引爆气球 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-452/","summary":"思路 其实就是求解无重叠区间最多有几个，同LeetCode-435，因为可以每一发都打在无重叠区间中每个区间的最右边，这样下一个区间之前的区间","title":"LeetCode 452"},{"content":"思路 利用贪心算法，每次选择结束最早的区间（这就是局部最优选择），然后统计就可以了\n代码 class Solution { private int intervalSchedule(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u0026gt; { return a[1] - b[1]; }); int count = 1, x_end = intervals[0][1]; for (int[] interval : intervals) { if (interval[0] \u0026gt;= x_end) { count++; x_end = interval[1]; } } return count; } public int eraseOverlapIntervals(int[][] intervals) { return intervals.length - intervalSchedule(intervals); } } References 1. 无重叠区间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-435/","summary":"思路 利用贪心算法，每次选择结束最早的区间（这就是局部最优选择），然后统计就可以了 代码 class Solution { private int intervalSchedule(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u0026gt; { return a[1] - b[1]; }); int count = 1, x_end = intervals[0][1]; for (int[] interval","title":"LeetCode 435"},{"content":"思路 利用动态规划的思想，dp[i][j] = x表示，戳破气球i和气球j之间（开区间，不包括i和j）的所有气球，可以获得的最高分数为x。状态转移方程为：\nfor (int k = i + 1; k \u0026lt; j; k++) { dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]); } base case和遍历顺序如下：\n可以优化空间复杂度\n代码 class Solution { public int maxCoins(int[] nums) { int n = nums.length; int [] points = new int[n + 2]; for (int i = 0; i \u0026lt; n; i++) { points[i + 1] = nums[i]; } points[0] = points[n + 1] = 1; int[][] dp = new int[n + 2][n + 2]; for (int i = n; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n + 2; j++) { for (int k = i + 1; k \u0026lt; j; k++) { dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]); } } } return dp[0][n + 1]; } } References 1. 戳气球 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-312/","summary":"思路 利用动态规划的思想，dp[i][j] = x表示，戳破气球i和气球j之间（开区间，不包括i和j）的所有气球，可以获得的最高分数为x。状态转移","title":"LeetCode 312"},{"content":"思路 比较复杂，详见：https://leetcode.cn/problems/super-egg-drop/solutions/44427/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/\n代码 基本动态规划版(会超时) class Solution { private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int superEggDrop(int k, int n) { if (k == 1) { return n; } if (n == 0) { return 0; } if (memo.containsKey(k + \u0026#34;,\u0026#34; + n)) { return memo.get(k + \u0026#34;,\u0026#34; + n); } int res = Integer.MAX_VALUE; for (int i = 1; i \u0026lt;= n; i++) { res = Math.min(res, Math.max(superEggDrop(k, n - i), superEggDrop(k - 1, i - 1)) + 1); } memo.put(k + \u0026#34;,\u0026#34; + n, res); return res; } } 基本动态规划+二分查找版 class Solution { // 基本动态规划+二分查找版 private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int superEggDrop(int k, int n) { if (k == 1) { return n; } if (n == 0) { return 0; } if (memo.containsKey(k + \u0026#34;,\u0026#34; + n)) { return memo.get(k + \u0026#34;,\u0026#34; + n); } int res = Integer.MAX_VALUE; int left = 1, right = n; while (left \u0026lt;= right) { int mid = (left + right) / 2; int broken = superEggDrop(k - 1, mid - 1); int notBroken = superEggDrop(k, n - mid); int midVal = broken - notBroken; if (0 \u0026gt; midVal) { left = mid + 1; res = Math.min(res, notBroken + 1); } else if (0 \u0026lt; midVal) { right = mid - 1; res = Math.min(res, broken + 1); } else { res = broken + 1; break; } } memo.put(k + \u0026#34;,\u0026#34; + n, res); return res; } } 进阶动态规划版 class Solution { // 进阶动态规划版 public int superEggDrop(int k, int n) { int[][] dp = new int[k + 1][n + 1]; int m = 0; while (dp[k][m] \u0026lt; n) { m++; for (int i = 1; i \u0026lt;= k; i++) { dp[i][m] = dp[i][m - 1] + 1 + dp[i - 1][m - 1]; } } return m; } } References 1. 鸡蛋掉落 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-887/","summary":"思路 比较复杂，详见：https://leetcode.cn/problems/super-egg-drop/solutions/44427/","title":"LeetCode 887"},{"content":"思路 同LeetCode-198，只不过变成了二叉树\n代码 原版 class Solution { private Map\u0026lt;TreeNode, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int rob(TreeNode root) { if (root == null) { return 0; } if (memo.containsKey(root)) { return memo.get(root); } int do_it = root.val + (root.left == null ? 0 : rob(root.left.left) + rob(root.left.right)) + (root.right == null ? 0 : rob(root.right.left) + rob(root.right.right)); int not_do = rob(root.left) + rob(root.right); int res = Math.max(do_it, not_do); memo.put(root, res); return res; } } 更加优秀的版本 class Solution { private int[] dp(TreeNode root) { if (root == null) { return new int[]{0, 0}; } int[] left = dp(root.left); int[] right = dp(root.right); int do_it = root.val + left[0] + right[0]; int not_do = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); return new int[]{not_do, do_it}; } public int rob(TreeNode root) { int[] res = dp(root); return Math.max(res[0], res[1]); } } References 1. 打家劫舍 III ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-337/","summary":"思路 同LeetCode-198，只不过变成了二叉树 代码 原版 class Solution { private Map\u0026lt;TreeNode, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int rob(TreeNode root) { if (root == null) { return 0; } if (memo.containsKey(root)) { return memo.get(root); } int do_it = root.val + (root.left == null ? 0 : rob(root.left.left)","title":"LeetCode 337"},{"content":"思路 同LeetCode-198，只不过首尾不能同时偷，共有三种情况，其中第一种情况不需要考虑因为肯定比其他两种小\n代码 class Solution { private int robRange(int[] nums, int start, int end) { int dp_i_0 = 0, dp_i_1 = 0, dp_i_2 = 0; for (int i = 2 + start; i \u0026lt; end + 3; i++) { dp_i_2 = Math.max(dp_i_1, dp_i_0 + nums[i - 2]); dp_i_0 = dp_i_1; dp_i_1 = dp_i_2; } return dp_i_2; } public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1)); } } References 1. 打家劫舍 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-213/","summary":"思路 同LeetCode-198，只不过首尾不能同时偷，共有三种情况，其中第一种情况不需要考虑因为肯定比其他两种小 代码 class Solution { private int robRange(int[] nums, int start, int end) {","title":"LeetCode 213"},{"content":"思路 利用动态规划的思想，dp数组里存截止到当前户最多偷到多少钱，状态转移方程为：\ndp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 2]); base case 为dp[0]和dp[1]为0，可以优化空间复杂度\n代码 原版 class Solution { public int rob(int[] nums) { int n = nums.length; int[] dp = new int[n + 2]; for (int i = 2; i \u0026lt; n + 2; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 2]); } return dp[n + 1]; } } 优化空间复杂度 class Solution { public int rob(int[] nums) { int n = nums.length; int dp_i_0 = 0, dp_i_1 = 0, dp_i_2 = 0; for (int i = 2; i \u0026lt; n + 2; i++) { dp_i_2 = Math.max(dp_i_1, dp_i_0 + nums[i - 2]); dp_i_0 = dp_i_1; dp_i_1 = dp_i_2; } return dp_i_2; } } References 1. 打家劫舍 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-198/","summary":"思路 利用动态规划的思想，dp数组里存截止到当前户最多偷到多少钱，状态转移方程为： dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 2]); base case 为dp[0]和dp[1]为0，可","title":"LeetCode 198"},{"content":"思路 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/96/\n代码 121题 class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); } return dp[n - 1][0]; } } 122题 class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]); } return dp[n - 1][0]; } } 309题 class Solution { public int maxProfit(int[] prices) { if (prices.length == 1) { return 0; } int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]); dp[1][1] = Math.max(dp[0][1], -prices[1]); for (int i = 2; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]); } return dp[n - 1][0]; } } 714题 class Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0] - fee; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee); } return dp[n - 1][0]; } } 123题 class Solution { public int maxProfit(int[] prices) { int max_k = 2, n = prices.length; int[][][] dp = new int[n][max_k + 1][2]; for (int i = max_k; i \u0026gt;= 1; i--) { dp[0][i][0] = 0; dp[0][i][1] = -prices[0]; } for (int i = 1; i \u0026lt; n; i++) { for (int k = max_k; k \u0026gt;= 1; k--) { dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } } return dp[n - 1][max_k][0]; } } 188题 class Solution { private int maxProfit_k_inf(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]); } return dp[n - 1][0]; } public int maxProfit(int max_k, int[] prices) { int n = prices.length; if (n \u0026lt;= 0) { return 0; } if (max_k \u0026gt;= n / 2) { // 复用之前交易次数 k 没有限制的情况 return maxProfit_k_inf(prices); } // base case： // dp[-1][...][0] = dp[...][0][0] = 0 // dp[-1][...][1] = dp[...][0][1] = -infinity int[][][] dp = new int[n][max_k + 1][2]; // k = 0 时的 base case for (int i = 0; i \u0026lt; n; i++) { dp[i][0][1] = Integer.MIN_VALUE; dp[i][0][0] = 0; } for (int i = 0; i \u0026lt; n; i++) for (int k = max_k; k \u0026gt;= 1; k--) { if (i - 1 == -1) { // 处理 i = -1 时的 base case dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; } dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } return dp[n - 1][max_k][0]; } } References 1. 买卖股票的最佳时机 2. 买卖股票的最佳时机 II 3. 买卖股票的最佳时机 III 4. 买卖股票的最佳时机 IV 5. 最佳买卖股票时机含冷冻期 6. 买卖股票的最佳时机含手续费 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-121+122+123+188+309+714/","summary":"思路 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/96/ 代码 121题 class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][]","title":"LeetCode 121+122+123+188+309+714"},{"content":"思路 利用动态规划的思想，dp数组里存s[i\u0026hellip;j]的最长回文子序列，状态转移方程如下：\nif (s.charAt(j) == s.charAt(j + i)) { dp[j][j + i] = 2 + dp[j + 1][j + i - 1]; } else { dp[j][j + i] = Math.max(dp[j + 1][j + i], dp[j][j + i - 1]); } base case为如下的0和1：\n可以斜着遍历，也可以从下往上遍历，可以优化空间复杂度\n代码 class Solution { public int longestPalindromeSubseq(String s) { int n = s.length(); int[][] dp = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { dp[i][i] = 1; } for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n - i; j++) { if (s.charAt(j) == s.charAt(j + i)) { dp[j][j + i] = 2 + dp[j + 1][j + i - 1]; } else { dp[j][j + i] = Math.max(dp[j + 1][j + i], dp[j][j + i - 1]); } } } return dp[0][n - 1]; } } References 1. 最长回文子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-516/","summary":"思路 利用动态规划的思想，dp数组里存s[i\u0026hellip;j]的最长回文子序列，状态转移方程如下： if (s.charAt(j) == s.charAt(j + i)) { dp[j][j + i] = 2 + dp[j + 1][j + i - 1]; }","title":"LeetCode 516"},{"content":"思路 dp数组里存s[i\u0026hellip;]和p[j\u0026hellip;]是否匹配，状态转移方程需要根据s[i]和p[j]是否相等来选择，具体如下：\nif (p.charAt(j) == \u0026#39;.\u0026#39; || s.charAt(i) == p.charAt(j)) { if (p.charAt(j + 1) == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j + 2] || dp[i + 1][j]; } else { dp[i][j] = dp[i + 1][j + 1]; } } else { if (p.charAt(j + 1) == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j + 2]; } else { dp[i][j] = false; } } base case为：\ndp[m][n] = true; for (int i = n - 2; i \u0026gt;= 0; i -= 2) { dp[m][i] = dp[m][i + 2] \u0026amp;\u0026amp; (p.charAt(i + 1) == \u0026#39;*\u0026#39;); } 可以优化空间复杂度，详见：https://mp.weixin.qq.com/s/rnaFK05IcFWvNN1ppNf2ug\n代码 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); s = s + \u0026#34;#\u0026#34;; p = p + \u0026#34;#\u0026#34;; boolean[][] dp = new boolean[m + 1][n + 1]; dp[m][n] = true; for (int i = n - 2; i \u0026gt;= 0; i -= 2) { dp[m][i] = dp[m][i + 2] \u0026amp;\u0026amp; (p.charAt(i + 1) == \u0026#39;*\u0026#39;); } for (int i = m - 1; i \u0026gt;= 0; i--) { for (int j = n - 1; j \u0026gt;= 0; j--) { if (p.charAt(j) == \u0026#39;*\u0026#39;) { continue; } if (p.charAt(j) == \u0026#39;.\u0026#39; || s.charAt(i) == p.charAt(j)) { if (p.charAt(j + 1) == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j + 2] || dp[i + 1][j]; } else { dp[i][j] = dp[i + 1][j + 1]; } } else { if (p.charAt(j + 1) == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j + 2]; } else { dp[i][j] = false; } } } } return dp[0][0]; } } References 1. 正则表达式匹配 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-10/","summary":"思路 dp数组里存s[i\u0026hellip;]和p[j\u0026hellip;]是否匹配，状态转移方程需要根据s[i]和p[j]是否相等来选择，具体如下：","title":"LeetCode 10"},{"content":"思路 与LeetCode-64类似，只不过dp数组中dp[i][j]的定义是从 grid[i][j] 到达终点（右下角）所需的最少生命值\n代码 class Solution { public int calculateMinimumHP(int[][] dungeon) { int m = dungeon.length, n = dungeon[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt; m; i++) { dp[i][n] = Integer.MAX_VALUE; } for (int i = 0; i \u0026lt; m; i++) { dp[i][n] = Integer.MAX_VALUE; } for (int i = 0; i \u0026lt; n; i++) { dp[m][i] = Integer.MAX_VALUE; } dp[m - 1][n - 1] = dungeon[m - 1][n - 1] \u0026gt;= 0 ? 1 : -dungeon[m - 1][n - 1] + 1; for (int i = m - 1; i \u0026gt;= 0; i--) { for (int j = n - 1; j \u0026gt;= 0; j--) { if (i != m - 1 || j != n - 1) { int temp = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]; dp[i][j] = temp \u0026gt; 0 ? temp : 1; } } } return dp[0][0]; } } References 1. 地下城游戏 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-174/","summary":"思路 与LeetCode-64类似，只不过dp数组中dp[i][j]的定义是从 grid[i][j] 到达终点（右下角）所需的最少生命值 代码 class Solution { public int calculateMinimumHP(int[][] dungeon) { int m = dungeon.length,","title":"LeetCode 174"},{"content":"思路 经典动态规划问题，构造dp[][]数组，里面存放从(0, 0)到(i, j)的最小路径，dp[i][j]由min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]得来，base case为第一行和第一列，可以优化空间复杂度\n代码 class Solution { public int minPathSum(int[][] grid) { int m = grid.length, n = grid[0].length; int[][] dp = new int[m][n]; dp[0][0] = grid[0][0]; for (int i = 1; i \u0026lt; m; i++) { dp[i][0] = dp[i - 1][0] + grid[i][0]; } for (int i = 1; i \u0026lt; n; i++) { dp[0][i] = dp[0][i - 1] + grid[0][i]; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; } } References 1. 最小路径和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-64/","summary":"思路 经典动态规划问题，构造dp[][]数组，里面存放从(0, 0)到(i, j)的最小路径，dp[i][j]由min(dp[i - 1][j], dp[i][j - 1]) + gri","title":"LeetCode 64"},{"content":"思路 有三种思路：\n递归思路 findTargetSumWays(nums, i, remain) = findTargetSumWays(nums, i + 1, remain - nums[i]) + findTargetSumWays(nums, i + 1, remain + nums[i])，直接看代码\n回溯思路 经典回溯问题，套模板即可\n动态规划 这道题还可以转换为子集划分问题，如果我们把 nums 划分成两个子集 A 和 B，分别代表分配 + 的数和分配 - 的数，那么他们和 target 存在如下关系：\nsum(A) - sum(B) = target sum(A) = target + sum(B) sum(A) + sum(A) = target + sum(B) + sum(A) 2 * sum(A) = target + sum(nums) 综上，可以推出 sum(A) = (target + sum(nums)) / 2，也就是把原问题转化成：nums 中存在几个子集 A，使得 A 中元素的和为 (target + sum(nums)) / 2？这就是一个子集背包问题了，直接套模板即可，详见思想篇章\n代码 递归解法 class Solution { private int findTargetSumWays(int[] nums, int i, int remain) { if (i == nums.length) { if (remain == 0) { return 1; } return 0; } return findTargetSumWays(nums, i + 1, remain - nums[i]) + findTargetSumWays(nums, i + 1, remain + nums[i]); } public int findTargetSumWays(int[] nums, int target) { // 递归解法 return findTargetSumWays(nums, 0, target); } } 回溯解法 class Solution { private int count = 0; private void backtrack(int[] nums, int i, int remain) { if (i == nums.length) { if (remain == 0) { count++; } return; } remain -= nums[i]; backtrack(nums, i + 1, remain); remain += nums[i]; remain += nums[i]; backtrack(nums, i + 1, remain); remain -= nums[i]; } public int findTargetSumWays(int[] nums, int target) { // 回溯解法 backtrack(nums, 0, target); return count; } } 子集背包解法 // 原版 class Solution { public int findTargetSumWays(int[] nums, int target) { // 动态规划(子集背包问题) int n = nums.length, sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; } if (Math.abs(target) \u0026gt; sum || (sum + target) % 2 == 1) { return 0; } sum = (sum + target) / 2; int[][] dp = new int[n + 1][sum + 1]; dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= sum; j++) { if (j \u0026lt; nums[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]; } } } return dp[n][sum]; } } // 优化空间复杂度 class Solution { public int findTargetSumWays(int[] nums, int target) { // 动态规划(子集背包问题) int n = nums.length, sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; } if (Math.abs(target) \u0026gt; sum || (sum + target) % 2 == 1) { return 0; } sum = (sum + target) / 2; int[] dp = new int[sum + 1]; dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = sum; j \u0026gt;= 0; j--) { if (j \u0026gt;= nums[i - 1]) { dp[j] = dp[j] + dp[j - nums[i - 1]]; } } } return dp[sum]; } } References 1. 目标和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-494/","summary":"思路 有三种思路： 递归思路 findTargetSumWays(nums, i, remain) = findTargetSumWays(nums, i + 1, remain - nums[i]) + findTargetSumWays(nums, i + 1, remain + nums[i])，直接看代码 回溯思路 经典回溯问题，套模板即可 动态规划 这道题还可以","title":"LeetCode 494"},{"content":"思路 经典完全背包问题，直接套模板即可，详见思想篇章，可以优化空间复杂度\n代码 原版 class Solution { public int change(int amount, int[] coins) { int n = coins.length; int[][] dp = new int[n + 1][amount + 1]; for (int i = 0; i \u0026lt;= n; i++) { dp[i][0] = 1; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= amount; j++) { if (j \u0026lt; coins[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; } } } return dp[n][amount]; } } 优化空间复杂度 class Solution { public int change(int amount, int[] coins) { int n = coins.length; int[] dp = new int[amount + 1]; dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= amount; j++) { if (j \u0026gt;= coins[i - 1]) { dp[j] = dp[j] + dp[j - coins[i - 1]]; } } } return dp[amount]; } } References 1. 零钱兑换 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-518/","summary":"思路 经典完全背包问题，直接套模板即可，详见思想篇章，可以优化空间复杂度 代码 原版 class Solution { public int change(int amount, int[] coins) { int n = coins.length; int[][] dp = new int[n + 1][amount + 1]; for (int i = 0; i \u0026lt;= n;","title":"LeetCode 518"},{"content":"思路 其实就是背包问题，直接套背包问题模板，构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下 dp[i][w]表示能否将该背包装满。base case是第一列取值为true，可以优化空间复杂度，但是要注意j需要倒着遍历\n代码 原版 class Solution { public boolean canPartition(int[] nums) { int n = nums.length, sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; } if (sum % 2 != 0) { return false; } boolean[][] dp = new boolean[n + 1][sum / 2 + 1]; for (int i = 0; i \u0026lt;= n; i++) { dp[i][0] = true; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= sum / 2; j++) { if (j \u0026lt; nums[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]; } } } return dp[n][sum / 2]; } } 优化空间复杂度 class Solution { public boolean canPartition(int[] nums) { int n = nums.length, sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; } if (sum % 2 != 0) { return false; } boolean[] dp = new boolean[sum / 2 + 1]; dp[0] = true; for (int i = 1; i \u0026lt;= n; i++) { for (int j = sum / 2; j \u0026gt;= 1; j--) { if (j \u0026gt;= nums[i - 1]) { dp[j] = dp[j] || dp[j - nums[i - 1]]; } } } return dp[sum / 2]; } } References 1. 分割等和子集 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-416/","summary":"思路 其实就是背包问题，直接套背包问题模板，构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下 dp[","title":"LeetCode 416"},{"content":"思路 利用动态规划的思想，同LeetCode-583，只不过不是计算删除操作数，而是删除的ASCII码\n代码 class Solution { public int minimumDeleteSum(String s1, String s2) { int m = s1.length(), n = s2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= n; i++) { dp[0][i] = dp[0][i - 1] + s2.charAt(i - 1); } for (int i = 1; i \u0026lt;= m; i++) { dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1); } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (s1.charAt(i - 1) == s2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i][j - 1] + s2.charAt(j - 1), dp[i - 1][j] + s1.charAt(i - 1)); } } } return dp[m][n]; } } References 1. 两个字符串的最小ASCII删除和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-712/","summary":"思路 利用动态规划的思想，同LeetCode-583，只不过不是计算删除操作数，而是删除的ASCII码 代码 class Solution { public int minimumDeleteSum(String s1, String s2) { int m = s1.length(), n = s2.length(); int[][]","title":"LeetCode 712"},{"content":"思路 基本同最长公共子序列：LeetCode-1143，也可以直接重用LCS，因为删除的结果不就是它俩的最长公共子序列，那么删除的次数就是word1.length() + word2.length() - 2 * lcsLen\n代码 class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt;= n; i++) { dp[0][i] = i; } for (int i = 0; i \u0026lt;= m; i++) { dp[i][0] = i; } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1); } } } return dp[m][n]; } } References 1. 两个字符串的删除操作 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-583/","summary":"思路 基本同最长公共子序列：LeetCode-1143，也可以直接重用LCS，因为删除的结果不就是它俩的最长公共子序列，那么删除的次数就是wo","title":"LeetCode 583"},{"content":"思路 利用动态规划的思想，dp数组里存s1[0\u0026hellip;i]和s2[0\u0026hellip;j]的最长公共子序列，如果s1[i]==s2[j]，dp[i][j]由dp[i-1][j-1]+1得来，否则dp[i][j]由max(dp[i][j-1], dp[i-1][j])得来，base case是dp[0][\u0026hellip;]和dp[\u0026hellip;][0]为0，可以优化空间复杂度\n代码 class Solution { public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { dp[i][j] = 1 + dp[i - 1][j - 1]; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } } References 1. 最长公共子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1143/","summary":"思路 利用动态规划的思想，dp数组里存s1[0\u0026hellip;i]和s2[0\u0026hellip;j]的最长公共子序列，如果s1[i]==s2[j]","title":"LeetCode 1143"},{"content":"思路 三种思路：\n动态规划 dp数组里放以该元素结尾的最大子数组和，可以由前面那个元素推出来，base case是dp[0] = nums[0]，可以优化空间复杂度\n滑动窗口 其实和动态规划一样，就是窗口里的元素和如果大于0，就扩大窗口（因为是正的加上后面的元素才有可能更大），窗口里的元素和如果小于0，就缩小窗口（因为是负的加上后面的元素只会更大），和动态规划其实一样的\n前缀和数组 利用前缀和数组的思想，最大子数组之和其实就是 preSum[i+1] - min(preSum[0..i])\n代码 动态规划 class Solution { public int maxSubArray(int[] nums) { // 动态规划 int n = nums.length; int dp_0 = nums[0], res = dp_0; for (int i = 1; i \u0026lt; n; i++) { dp_0 = Math.max(dp_0 + nums[i], nums[i]); res = Math.max(res, dp_0); } return res; } } 滑动窗口 class Solution { public int maxSubArray(int[] nums) { // 滑动窗口 int left = 0, right = 0; int windowSum = 0, res = Integer.MIN_VALUE; while (right \u0026lt; nums.length) { windowSum += nums[right]; right++; res = Math.max(res, windowSum); while (windowSum \u0026lt; 0) { windowSum -= nums[left]; left++; } } return res; } } 前缀和数组 class Solution { public int maxSubArray(int[] nums) { // 前缀和数组 int n = nums.length; int[] preSum = new int[n + 1]; for (int i = 0; i \u0026lt; n ; i++) { preSum[i + 1] = preSum[i] + nums[i]; } int minVal = Integer.MAX_VALUE, res = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; n; i++) { minVal = Math.min(minVal, preSum[i]); res = Math.max(res, preSum[i + 1] - minVal); } return res; } } References 1. 最大子数组和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-53/","summary":"思路 三种思路： 动态规划 dp数组里放以该元素结尾的最大子数组和，可以由前面那个元素推出来，base case是dp[0] = nums[0]，可以优","title":"LeetCode 53"},{"content":"思路 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来：\nbase case是第一行和第一列，可以优化空间复杂度但是懒得弄了\n补充：具体s1是怎么转换为s2的，可以在dp数组的每个元素里补充额外的信息，详见：https://labuladong.gitee.io/algo/3/26/75/\n代码 class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt;= m; i++) { dp[i][0] = i; } for (int i = 0; i \u0026lt;= n; i++) { dp[0][i] = i; } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1)); } } } return dp[m][n]; } } References 1. 编辑距离 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-72/","summary":"思路 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来： base case是第一行和第一","title":"LeetCode 72"},{"content":"思路 利用动态规划的思想，dp数组里放落到该位置的最小路径和，由上一行临近自己的三个元素最小值+自己元素的大小得到，base case是dp数组第一行为matrix数组第一行，可以优化空间复杂度，因为只用到了两行，但是懒得弄了\n代码 class Solution { public int minFallingPathSum(int[][] matrix) { int n = matrix.length; int[][] dp = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { dp[0][i] = matrix[0][i]; } for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.min(dp[i - 1][0], dp[i - 1][1]) + matrix[i][0]; for (int j = 1; j \u0026lt; n - 1; j++) { dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j + 1])) + matrix[i][j]; } dp[i][n - 1] = Math.min(dp[i - 1][n - 1], dp[i - 1][n - 2]) + matrix[i][n - 1]; } int res = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; n; i++) { res = Math.min(res, dp[n - 1][i]); } return res; } } References 1. 下降路径最小和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-931/","summary":"思路 利用动态规划的思想，dp数组里放落到该位置的最小路径和，由上一行临近自己的三个元素最小值+自己元素的大小得到，base case是dp数组","title":"LeetCode 931"},{"content":"思路 本质上就是最长递增子序列问题，见LeetCode-300，只不过需要先对width升序排序，然后计算height的最长递增子序列即可\nps：此版本会超时，需要融合二分查找\n代码 class Solution { public int maxEnvelopes(int[][] envelopes) { int n = envelopes.length; Arrays.sort(envelopes, (a, b) -\u0026gt; { return a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]; }); int[] dp = new int[n]; Arrays.fill(dp, 1); int res = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (envelopes[j][1] \u0026lt; envelopes[i][1]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } res = Math.max(res, dp[i]); } return res; } } References 1. 俄罗斯套娃信封问题 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-354/","summary":"思路 本质上就是最长递增子序列问题，见LeetCode-300，只不过需要先对width升序排序，然后计算height的最长递增子序列即可 ps","title":"LeetCode 354"},{"content":"思路 两种解法：\n动态规划 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素的索引，base case为f(0) = 1，具有最优子结构，状态转移方程为f(x) = \u0026hellip;.(懒得写了)，会有重叠子问题所以用dp数组记录，无法优化空间复杂度\n动态规划+二分查找 没看懂，也不重要，以后再说吧 // TODO\n代码 动态规划 class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length, res = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[j] \u0026lt; nums[i]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } res = Math.max(res, dp[i]); } return res; } } References 1. 最长递增子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-300/","summary":"思路 两种解法： 动态规划 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素","title":"LeetCode 300"},{"content":"动态规划基本问题 解法 经典动态规划问题，详见思想篇章\n题目 1. 斐波那契数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-509/\n2. 零钱兑换 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-322/\n3. 下降路径最小和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-931/\n4. 最小路径和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-64/\n5. 地下城游戏 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-174/\n6. 鸡蛋掉落 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-887/\n7. 戳气球 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-312/\n8. 单词拆分 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-139/\n9. 比特位计数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-338/\n10. 乘积最大子数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-152/\n11. 最大矩形 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-85/\n12. 最大正方形 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-221/\n13. 最长有效括号 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-32/\n14. 爬楼梯 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-70/\n正则表达式匹配 解法 详见题解\n题目 1. 正则表达式匹配 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-10/\n股票问题 解法 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/96/\n题目 1. 买卖股票的最佳时机 2. 买卖股票的最佳时机 II 3. 买卖股票的最佳时机 III 4. 买卖股票的最佳时机 IV 5. 最佳买卖股票时机含冷冻期 6. 买卖股票的最佳时机含手续费 打家劫舍问题 解法 详见题解\n题目 1. 打家劫舍 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-198/\n2. 打家劫舍 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-213/\n2. 打家劫舍 III 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-337/\nKMP算法 解法 详见思想篇章\n题目 1. 实现 strStr() 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-28/\n2. 通过连接另一个数组的子数组得到一个数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1764/\n子序列问题 最长递增子序列 解法 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素的索引，base case为f(0) = 1，具有最优子结构，状态转移方程为f(x) = \u0026hellip;.(懒得写了)，会有重叠子问题所以用dp数组记录，无法优化空间复杂度\n题目 1. 最长递增子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-300/\n2. 俄罗斯套娃信封问题 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-354/\n编辑距离 解法 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来：\nbase case是第一行和第一列，可以优化空间复杂度但是懒得弄了\n补充：具体s1是怎么转换为s2的，可以在dp数组的每个元素里补充额外的信息，详见：https://labuladong.gitee.io/algo/3/26/75/\n题目 1. 编辑距离 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-72/\n最大子数组和 解法 dp数组里放以该元素结尾的最大子数组和，可以由前面那个元素推出来，base case是dp[0] = nums[0]，可以优化空间复杂度\n还可以利用滑动窗口和前缀和数组解决\n题目 1. 最大子数组和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-53/\n最长公共子序列 解法 利用动态规划的思想，dp数组里存s1[0\u0026hellip;i]和s2[0\u0026hellip;j]的最长公共子序列，如果s1[i]==s2[j]，dp[i][j]由dp[i-1][j-1]+1得来，否则dp[i][j]由max(dp[i][j-1], dp[i-1][j])得来，base case是dp[0][\u0026hellip;]和dp[\u0026hellip;][0]为0，可以优化空间复杂度\n题目 1. 最长公共子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1143/\n2. 两个字符串的删除操作 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-583/\n3. 两个字符串的最小ASCII删除和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-712/\n最长回文子序列 解法 见题解\n题目 1. 最长回文子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-516/\n2. 回文子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-647/\n背包问题 0-1背包问题 解法 见思想篇章\n子集背包问题 解法 见思想篇章\n题目 1. 分割等和子集 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-416/\n2. 目标和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-494/\n完全背包问题 解法 见思想篇章\n题目 1. 零钱兑换 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-518/\n贪心算法 无重叠区间最多有几个 解法 利用贪心算法，每次选择结束最早的区间（这就是局部最优选择），然后统计就可以了\n题目 1. 无重叠区间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-435/\n2. 用最少数量的箭引爆气球 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-452/\n最少需要几个区间才能覆盖整个x轴 解法 利用贪心算法，思路很简单，先按start排序，遍历区间，找end最大的区间，然后再遍历区间找start小于前一个end，end最大的区间，就是代码有点难写\n题目 1. 视频拼接 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1024/\n跳跃游戏 解法 见题解\n题目 1. 跳跃游戏 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-55/\n2. 跳跃游戏 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-45/\n同一时刻最多有多少重叠区间 解法 见题解\n题目 1. 会议室 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-253/\n暴力搜索算法 回溯 一般回溯问题 解法 详见题解\n题目 1. 电话号码的字母组合 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-17/\nN皇后 解法 利用回溯算法，在棋盘上从上往下下棋子，如果不能下就换个格子，如果一整行都不能下，就回溯到上一行换下一个格子\n题目 1. N 皇后 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-51/\n集合划分问题 解法 利用回溯算法，这种排列组合问题的各种变体都可以抽象成「球盒模型」，将子集看成盒子，那么每个盒子遍历一遍数组，要么将元素放盒子里面要么不放，就这样回溯，只不过代码有点难写\n题目 1. 划分为k个相等的子集 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-698/\n排列组合子集问题 解法 详见思想篇章\n题目 1. 子集 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-78/\n2. 组合 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-77/\n3. 全排列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-46/\n4. 子集 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-90/\n5. 组合总和 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-40/\n6. 全排列 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-47/\n7. 组合总和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-39/\n岛屿问题 解法 利用dfs的思想，遍历矩阵，如果碰到陆地就从这个元素开始dfs，同时将陆地全部变为海水，同时统计岛屿的个数\n详见：https://labuladong.gitee.io/algo/4/31/107/\n题目 1. 岛屿数量 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-200/\n2. 统计封闭岛屿的数目 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1254/\n3. 飞地的数量 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1020/\n4. 岛屿的最大面积 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-695/\n5. 统计子岛屿 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1905/\n6. 不同岛屿的数量 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-694/\n数独问题 解法 经典回溯问题，暴力求解即可\n题目 1. 解数独 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-37/\n括号生成 解法 经典回溯问题，穷举所有可能并且对不合理的情况剪枝即可\n题目 1. 括号生成 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-22/\nBFS BFS基本问题 解法 套模板即可，详见思想篇章\n题目 1. 二叉树的最小深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-111/\n2. 打开转盘锁 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-752/\nDFS DFS基本问题 解法 详见题解\n题目 1. 删除无效的括号 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-301/\n数学问题 随机算法 解法 有洗牌算法和蓄水池抽样算法两种，详见思想篇章\n题目 1. 打乱数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-384/\n2. 链表随机节点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-382/\n3. 随机数索引 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-398/\n位运算 解法 就那几个技巧，详见思想篇章\n题目 1. 位 1 的个数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-191/\n2. 2 的幂 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-231/\n3. 只出现一次的数字 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-136/\n4. 丢失的数字 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-268/\n阶乘后的零 解法 其实求阶乘结果有几个零就是求阶乘式子里可以分解出来几个因数5，其实就是n/5 + n/25 + n/125 + \u0026hellip;.\n题目 1. 阶乘后的零 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-172/\n2. 阶乘函数后 K 个零 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-793/\n素数筛选法 解法 详见思想篇章\n题目 1. 计数质数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-204/\n模幂运算 解法 详见思想篇章\n题目 1. 超级次方 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-372/\n经典面试题 分治算法 解法 通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。\n题目 1. 为运算表达式设计优先级 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-241/\n分割数组为连续子序列 解法 详见题解\n题目 1. 分割数组为连续子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-659/\n大整数乘法 解法 详见题解\n题目 1. 字符串相乘 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-43/\n实现计算器 解法 根本思想是建立一个栈，栈里存放目前遍历到的数字，比如1-2+3，栈里存放1、-2、3，最后将栈里的数字相加即可，详见：https://labuladong.gitee.io/algo/4/33/127/\n题目 1. 基本计算器 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-224/\n2. 基本计算器 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-227/\n括号相关问题 解法 详见题解\n题目 1. 有效的括号 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-20/\n2. 使括号有效的最少添加 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-921/\n3. 平衡括号字符串的最少插入次数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1541/\n区间问题 解法 区间类问题看起来都比较复杂，情况很多难以处理，但实际上通过观察各种不同情况之间的共性可以发现规律，用简洁的代码就能处理。\n题目 1. 删除被覆盖区间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1288/\n2. 合并区间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-56/\n3. 区间列表的交集 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-986/\n接雨水 解法 详见题解\n题目 1. 接雨水 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-42/\n2. 盛最多水的容器 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-11/\n完美矩形 解法 详见题解\n题目 1. 完美矩形 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-391/\n二分查找高效判定子序列 解法 详见题解\n题目 1. 判断子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-392/\n2. 匹配子序列的单词数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-792/\n思想 动态规划 动态规划问题有两个重要的特点，分别是最优子结构性质和存在重叠子问题，只要满足这两个条件都可以用动态规划\n流程 明确状态方程y = f(x)的定义\n确定「状态」，就是能描述一个问题局面所需的变量，也是原问题和子问题中会变化的变量。即y = f(x)中的x 确定y = f(x)中的y，一般是问题要求我们计算的量 确定「选择」，也就是导致「状态」产生变化的行为。即状态转移方程里的x应该选择哪一个 确定base case 写出状态转移方程（列出状态转移方程，就是在解决“如何穷举”的问题。），这个过程就是判断问题是否具有最优子结构性质（就是能否通过子问题的最优解求出原问题的最优解），此时可以通过状态转移方程写出递归写法，递归写法就是自顶向下的解法，但是这种写法一般存在重叠子问题\n判断问题是否具有重叠子问题，如果有，使用DP table代替f(x)函数，同时将递归改成迭代（也就是自底向上），DP table起到了记录子问题的作用，DP table 就是在追求“如何聪明地穷举”\n优化空间复杂度，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度\n精简流程 构造一个dp数组 确定dp数组里面放什么 dp数组里的元素怎么根据前面元素推出来（即状态转移方程） base case 优化空间复杂度 注意点 动态规划的核心问题是“如何穷举”（状态转移方程），然后考虑“如何聪明地穷举”（消除重叠子问题、剪枝） 算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举” 递归是自顶向下，dp table迭代是自底向上 dp数组的大小有时候要比原问题大一点，目的是防止特殊判断和dummy node的原理类似 dp 数组的遍历方向只要保证两点即可 遍历的过程中，所需的状态必须是已经计算出来的 遍历结束后，存储结果的那个位置必须已经被计算出来 经典问题 子序列问题 一般y = f(x)的x都是数组的索引，y是以这个索引对应的元素结尾的最长\u0026hellip;子序列或者数组[0\u0026hellip;x]的最长\u0026hellip;子序列，两个数组同理，只不过是二维的\n如果是两个字符串，求最长\u0026hellip;子序列，一个常用的思路就是根据每两个字符是否相同来判断他们是否在结果子序列中，从而避免了对所有子序列进行穷举。\n记住一个思想s1[i]和s2[j]不相等时，不可能同时出现在最长\u0026hellip;子序列中，因为对于当前的子问题来说，s1[i]和s2[j]是字符串的最后一个字符\n一般有两种思路，第一种思路模板是一个一维的 dp 数组：\nint n = array.length; int[] dp = new int[n]; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { dp[i] = 最值(dp[i], dp[j] + ...) } } 第二种思路模板是一个二维的 dp 数组：\nint n = arr.length; int[][] dp = new dp[n][n]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (arr[i] == arr[j]) dp[i][j] = dp[i][j] + ... else dp[i][j] = 最值(...) } } 背包问题 0-1背包问题 构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。base case是第一行和第一列取值为0，可以优化空间复杂度，模板如下：\nint knapsack(int W, int N, int[] wt, int[] val) { assert N == wt.length; // base case 已初始化 int[][] dp = new int[N + 1][W + 1]; for (int i = 1; i \u0026lt;= N; i++) { for (int w = 1; w \u0026lt;= W; w++) { if (w - wt[i - 1] \u0026lt; 0) { // 这种情况下只能选择不装入背包 dp[i][w] = dp[i - 1][w]; } else { // 装入或者不装入背包，择优 dp[i][w] = Math.max( dp[i - 1][w - wt[i-1]] + val[i-1], dp[i - 1][w] ); } } } return dp[N][W]; } 详见：https://labuladong.gitee.io/algo/3/27/81/\n子集背包问题 子集背包问题就是子集划分问题，就是给定一个数组和一个数字，让求数组里有几种子集和为该数字\n与0-1背包问题相似，就是问题不是该背包最多能装多少东西，而是被刚好装满有几种方式\n构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下 dp[i][w]表示被刚好装满有几种方式。base case是dp[0][0]=1（第一列不能都为0，因为数组里可能有0），可以优化空间复杂度，但是要注意j需要倒着遍历\n模板如下：\n/* 计算 nums 中有几个子集的和为 sum */ int subsets(int[] nums, int sum) { int n = nums.length; int[][] dp = new int[n + 1][sum + 1]; // base case dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= sum; j++) { if (j \u0026gt;= nums[i-1]) { // 两种选择的结果之和 dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]; } else { // 背包的空间不足，只能选择不装物品 i dp[i][j] = dp[i-1][j]; } } } return dp[n][sum]; } 详见：https://labuladong.gitee.io/algo/3/27/82/\n完全背包问题 与0-1背包问题相似，构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，可以重复选择第i个物品，这种情况下正好将背包装满的方式有 dp[i][w] 种。base case是第一列取值为1，可以优化空间复杂度，模板如下：\nint change(int amount, int[] coins) { int n = coins.length; int[][] dp = int[n + 1][amount + 1]; // base case for (int i = 0; i \u0026lt;= n; i++) dp[i][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= amount; j++) if (j - coins[i-1] \u0026gt;= 0) dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i-1]]; else dp[i][j] = dp[i - 1][j]; } return dp[n][amount]; } 详见：https://labuladong.gitee.io/algo/3/27/83/\nKMP算法 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/97/\n其中状态机的影子X比较难理解，其实就是对于一个自动机，s[0\u0026hellip;i]输入之后会走到j这个状态，X就是s[1\u0026hellip;i]输入自动机之后走到的状态（所以X = dp[X][pat.charAt(j)];，j从1开始），也就是s[0\u0026hellip;i]不匹配之后应该走到的状态（因为s[0\u0026hellip;i]不匹配，那肯定重新从s[1\u0026hellip;i]开始匹配），也就是j这个状态不匹配时应该回到X这个状态，所以有当pat.charAt(j) != c时dp[j][c] = dp[X][c];，还要注意该自动机是一边生成一边推进j和X的（其实就是动态规划），而不是先生成好自动机，再进行匹配，而且j用到了X（不匹配的时候），X也用到了j（因为X在j的后面，j走过的路自动机已经生成好了），就是下面这张图：\n模板如下：\npublic class KMP { private int[][] dp; private String pat; public KMP(String pat) { this.pat = pat; int M = pat.length(); // dp[状态][字符] = 下个状态 dp = new int[M][256]; // base case dp[0][pat.charAt(0)] = 1; // 影子状态 X 初始为 0 int X = 0; // 构建状态转移图（稍改的更紧凑了） for (int j = 1; j \u0026lt; M; j++) { for (int c = 0; c \u0026lt; 256; c++) dp[j][c] = dp[X][c]; dp[j][pat.charAt(j)] = j + 1; // 更新影子状态 X = dp[X][pat.charAt(j)]; } } public int search(String txt) { int M = pat.length(); int N = txt.length(); // pat 的初始态为 0 int j = 0; for (int i = 0; i \u0026lt; N; i++) { // 计算 pat 的下一个状态 j = dp[j][txt.charAt(i)]; // 到达终止态，返回结果 if (j == M) return i - M + 1; } // 没到达终止态，匹配失败 return -1; } } 贪心算法 贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。\n什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。\n贪心算法题目，大多一眼就能看出来，大不了就先用动态规划求解，如果动态规划都超时，说明该问题存在贪心选择性质无疑了。\n回溯 回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」\n废话不多说，直接上回溯算法框架，解决一个回溯问题，实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，你只需要思考 3 个问题：\n1、路径：也就是已经做出的选择。\n2、选择列表：也就是你当前可以做的选择。\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。（注意结束条件不只有满足条件的情况，也要考虑不满足条件的情况，到决策树底层就得结束）\n模板 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: # 做选择 将该选择从选择列表移除 路径.add(选择) backtrack(路径, 选择列表) # 撤销选择 路径.remove(选择) 将该选择再加入选择列表 思考回溯问题时，一定要把递归过程想成一棵树，不同的选择就是不同的分支，backtrack函数开头就是进入一个结点时要做什么，一般都是判断是否应该进入这个结点（其实就是剪枝）和当前结点是否满足结束条件，其实仔细想想，只要是牵扯到递归的都可以想象成一棵树（因为考虑问题比较方便），比如dfs，回溯，等等\n其实想想看，回溯算法和动态规划是不是有点像呢？动态规划的三个需要明确的点就是「状态」「选择」和「base case」，正好就对应着走过的「路径」，当前的「选择列表」和「结束条件」\n注意：\n带备忘录的回溯就叫做记忆化回溯，记忆化回溯就相当于动态规划，因为记忆化回溯消除了重叠子问题，消除了重叠子问题就相当于动态规划了\n排列组合子集问题 由于子集问题和组合问题本质上是一样的，无非就是 base case 有一些区别，所以把这两个问题放在一起看。\n形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，backtrack 核心代码如下：\n/* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i \u0026lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.removeLast(); } } /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { // 剪枝逻辑 if (used[i]) { continue; } // 做选择 used[i] = true; track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); used[i] = false; } } 形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝，backtrack 核心代码如下：\nArrays.sort(nums); /* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i \u0026lt; nums.length; i++) { // 剪枝逻辑，跳过值相同的相邻树枝 if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.removeLast(); } } Arrays.sort(nums); /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { // 剪枝逻辑 if (used[i]) { continue; } // 剪枝逻辑，固定相同的元素在排列中的相对位置 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } // 做选择 used[i] = true; track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); used[i] = false; } } 形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可，backtrack 核心代码如下：\n/* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i \u0026lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i); // 撤销选择 track.removeLast(); } } /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); } } 详见：https://labuladong.gitee.io/algo/4/31/106/\nBFS 即广度优先搜索，不多说了，模板如下：\n// 计算从起点 start 到终点 target 的最近距离 int BFS(Node start, Node target) { Queue\u0026lt;Node\u0026gt; q; // 核心数据结构 Set\u0026lt;Node\u0026gt; visited; // 避免走回头路 q.offer(start); // 将起点加入队列 visited.add(start); int step = 0; // 记录扩散的步数 while (q not empty) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i \u0026lt; sz; i++) { Node cur = q.poll(); /* 划重点：这里判断是否到达终点 */ if (cur is target) return step; /* 将 cur 的相邻节点加入队列 */ for (Node x : cur.adj()) { if (x not in visited) { q.offer(x); visited.add(x); } } } /* 划重点：更新步数在这里 */ step++; } } 队列 q 就不说了，BFS 的核心数据结构；cur.adj() 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；visited 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。\n流程如下所示：\n数学 随机算法 洗牌算法 一般解决随机打乱一个数组问题，算法如下：\npublic int[] shuffle(int[] nums) { int n = nums.length; for (int i = 0 ; i \u0026lt; n; i++) { // 生成一个 [i, n-1] 区间内的随机数 int r = i + rand.nextInt(n - i); // 交换 nums[i] 和 nums[r] swap(nums, i, r); } return copy; } 蓄水池抽样算法 可以解决在一堆数据中随机取出一个或多个数据，算法如下：\n/* 返回链表中一个随机节点的值 */ int getRandom(ListNode head) { Random r = new Random(); int i = 0, res = 0; ListNode p = head; // while 循环遍历链表 while (p != null) { i++; // 生成一个 [0, i) 之间的整数 // 这个整数等于 0 的概率就是 1/i if (0 == r.nextInt(i)) { res = p.val; } p = p.next; } return res; } 证明如下：\n取出k个元素：\n/* 返回链表中 k 个随机节点的值 */ int[] getRandom(ListNode head, int k) { Random r = new Random(); int[] res = new int[k]; ListNode p = head; // 前 k 个元素先默认选上 for (int i = 0; i \u0026lt; k \u0026amp;\u0026amp; p != null; i++) { res[i] = p.val; p = p.next; } int i = k; // while 循环遍历链表 while (p != null) { i++; // 生成一个 [0, i) 之间的整数 int j = r.nextInt(i); // 这个整数小于 k 的概率就是 k/i if (j \u0026lt; k) { res[j] = p.val; } p = p.next; } return res; } 证明如下：\n详见：https://labuladong.gitee.io/algo/4/32/113/\n位运算 判断两个数是否异号 int x = -1, y = 2; boolean f = ((x ^ y) \u0026lt; 0); // true int x = 3, y = 2; boolean f = ((x ^ y) \u0026lt; 0); // false n \u0026amp; (n-1) 的运用 消除数字 n 的二进制表示中的最后一个 1，即Brian Kernighan算法\na ^ a = 0 的运用 一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。而且异或运算满足交换律和结合律\n素数筛选法 求[2\u0026hellip;n]之间的所有的素数可以这样求，从2开始遍历，遍历到的数字的整数倍一定不是素数，这样排除遍历到n的时候，没被排除的就是[2\u0026hellip;n]的素数，模板如下：\nint countPrimes(int n) { boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); for (int i = 2; i * i \u0026lt; n; i++) if (isPrime[i]) for (int j = i * i; j \u0026lt; n; j += i) isPrime[j] = false; int count = 0; for (int i = 2; i \u0026lt; n; i++) if (isPrime[i]) count++; return count; } 这里优化了两个地方，详见：https://labuladong.gitee.io/algo/4/32/116/\n模幂运算 模幂运算就是求a^b%k，就是对幂取模，所以叫模幂运算\n(a * b) % k = ((a % k) * (b % k)) % k，当a*b会溢出时可以用这个技巧，可以拓展到多个数相乘然后取余，只不过要记得每个乘法都要做一次这个运算，比如(a * b * c) % k -\u0026gt; (((a % k) * (b % k)) % k) * c = (((a % k) * (b % k)) % k) * (c % k) % k，只要做乘法就要取模\n模板 int base = 1337; // 计算 a 的 k 次方然后与 base 求模的结果 int mypow(int a, int k) { // 对因子求模 a %= base; int res = 1; for (int _ = 0; _ \u0026lt; k; _++) { // 这里有乘法，是潜在的溢出点 res *= a; // 对乘法结果求模 res %= base; } return res; } 如何高效求幂？\n利用幂运算的性质，我们可以写出这样一个递归式：\n这样就不用傻乎乎的从第一个乘到最后一个了\n模板 int mypow(int a, int k, int MOD) { if (k == 0) return 1; a %= MOD; if (k % 2 == 1) { // k 是奇数 return (int) (((long)a * mypow(a, k - 1, MOD)) % MOD); } else { // k 是偶数 int sub = mypow(a, k / 2, MOD); return (int) (((long)sub * sub) % MOD); } // 还有一种迭代的写法 // int res = 1; // while(k != 0) { // if (k \u0026amp; 1 == 1) { // res = ((long)res * a) % MOD; // } // k /= 2; // a = ((long)a * a) % MOD; // } // return res; } 求组合数 模板如下：\npublic int combination(int m, int n) { long res = 1; for (int i = n - m + 1, j = 1; j \u0026lt;= m; i++, j++) { res = res * i / j; } return (int) res; } 注意i必须从n - m + 1开始乘，因为从n开始乘会溢出\n零碎 四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。详见：https://leetcode.cn/problems/perfect-squares/solutions/822940/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/ 分治算法 分治算法可以认为是一种算法思想，通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。\n与动态规划和回溯类似，都是通过子问题的解推出来的原问题的解\n详见：https://labuladong.gitee.io/algo/4/33/122/\n自动机 就是根据不同的输入进入不同的状态\n模板 class Solution { public int myAtoi(String s) { Automaton automaton = new Automaton(); for (char c : s.toCharArray()) { automaton.get(c); } return (int) (automaton.sign * automaton.res); } class Automaton { int sign = 1; long res = 0; String state = \u0026#34;start\u0026#34;; Map\u0026lt;String, String[]\u0026gt; table = new HashMap\u0026lt;\u0026gt;() { { put(\u0026#34;start\u0026#34;, new String[]{\u0026#34;start\u0026#34;, \u0026#34;signed\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;signed\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;in_number\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;end\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;}); } }; public void get(char c) { state = table.get(state)[getCol(c)]; if (state == \u0026#34;in_number\u0026#34;) { res = res * 10 + c - \u0026#39;0\u0026#39;; res = sign == 1 ? Math.min(res, Integer.MAX_VALUE) : Math.min(res, -(long) Integer.MIN_VALUE); } else if (state == \u0026#34;signed\u0026#34;) { sign = c == \u0026#39;+\u0026#39; ? 1 : -1; } } private int getCol(char c) { if (c == \u0026#39; \u0026#39;) { return 0; } if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) { return 1; } if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return 2; } return 3; } } } 这是力扣第8题的答案\n其他 零碎 二分查找的左侧边界的定义就是该边界及该边界右边的元素都大于等于查找元素，右侧边界的定义就是该边界及该边界左边的元素都小于等于查找元素\n向上取整可以用(val + 2) / 3，即(val + n - 1) / n\n字符串比较大小 比如ABC与ACDE比较，第一个字符相同，继续比较第二个字符，由于第二个字符是后面一个串大，所以不再继续比较，结果就是后面个串大。再如ABC与ABC123比较，比较三个字符后第一个串结束，所以就是后面一个串大，可以认为一个字符串到头了那这个字符串当前比较的字符就是最小的（因为这个字符都不存在）\n待做 LinkedHashMap是什么\nhttps://labuladong.gitee.io/algo/3/28/88/没看\nhttps://labuladong.gitee.io/algo/3/28/89/没看\nhttps://labuladong.gitee.io/algo/3/28/93/没看\nhttps://labuladong.gitee.io/algo/3/28/94/没看\nhttps://labuladong.gitee.io/algo/3/28/91/没看\nhttps://labuladong.gitee.io/algo/3/28/92/没看\nhttps://labuladong.gitee.io/algo/4/31/111/没看\nhttps://labuladong.gitee.io/algo/4/32/118/没看\nhttps://labuladong.gitee.io/algo/4/33/125/没看\nhttps://labuladong.gitee.io/algo/4/33/131/没看\n山谷(Valley)问题是什么（二分查找）\n技巧 学习方法 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-2/","summary":"动态规划基本问题 解法 经典动态规划问题，详见思想篇章 题目 1. 斐波那契数 题解详见：https://blog.zhangmengyang.tk/po","title":"LeetCode Note 2"},{"content":"思路 经典动态规划问题，具有最优子结构性质，“状态”为金额，“选择”为硬币的面值，dp数组定义为dp[金额] = 取得该金额需要的最少硬币，”basecase“为dp[0] = 0，状态转移方程如下：\n直接递归存在重复子问题，所以用dp数组迭代方式\n代码 class Solution { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for(int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i - coin \u0026lt; 0) { continue; } dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] == amount + 1 ? -1 : dp[amount]; } } References 1. 零钱兑换 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-322/","summary":"思路 经典动态规划问题，具有最优子结构性质，“状态”为金额，“选择”为硬币的面值，dp数组定义为dp[金额] = 取得该金额需要的最少硬币，”ba","title":"LeetCode 322"},{"content":"思路 状态转移方程很简单，注意一下直接递归会有重复子问题，所以可以使用数组备份一下（其实就是dp数组），又发现只会用到每个元素的前两个元素，所以可以把数组换成前两个元素\n代码 class Solution { public int fib(int n) { if (n == 0 || n == 1) { return n; } int dp_i_1 = 0, dp_i_2 = 1; for (int i = 2; i \u0026lt;= n; i++) { int dp_i_3 = dp_i_1 + dp_i_2; dp_i_1 = dp_i_2; dp_i_2 = dp_i_3; } return dp_i_2; } } References 1. 斐波那契数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-509/","summary":"思路 状态转移方程很简单，注意一下直接递归会有重复子问题，所以可以使用数组备份一下（其实就是dp数组），又发现只会用到每个元素的前两个元素，所","title":"LeetCode 509"},{"content":"思路 直接套用队列实现栈的模板即可，详见思想篇章\n代码 class MyStack { private Queue\u0026lt;Integer\u0026gt; q; private int topElem; public MyStack() { q = new LinkedList\u0026lt;\u0026gt;(); } public void push(int x) { q.offer(x); topElem = x; } public int pop() { int size = q.size(); while (size \u0026gt; 2) { q.offer(q.poll()); size--; } topElem = q.peek(); q.offer(q.poll()); return q.poll(); } public int top() { return topElem; } public boolean empty() { return q.isEmpty(); } } References 1. 用队列实现栈 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-225/","summary":"思路 直接套用队列实现栈的模板即可，详见思想篇章 代码 class MyStack { private Queue\u0026lt;Integer\u0026gt; q; private int topElem; public MyStack() { q = new LinkedList\u0026lt;\u0026gt;(); } public void push(int x) { q.offer(x); topElem = x; } public int pop() { int size = q.size(); while (size \u0026gt; 2) { q.offer(q.poll()); size--; } topElem =","title":"LeetCode 225"},{"content":"思路 直接套栈实现队列模板即可，详见思想篇章\n代码 class MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { s2.push(x); } public int pop() { peek(); return s1.pop(); } public int peek() { if (s1.isEmpty()) { while (!s2.isEmpty()) { s1.push(s2.pop()); } } return s1.peek(); } public boolean empty() { return s1.isEmpty() \u0026amp;\u0026amp; s2.isEmpty(); } } References 1. 用栈实现队列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-232/","summary":"思路 直接套栈实现队列模板即可，详见思想篇章 代码 class MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { s2.push(x); } public int pop() { peek(); return s1.pop(); } public int peek() { if (s1.isEmpty()) { while (!s2.isEmpty()) { s1.push(s2.pop()); } }","title":"LeetCode 232"},{"content":"思路 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色），详见思想篇章\n代码 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); MonotonicQueue window = new MonotonicQueue(); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026lt; k - 1) { window.push(nums[i]); } else { window.push(nums[i]); res.add(window.max()); window.poll(nums[i - k + 1]); } } int[] arr = new int[res.size()]; for (int i = 0; i \u0026lt; res.size(); i++) { arr[i] = res.get(i); } return arr; } class MonotonicQueue { LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); private void push(int n) { while (!queue.isEmpty() \u0026amp;\u0026amp; queue.getLast() \u0026lt; n) { queue.pollLast(); } queue.addLast(n); } private void poll(int n) { if (n == queue.getFirst()) { queue.pollFirst(); } } private int max() { return queue.getFirst(); } } } References 1. 滑动窗口最大值 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-239/","summary":"思路 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色","title":"LeetCode 239"},{"content":"思路 利用单调栈的思想，同LeetCode-496，只不过牵扯到循环数组的问题，常用套路就是将数组长度翻倍，代码实现的时候也可以用i % nums.length来模拟数组长度翻倍\n代码 class Solution { public int[] nextGreaterElements(int[] nums) { int n = nums.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i = 2 * n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026lt;= nums[i % n]) { stack.pop(); } res[i % n] = stack.isEmpty() ? -1 : stack.peek(); stack.push(nums[i % n]); } return res; } } References 1. 下一个更大元素 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-503/","summary":"思路 利用单调栈的思想，同LeetCode-496，只不过牵扯到循环数组的问题，常用套路就是将数组长度翻倍，代码实现的时候也可以用i % nums","title":"LeetCode 503"},{"content":"思路 利用单调栈的思想即可，同LeetCode-496，只不过这次存的是索引而不是元素\n代码 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i = n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt;= temperatures[i]) { stack.pop(); } res[i] = stack.isEmpty() ? 0 : (stack.peek() - i); stack.push(i); } return res; } } References 1. 每日温度 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-739/","summary":"思路 利用单调栈的思想即可，同LeetCode-496，只不过这次存的是索引而不是元素 代码 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i =","title":"LeetCode 739"},{"content":"思路 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充当下一个更大元素的角色（中间去除的元素是无法充当这种角色的），那么此时栈顶就是当前元素下一个更大元素\n代码 class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int n = nums2.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; res = new HashMap\u0026lt;\u0026gt;(); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026lt;= nums2[i]) { stack.pop(); } res.put(nums2[i], stack.isEmpty() ? -1 : stack.peek()); stack.push(nums2[i]); } for (int i = 0; i \u0026lt; nums1.length; i++) { nums1[i] = res.get(nums1[i]); } return nums1; } } References 1. 下一个更大元素 I ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-496/","summary":"思路 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充","title":"LeetCode 496"},{"content":"思路 经典TrieMap问题，不解释\n代码 class MapSum { private TrieMap\u0026lt;Integer\u0026gt; trieMap; public MapSum() { this.trieMap = new TrieMap(); } public void insert(String key, int val) { trieMap.put(key, val); } public int sum(String prefix) { List\u0026lt;String\u0026gt; keys = trieMap.keysWithPrefix(prefix); int res = 0; for (String key : keys) { res += trieMap.get(key); } return res; } class TrieMap { /* 见思想篇章 */ } } References 1. 键值映射 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-677/","summary":"思路 经典TrieMap问题，不解释 代码 class MapSum { private TrieMap\u0026lt;Integer\u0026gt; trieMap; public MapSum() { this.trieMap = new TrieMap(); } public void insert(String key, int val) { trieMap.put(key, val); } public int sum(String prefix) { List\u0026lt;String\u0026gt; keys = trieMap.keysWithPrefix(prefix); int res = 0; for (String key : keys) { res += trieMap.get(key); } return res; } class","title":"LeetCode 677"},{"content":"思路 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg\n代码 class MedianFinder { private Queue\u0026lt;Integer\u0026gt; small; private Queue\u0026lt;Integer\u0026gt; large; public MedianFinder() { small = new PriorityQueue\u0026lt;\u0026gt;(); large = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b - a; }); } public void addNum(int num) { if (small.size() \u0026gt; large.size()) { small.offer(num); large.offer(small.poll()); } else { large.offer(num); small.offer(large.poll()); } } public double findMedian() { if (small.size() \u0026gt; large.size()) { return small.peek(); } else if (small.size() \u0026lt; large.size()) { return large.peek(); } else { return (small.peek() + large.peek()) / 2.0; } } } References 1. 数据流的中位数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-295/","summary":"思路 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：h","title":"LeetCode 295"},{"content":"思路 利用Trie树的思想即可，详见思想篇章\n代码 class WordDictionary { private TrieNode root; private static class TrieNode { boolean isEnd = false; TrieNode[] children = new TrieNode[26]; } public WordDictionary() { this.root = new TrieNode(); } public void addWord(String word) { this.root = put(root, word, 0); } private TrieNode put(TrieNode node, String word, int i) { if (node == null) { node = new TrieNode(); } if (i == word.length()) { node.isEnd = true; return node; } int c = word.charAt(i) - \u0026#39;a\u0026#39;; node.children[c] = put(node.children[c], word, i + 1); return node; } public boolean search(String word) { return hasKeyWithPattern(root, word, 0); } private boolean hasKeyWithPattern(TrieNode node, String word, int i) { if (node == null) { return false; } if (i == word.length()) { return node.isEnd; } char c = word.charAt(i); if (c != \u0026#39;.\u0026#39;) { return hasKeyWithPattern(node.children[c - \u0026#39;a\u0026#39;], word, i + 1); } for (int j = 0; j \u0026lt; 26; j++) { if (hasKeyWithPattern(node.children[j], word, i + 1)) { return true; } } return false; } } References 1. 添加与搜索单词 - 数据结构设计 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-211/","summary":"思路 利用Trie树的思想即可，详见思想篇章 代码 class WordDictionary { private TrieNode root; private static class TrieNode { boolean isEnd = false; TrieNode[] children = new TrieNode[26]; } public WordDictionary() { this.root = new TrieNode(); } public void addWord(String word) { this.root = put(root, word, 0); } private TrieNode put(TrieNode node, String word, int","title":"LeetCode 211"},{"content":"思路 经典前缀树（Trie）问题，只不过需要注意将dictionary添加进set即可（因为只添加进set的字符串才能充当前缀）\n代码 class Solution { public String replaceWords(List\u0026lt;String\u0026gt; dictionary, String sentence) { TrieSet trieSet = new TrieSet(); for (String key : dictionary) { trieSet.add(key); } String[] words = sentence.split(\u0026#34; \u0026#34;); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; words.length; i++) { String word = words[i]; String prefix = trieSet.shortestPrefixOf(word); if (prefix.isEmpty()) { sb.append(word); } else { sb.append(prefix); } if (i != words.length - 1) { sb.append(\u0026#34; \u0026#34;); } } return sb.toString(); } class TrieSet { /* 见思想篇章 */ } class TrieMap { /* 见思想篇章 */ } } References 1. 单词替换 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-648/","summary":"思路 经典前缀树（Trie）问题，只不过需要注意将dictionary添加进set即可（因为只添加进set的字符串才能充当前缀） 代码 class Solution { public String","title":"LeetCode 648"},{"content":"思路 经典前缀树（Trie）问题，直接套模板即可，详见思想篇章\n代码 class Trie { private TrieSet trieSet; public Trie() { this.trieSet = new TrieSet(); } public void insert(String word) { trieSet.add(word); } public boolean search(String word) { return trieSet.contains(word); } public boolean startsWith(String prefix) { return trieSet.hasKeyWithPrefix(prefix); } class TrieSet { /* 见思想篇章 */ } class TrieMap { /* 见思想篇章 */ } } References 1. 实现 Trie (前缀树) ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-208/","summary":"思路 经典前缀树（Trie）问题，直接套模板即可，详见思想篇章 代码 class Trie { private TrieSet trieSet; public Trie() { this.trieSet = new TrieSet(); } public void insert(String word) { trieSet.add(word); } public boolean search(String word) { return trieSet.contains(word); } public boolean startsWith(String prefix) { return trieSet.hasKeyWithPrefix(prefix); } class","title":"LeetCode 208"},{"content":"思路 经典LRU缓存问题，直接套LRU模板即可，详见思想篇章\n代码 手写轮子 class LRUCache { private Map\u0026lt;Integer, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private DoubleList cache = new DoubleList(); private int capacity; public LRUCache(int capacity) { this.capacity = capacity; } public int get(int key) { if (!map.containsKey(key)) { return -1; } makeRecently(key); return map.get(key).val; } public void put(int key, int value) { if (map.containsKey(key)) { deleteKey(key); addRecently(key, value); return; } if (cache.size() == capacity) { removeLeastRecently(); } addRecently(key, value); } private void makeRecently(int key) { Node x = map.get(key); cache.remove(x); cache.addLast(x); } private void addRecently(int key, int val) { Node x = new Node(key, val); cache.addLast(x); map.put(key, x); } private void deleteKey(int key) { Node x = map.get(key); cache.remove(x); map.remove(key); } private void removeLeastRecently() { Node x = cache.removeFirst(); map.remove(x.key); } class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class DoubleList { private Node head, tail; private int size; public DoubleList() { this.head = new Node(0, 0); this.tail = new Node(0, 0); head.next = tail; tail.prev = head; size = 0; } public void addLast(Node x) { x.next = tail; x.prev = tail.prev; tail.prev.next = x; tail.prev = x; size++; } public void remove(Node x) { x.prev.next = x.next; x.next.prev = x.prev; size--; } public Node removeFirst() { if (size == 0) { return null; } Node first = head.next; remove(first); return first; } public int size() { return size; } } } 重用LinkedHashMap class LRUCache { int cap; LinkedHashMap\u0026lt;Integer, Integer\u0026gt; cache = new LinkedHashMap\u0026lt;\u0026gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() \u0026gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); } } References 1. LRU 缓存 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-146/","summary":"思路 经典LRU缓存问题，直接套LRU模板即可，详见思想篇章 代码 手写轮子 class LRUCache { private Map\u0026lt;Integer, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private DoubleList cache = new DoubleList(); private int capacity; public LRUCache(int capacity) { this.capacity = capacity; } public int get(int key) { if (!map.containsKey(key)) {","title":"LeetCode 146"},{"content":"思路 经典LFU缓存问题，直接套LFU模板即可，详见思想篇章\n代码 class LFUCache { private Map\u0026lt;Integer, Integer\u0026gt; keyToVal; private Map\u0026lt;Integer, Integer\u0026gt; keyToFreq; private Map\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; private int minFreq; private int capacity; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.capacity = capacity; this.minFreq = 0; } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } increaseFreq(key); return keyToVal.get(key); } public void put(int key, int value) { if (this.capacity == 0) { return; } if (keyToVal.containsKey(key)) { keyToVal.put(key, value); increaseFreq(key); return; } if (keyToVal.size() == this.capacity) { removeMinFreqKey(); } keyToVal.put(key, value); keyToFreq.put(key, 1); freqToKeys.putIfAbsent(1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(1).add(key); this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); keyToFreq.put(key, freq + 1); freqToKeys.get(freq).remove(key); freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(freq + 1).add(key); if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); if (this.minFreq == freq) { this.minFreq++; } } } private void removeMinFreqKey() { LinkedHashSet\u0026lt;Integer\u0026gt; keyList = freqToKeys.get(this.minFreq); int deleteKey = keyList.iterator().next(); keyList.remove(deleteKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 这里不用修改minFreq因为后面会置为1 } keyToVal.remove(deleteKey); keyToFreq.remove(deleteKey); } } References 1. LFU 缓存 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-460/","summary":"思路 经典LFU缓存问题，直接套LFU模板即可，详见思想篇章 代码 class LFUCache { private Map\u0026lt;Integer, Integer\u0026gt; keyToVal; private Map\u0026lt;Integer, Integer\u0026gt; keyToFreq; private Map\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; private int minFreq; private int capacity; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.capacity =","title":"LeetCode 460"},{"content":"思路 两种思路：\nkruskal 利用kruskal算法即可，只不过这里的边需要自己生成，详见思想章节\nprim 利用prim算法即可，只不过这里的边需要自己生成，详见思想章节\n代码 kruskal class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; List\u0026lt;int[]\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { int xi = points[i][0], yi = points[i][1]; int xj = points[j][0], yj = points[j][1]; edges.add(new int[]{i, j, Math.abs(xi - xj) + Math.abs(yi- yj)}); } } Collections.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UF uf = new UF(n); int mst = 0; for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (uf.connected(u, v)) { continue; } mst += weight; uf.union(u, v); } return mst; } class UF { // 连通分量个数 private int count; // 存储每个节点的父节点 private int[] parent; // n 为图中节点的个数 public UF(int n) { this.count = n; parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } // 将节点 p 和节点 q 连通 public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootQ] = rootP; // 两个连通分量合并成一个连通分量 count--; } // 判断节点 p 和节点 q 是否连通 public boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } // 返回图中的连通分量个数 public int count() { return count; } } } prim class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; List\u0026lt;int[]\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { int xi = points[i][0], yi = points[i][1]; int xj = points[j][0], yj = points[j][1]; int weight = Math.abs(xi - xj) + Math.abs(yi- yj); graph[i].add(new int[]{i, j, weight}); graph[j].add(new int[]{j, i, weight}); } } return new Prim(graph).getWeightSum(); } class Prim { private List\u0026lt;int[]\u0026gt;[] graph; private Queue\u0026lt;int[]\u0026gt; pq; private boolean[] inMST; private int weightSum = 0; public Prim(List\u0026lt;int[]\u0026gt;[] graph) { this.graph = graph; this.pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a[2] - b[2]; }); int n = graph.length; inMST = new boolean[n]; inMST[0] = true; cut(0); while (!pq.isEmpty()) { int[] edge = pq.poll(); int to = edge[1]; int weight = edge[2]; if (inMST[to]) { continue; } weightSum += weight; inMST[to] = true; cut(to); } } private void cut(int s) { for (int[] edge : graph[s]) { int to = edge[1]; if (inMST[to]) { continue; } pq.offer(edge); } } private int getWeightSum() { return weightSum; } private boolean allConnected() { for (boolean b : inMST) { if (!b) { return false; } } return true; } } } References 1. 连接所有点的最小费用 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1584/","summary":"思路 两种思路： kruskal 利用kruskal算法即可，只不过这里的边需要自己生成，详见思想章节 prim 利用prim算法即可，只不过这里的边需要自己生成，详见","title":"LeetCode 1584"},{"content":"思路 dijkstra问题的变种，利用dijkstra模板即可，主要有两个注意点：\n首先需要构造图，构造图时注意无向图的一条边相当于两条有向边 weight计算方式与普通的dijkstra不同，即需要修改weight函数 代码 class Solution { class State { int id; double probFromStart; public State(int id, double probFromStart) { this.id = id; this.probFromStart = probFromStart; } } private double dijkstra(List\u0026lt;double[]\u0026gt;[] graph, int start, int end) { double[] probTo = new double[graph.length]; Arrays.fill(probTo, -1); probTo[start] = 1; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;State\u0026gt;((a, b) -\u0026gt; { return Double.compare(b.probFromStart, a.probFromStart); }); pq.offer(new State(start, 1)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeId = curState.id; double curProbFromStart = curState.probFromStart; if (curNodeId == end) { return probTo[end]; } if (curProbFromStart \u0026lt; probTo[curNodeId]) { continue; } for (double[] neighbor : graph[curNodeId]) { int nextId = (int) neighbor[0]; double nextProbFromStart = curProbFromStart * neighbor[1]; if (nextProbFromStart \u0026gt; probTo[nextId]) { probTo[nextId] = nextProbFromStart; pq.offer(new State(nextId, nextProbFromStart)); } } } return 0.0; } public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) { List\u0026lt;double[]\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; succProb.length; i++) { int from = edges[i][0]; int to = edges[i][1]; double weight = succProb[i]; graph[from].add(new double[]{to, weight}); graph[to].add(new double[]{from, weight}); } return dijkstra(graph, start, end); } } References 1. 概率最大的路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1514/","summary":"思路 dijkstra问题的变种，利用dijkstra模板即可，主要有两个注意点： 首先需要构造图，构造图时注意无向图的一条边相当于两条有向边 w","title":"LeetCode 1514"},{"content":"思路 利用dijkstra的思想，只不过需要把矩阵里的每个元素当成一个结点，求一个结点的相邻结点与一般的图不同（即adj函数），而且最后求的体力消耗是路径上体力的最大值，不是体力消耗之和，所以刷新权重的时候需要编写相应的weight函数\n其实dijsktra问题的变种只要编写相应的adj函数和weight函数即可\n代码 class Solution { class State { int x, y; int effortFromStart; public State(int x, int y, int effortFromStart) { this.x = x; this.y = y; this.effortFromStart = effortFromStart; } } private int[][] dirs = new int[][]{{0, 1}, {0, -1}, {-1, 0}, {1, 0}}; private List\u0026lt;int[]\u0026gt; adj(int[][] matrix, int x, int y) { int m = matrix.length, n = matrix[0].length; List\u0026lt;int[]\u0026gt; neighbors = new ArrayList\u0026lt;\u0026gt;(); for (int[] dir : dirs) { int nx = x + dir[0]; int ny = y + dir[1]; if (nx \u0026lt; 0 || nx \u0026gt;= m || ny \u0026lt; 0 || ny \u0026gt;= n) { continue; } neighbors.add(new int[]{nx, ny}); } return neighbors; } public int minimumEffortPath(int[][] heights) { int m = heights.length, n = heights[0].length; int[][] effortTo = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { Arrays.fill(effortTo[i], Integer.MAX_VALUE); } effortTo[0][0] = 0; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.effortFromStart - b.effortFromStart; }); pq.offer(new State(0, 0, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curX = curState.x; int curY = curState.y; int curEffortFromStart = curState.effortFromStart; if (curX == m -1 \u0026amp;\u0026amp; curY == n - 1) { return curEffortFromStart; } if (curEffortFromStart \u0026gt; effortTo[curX][curY]) { continue; } for (int[] neighbor : adj(heights, curX, curY)) { int nextX = neighbor[0]; int nextY = neighbor[1]; int nextEffort = Math.max(effortTo[curX][curY], Math.abs(heights[nextX][nextY] - heights[curX][curY])); if (nextEffort \u0026lt; effortTo[nextX][nextY]) { effortTo[nextX][nextY] = nextEffort; pq.offer(new State(nextX, nextY, nextEffort)); } } } return -1; } } References 1. 最小体力消耗路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1631/","summary":"思路 利用dijkstra的思想，只不过需要把矩阵里的每个元素当成一个结点，求一个结点的相邻结点与一般的图不同（即adj函数），而且最后求的体","title":"LeetCode 1631"},{"content":"思路 经典dijkstra问题，利用dijkstra模板即可，详见思想章节\n代码 class Solution { class State { int id; int distFromStart; public State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } private int[] dijkstra(List\u0026lt;int[]\u0026gt;[] graph, int start) { int[] distTo = new int[graph.length]; Arrays.fill(distTo, Integer.MAX_VALUE); distTo[start] = 0; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.distFromStart - b.distFromStart; }); pq.offer(new State(start, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeId = curState.id; int curDistFromStart = curState.distFromStart; if (curDistFromStart \u0026gt; distTo[curNodeId]) { continue; } for (int[] neighbor : graph[curNodeId]) { int neighborId = neighbor[0]; int distToNeighbor = distTo[curNodeId] + neighbor[1]; if (distToNeighbor \u0026lt; distTo[neighborId]) { distTo[neighborId] = distToNeighbor; pq.offer(new State(neighborId, distToNeighbor)); } } } return distTo; } public int networkDelayTime(int[][] times, int n, int k) { List\u0026lt;int[]\u0026gt;[] graph = new List[n + 1]; for (int i = 1; i \u0026lt; n + 1; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int[] time : times) { int from = time[0]; int to = time[1]; int weight = time[2]; graph[from].add(new int[]{to, weight}); } int[] distTo = dijkstra(graph, k); int res = 0; for (int i = 1; i \u0026lt; n + 1; i++) { if (distTo[i] == Integer.MAX_VALUE) { return -1; } res = Math.max(res, distTo[i]); } return res; } } References 1. 网络延迟时间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-743/","summary":"思路 经典dijkstra问题，利用dijkstra模板即可，详见思想章节 代码 class Solution { class State { int id; int distFromStart; public State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } private int[] dijkstra(List\u0026lt;int[]\u0026gt;[] graph, int start) { int[]","title":"LeetCode 743"},{"content":"思路 利用并查集的思想，先将相等的连接起来，然后再判断不相等的是否与并查集里的连通状态冲突\n代码 class Solution { public boolean equationsPossible(String[] equations) { UF uf = new UF(26); for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) { uf.union(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;); } } for (String equation : equations) { if (equation.charAt(1) == \u0026#39;!\u0026#39;) { if (uf.isConnected(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;)) { return false; } } } return true; } class UF { private int[] parent; private int count; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } count = n; } public int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int xRoot = find(x); int yRoot = find(y); if (xRoot == yRoot) { return; } parent[xRoot] = yRoot; count--; } public boolean isConnected(int x, int y) { int xRoot = find(x); int yRoot = find(y); return xRoot == yRoot; } public int getCount() { return count; } } } References 1. 等式方程的可满足性 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-990/","summary":"思路 利用并查集的思想，先将相等的连接起来，然后再判断不相等的是否与并查集里的连通状态冲突 代码 class Solution { public boolean equationsPossible(String[] equations) { UF uf = new UF(26); for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) {","title":"LeetCode 990"},{"content":"思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的\u0026rsquo;O\u0026rsquo;相连的\u0026rsquo;O\u0026rsquo;加入到dummy的集合中，然后遍历一遍二维数组，将不在dummy集合里的\u0026rsquo;O\u0026rsquo;改成\u0026rsquo;X\u0026rsquo;即可\n代码 class Solution { public void solve(char[][] board) { int m = board.length; int n = board[0].length; UF uf = new UF(m * n + 1); int dummy = m * n; for (int i = 0; i \u0026lt; m; i++) { if (board[i][0] == \u0026#39;O\u0026#39;) { uf.union(dummy,i * n); } if (board[i][n - 1] == \u0026#39;O\u0026#39;) { uf.union(dummy,i * n + n - 1); } } for (int i = 0; i \u0026lt; n; i++) { if (board[0][i] == \u0026#39;O\u0026#39;) { uf.union(dummy, i); } if (board[m - 1][i] == \u0026#39;O\u0026#39;) { uf.union(dummy, (m - 1) * n + i); } } int[][] d = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; for (int i = 1; i \u0026lt; m - 1; i++) { for (int j = 1; j \u0026lt; n - 1; j++) { if (board[i][j] == \u0026#39;O\u0026#39;) { for (int k = 0; k \u0026lt; 4; k++) { int x = i + d[k][0]; int y = j + d[k][1]; if (board[x][y] == \u0026#39;O\u0026#39;) { uf.union(i * n + j, x * n + y); } } } } } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (!uf.isConnected(i * n + j, dummy)) { board[i][j] = \u0026#39;X\u0026#39;; } } } } class UF { private int[] parent; private int count; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } count = n; } public int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int xRoot = find(x); int yRoot = find(y); if (xRoot == yRoot) { return; } parent[xRoot] = yRoot; count--; } public boolean isConnected(int x, int y) { int xRoot = find(x); int yRoot = find(y); return xRoot == yRoot; } public int getCount() { return count; } } } References 1. 被围绕的区域 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-130/","summary":"思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的\u0026rsquo;O\u0026rsquo;相连的\u0026rsquo;O\u0026rsquo;加入到dum","title":"LeetCode 130"},{"content":"思路 经典二分图判断，只不过需要先构造一个图，详见思想章节\n代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(n, dislikes); for (int i = 1; i \u0026lt;= n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int n, int[][] dislikes) { List\u0026lt;Integer\u0026gt;[] graph = new List[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] dislike : dislikes) { int s = dislike[0]; int d = dislike[1]; graph[s].add(d); graph[d].add(s); } return graph; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int v) { if (!ok) { return; } visited[v] = true; for (int neighbor : graph[v]) { if (!visited[neighbor]) { color[neighbor] = !color[v]; traverse(graph, neighbor); } else { if (color[v] == color[neighbor]) { ok = false; return; } } } } } References 1. 可能的二分法 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-886/","summary":"思路 经典二分图判断，只不过需要先构造一个图，详见思想章节 代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(n, dislikes); for (int","title":"LeetCode 886"},{"content":"思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节\n代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color = new boolean[n]; visited = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private void traverse(int[][] graph, int v) { if (!ok) { return; } visited[v] = true; for (int neighbor : graph[v]) { if (!visited[neighbor]) { color[neighbor] = !color[v]; traverse(graph, neighbor); } else { if (color[v] == color[neighbor]) { ok = false; return; } } } } } BFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color = new boolean[n]; visited = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private void traverse(int[][] graph, int start) { if (!ok) { return; } Deque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); visited[start] = true; queue.offer(start); while (!queue.isEmpty() \u0026amp;\u0026amp; ok) { int v = queue.poll(); for (int n : graph[v]) { if (!visited[n]) { color[n] = !color[v]; visited[n] = true; queue.offer(n); } else { if (color[n] == color[v]) { ok = false; return; } } } } } } References 1. 判断二分图 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-785/","summary":"思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节 代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color","title":"LeetCode 785"},{"content":"思路 寻找可行的选课顺序其实就是计算拓扑排序\n思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序\n思路二 利用图的BFS，只不过只把入度为零的结点加入队列，队列出队的序列就是该图的拓扑排序\n代码 思路一 class Solution { private boolean[] visited; private boolean[] onPath; private boolean hasCycle = false; private List\u0026lt;Integer\u0026gt; postorder = new LinkedList\u0026lt;\u0026gt;(); public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i]) { traverse(graph, i); } } if (hasCycle) { return new int[0]; } Collections.reverse(postorder); int[] res = new int[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { res[i] = postorder.get(i); } return res; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; return; } if (visited[s]) { return; } visited[s] = true; onPath[s] = true; for (Integer n : graph[s]) { traverse(graph, n); } onPath[s] = false; postorder.add(s); } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } 思路二 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int to = edge[0]; indegree[to]++; } Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int count = 0; int[] res = new int[numCourses]; while (!queue.isEmpty()) { int node = queue.poll(); res[count] = node; count++; for (Integer next : graph[node]) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } if (count != numCourses) { return new int[0]; } return res; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } References 1. 课程表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-210/","summary":"思路 寻找可行的选课顺序其实就是计算拓扑排序 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无","title":"LeetCode 210"},{"content":"思路 这道题其实就是检测图里是否有环\n思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回\n思路二 利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列即可，最后判断访问过的结点个数是否等于总结点个数\n代码 思路一 class Solution { private boolean[] visited; private boolean[] onPath; private boolean hasCycle = false; public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i]) { traverse(graph, i); } } return !hasCycle; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; return; } if (visited[s]) { return; } visited[s] = true; onPath[s] = true; for (Integer n : graph[s]) { traverse(graph, n); } onPath[s] = false; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } 思路二 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int to = edge[0]; indegree[to]++; } Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int count = 0; while (!queue.isEmpty()) { int node = queue.poll(); count++; for (Integer next : graph[node]) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } return count == numCourses; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } References 1. 课程表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-207/","summary":"思路 这道题其实就是检测图里是否有环 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该","title":"LeetCode 207"},{"content":"思路 经典图的遍历，只不过要同时记录路径\n代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList\u0026lt;Integer\u0026gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s == n) { res.add(new LinkedList\u0026lt;\u0026gt;(path)); path.removeLast(); return; } for (int v : graph[s]) { traverse(graph, v, path); } // 离开结点时 path.removeLast(); } } References 1. 所有可能的路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-797/","summary":"思路 经典图的遍历，只不过要同时记录路径 代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList\u0026lt;Integer\u0026gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s","title":"LeetCode 797"},{"content":"思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树\n这种做法时间复杂度是O(logn*logn)，详见：https://labuladong.gitee.io/algo/2/21/48/\n代码 class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } TreeNode left = root, right = root; int lh = 0, rh = 0; while (left != null) { left = left.left; lh++; } while (right != null) { right = right.right; rh++; } if (lh == rh) { return (int) (Math.pow(2, lh) - 1); } return 1 + countNodes(root.left) + countNodes(root.right); } } References 1. 完全二叉树的节点个数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-222/","summary":"思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和","title":"LeetCode 222"},{"content":"思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是LCA\n代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { int val1 = Math.min(p.val, q.val); int val2 = Math.max(p.val, q.val); return find(root, val1, val2); } private TreeNode find(TreeNode root, int val1, int val2) { if (root == null) { return null; } if (root.val \u0026gt; val2) { return find(root.left, val1, val2); } if (root.val \u0026lt; val1) { return find(root.right, val1, val2); } return root; } } References 1. 二叉搜索树的最近公共祖先 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-235/","summary":"思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是","title":"LeetCode 235"},{"content":"思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或q或qp的LCA\n代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return findLCA(root, p.val, q.val); } private TreeNode findLCA(TreeNode root, int p, int q) { if (root == null) { return null; } if (root.val == p || root.val == q) { return root; } TreeNode left = findLCA(root.left, p, q); TreeNode right = findLCA(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left != null ? left : right; } } References 1. 二叉树的最近公共祖先 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-236/","summary":"思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或","title":"LeetCode 236"},{"content":"思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码\n思路二 思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代\n代码 思路一 public class NestedIterator implements Iterator\u0026lt;Integer\u0026gt; { private Iterator\u0026lt;Integer\u0026gt; it; public NestedIterator(List\u0026lt;NestedInteger\u0026gt; nestedList) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (NestedInteger nestedInteger : nestedList) { traverse(nestedInteger, result); } it = result.iterator(); } private void traverse(NestedInteger nestedInteger, List\u0026lt;Integer\u0026gt; result) { if (nestedInteger.isInteger()) { result.add(nestedInteger.getInteger()); return; } List\u0026lt;NestedInteger\u0026gt; list = nestedInteger.getList(); for (NestedInteger integer : list) { traverse(integer, result); } } @Override public Integer next() { return it.next(); } @Override public boolean hasNext() { return it.hasNext(); } } 思路二 public class NestedIterator implements Iterator\u0026lt;Integer\u0026gt; { private LinkedList\u0026lt;NestedInteger\u0026gt; nestedList; public NestedIterator(List\u0026lt;NestedInteger\u0026gt; nestedList) { this.nestedList = new LinkedList\u0026lt;\u0026gt;(nestedList); } @Override public Integer next() { return nestedList.remove(0).getInteger(); } @Override public boolean hasNext() { while (!nestedList.isEmpty() \u0026amp;\u0026amp; !nestedList.get(0).isInteger()) { List\u0026lt;NestedInteger\u0026gt; first = nestedList.remove(0).getList(); for (int i = first.size() - 1; i \u0026gt;= 0; i--) { nestedList.addFirst(first.get(i)); } } return !nestedList.isEmpty(); } } References 1. 扁平化嵌套列表迭代器 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-341/","summary":"思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码 思路二 思路一会在","title":"LeetCode 341"},{"content":"思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用\n我的代码 class Solution { private List\u0026lt;TreeNode\u0026gt; generateTrees(int min, int max) { List\u0026lt;TreeNode\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (min \u0026gt; max) { res.add(null); return res; } for (int i = min; i \u0026lt;= max; i++) { List\u0026lt;TreeNode\u0026gt; leftList = generateTrees(min, i - 1); List\u0026lt;TreeNode\u0026gt; rightList = generateTrees(i + 1, max); for (TreeNode leftNode : leftList) { for (TreeNode rightNode : rightList) { TreeNode root = new TreeNode(i); root.left = leftNode; root.right = rightNode; res.add(root); } } } return res; } public List\u0026lt;TreeNode\u0026gt; generateTrees(int n) { return generateTrees(1, n); } } References 1. 不同的二叉搜索树 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-95/","summary":"思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用 我的","title":"LeetCode 95"},{"content":"思路 三种思路：\n递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类\n动态规划 递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划\n数学思路 感觉没必要看\n我的代码 递归 class Solution { public int numTrees(int n) { if (n == 1 || n == 0) { return 1; } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += numTrees(i) * numTrees(n - i - 1); } return sum; } } 动态规划 class Solution { public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; i; j++) { dp[i] += dp[j] * dp[i - 1 - j]; } } return dp[n]; } } References 1. 不同的二叉搜索树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-96/","summary":"思路 三种思路： 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相","title":"LeetCode 96"},{"content":"思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种情况：\nroot左右皆为空，此时直接删除 root左右有一个为空，将不为空的子树替换为当前结点的位置 root左右都不为空，找左子树中最大的或右子树中最小的替换root 我的代码 class Solution { private TreeNode getMin(TreeNode root) { while (root.left != null) { root = root.left; } return root; } public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return null; if (root.val == key) { // 删除该结点 if (root.left == null \u0026amp;\u0026amp; root.right == null) { return null; } if (root.left == null) return root.right; if (root.right == null) return root.left; TreeNode min = getMin(root.right); root.right = deleteNode(root.right, min.val); min.left = root.left; min.right = root.right; root = min; } if (key \u0026gt; root.val) { root.right = deleteNode(root.right, key); } if (key \u0026lt; root.val) { root.left = deleteNode(root.left, key); } return root; } } References 1. 删除二叉搜索树中的节点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-504/","summary":"思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种","title":"LeetCode 504"},{"content":"思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造\n我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } if (val \u0026gt; root.val) { root.right = insertIntoBST(root.right, val); } if (val \u0026lt; root.val) { root.left = insertIntoBST(root.left, val); } return root; } } References 1. 二叉搜索树中的插入操作 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-701/","summary":"思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造 我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) {","title":"LeetCode 701"},{"content":"思路 利用二分查找的思想，不解释了\n我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val \u0026gt; root.val) { return searchBST(root.right, val); } if (val \u0026lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜索 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-700/","summary":"思路 利用二分查找的思想，不解释了 我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val \u0026gt; root.val) { return searchBST(root.right, val); } if (val \u0026lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜","title":"LeetCode 700"},{"content":"思路 两种思路：\n递归 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小+右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，而判断是子树的节点都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去\n中序遍历 先中序遍历，然后看遍历的序列是不是有序的\n我的代码 递归 class Solution { private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) { if (root == null) { return true; } if (min != null \u0026amp;\u0026amp; root.val \u0026lt;= min.val) return false; if (max != null \u0026amp;\u0026amp; root.val \u0026gt;= max.val) return false; return isValidBST(root.left, min, root) \u0026amp; isValidBST(root.right, root, max); } public boolean isValidBST(TreeNode root) { return isValidBST(root, null, null); } } 中序遍历 class Solution { private List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public boolean isValidBST(TreeNode root) { inorder(root); for (int i = 0; i \u0026lt; track.size() - 1; i++) { if (track.get(i) \u0026gt;= track.get(i + 1)) { return false; } } return true; } private void inorder(TreeNode root) { if (root == null) { return; } inorder(root.left); track.add(root.val); inorder(root.right); } } References 1. 验证二叉搜索树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-98/","summary":"思路 两种思路： 递归 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小+右边的的结点都比root大+左子树是BST+右子","title":"LeetCode 98"},{"content":"思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，这样的话遍历到当前节点的时候，比这个结点大的结点已经遍历完了，用个变量累加一下，然后赋值给当前结点就可以了\n我的代码 class Solution { private int sum = 0; public TreeNode convertBST(TreeNode root) { if (root == null) { return null; } convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root; } } References 1. 把二叉搜索树转换为累加树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-538/","summary":"思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，","title":"LeetCode 538"},{"content":"思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return\n我的代码 class Solution { private int rank = 0; public int kthSmallest(TreeNode root, int k) { if (root == null) { return 0; } int res; if ((res = kthSmallest(root.left, k)) != 0) { return res; } rank++; if (rank == k) { return root.val; } return kthSmallest(root.right, k); } } References 1. 二叉搜索树中第 K 小的元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-230/","summary":"思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return 我的代码 class Solution { private int rank","title":"LeetCode 230"},{"content":"思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（空结点和左右子树都不为null的结点），如果是那就出栈挂在新栈顶的左子树或右子树上，循环往复，直到所有的结点都被加入到栈中，树就被反序列化完成了\n官方思路一 序列化和反序列化均采用分解问题的思想，序列化不用多说，这里把反序列化问题拆分为：新建根节点+反序列化左子树+反序列化右子树（我当时为什么没想到，因为没想到还要写base case）\n官方思路二 使用文法的思想，可以将树用T -\u0026gt; (T) num (T) | X文法来序列化和反序列化，其实本质思路和我的思路一样\n代码 我的代码 public class Codec { private static final char NULL = \u0026#39;#\u0026#39;; private static final char SEP = \u0026#39;,\u0026#39;; private void doSerialize(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(NULL).append(SEP); return; } sb.append(root.val).append(SEP); doSerialize(root.left, sb); doSerialize(root.right, sb); } // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); doSerialize(root, sb); return sb.toString(); } private TreeNode newTreeNode(String val) { if (\u0026#34;#\u0026#34;.equals(val)) { return new TreeNode(-1001); } return new TreeNode(Integer.parseInt(val)); } private TreeNode fixTree(TreeNode root) { if (root == null || root.val == -1001) { return null; } root.left = fixTree(root.left); root.right = fixTree(root.right); return root; } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] nodes = data.split(\u0026#34;,\u0026#34;); Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); TreeNode dummyRoot = new TreeNode(1001); stack.push(dummyRoot); for (int i = 0; i \u0026lt; nodes.length; i++) { stack.push(newTreeNode(nodes[i])); while (stack.peek().val == -1001 || stack.peek().left != null \u0026amp;\u0026amp; stack.peek().right != null) { TreeNode peek = stack.pop(); if (stack.peek().left == null) { stack.peek().left = peek; } else { stack.peek().right = peek; } } } return fixTree(dummyRoot).left; } } 官方思路一 public class Codec { public String serialize(TreeNode root) { return rserialize(root, \u0026#34;\u0026#34;); } public TreeNode deserialize(String data) { String[] dataArray = data.split(\u0026#34;,\u0026#34;); List\u0026lt;String\u0026gt; dataList = new LinkedList\u0026lt;String\u0026gt;(Arrays.asList(dataArray)); return rdeserialize(dataList); } public String rserialize(TreeNode root, String str) { if (root == null) { str += \u0026#34;None,\u0026#34;; } else { str += str.valueOf(root.val) + \u0026#34;,\u0026#34;; str = rserialize(root.left, str); str = rserialize(root.right, str); } return str; } public TreeNode rdeserialize(List\u0026lt;String\u0026gt; dataList) { if (dataList.get(0).equals(\u0026#34;None\u0026#34;)) { dataList.remove(0); return null; } TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0))); dataList.remove(0); root.left = rdeserialize(dataList); root.right = rdeserialize(dataList); return root; } } 官方思路二 public class Codec { public String serialize(TreeNode root) { if (root == null) { return \u0026#34;X\u0026#34;; } String left = \u0026#34;(\u0026#34; + serialize(root.left) + \u0026#34;)\u0026#34;; String right = \u0026#34;(\u0026#34; + serialize(root.right) + \u0026#34;)\u0026#34;; return left + root.val + right; } public TreeNode deserialize(String data) { int[] ptr = {0}; return parse(data, ptr); } public TreeNode parse(String data, int[] ptr) { if (data.charAt(ptr[0]) == \u0026#39;X\u0026#39;) { ++ptr[0]; return null; } TreeNode cur = new TreeNode(0); cur.left = parseSubtree(data, ptr); cur.val = parseInt(data, ptr); cur.right = parseSubtree(data, ptr); return cur; } public TreeNode parseSubtree(String data, int[] ptr) { ++ptr[0]; // 跳过左括号 TreeNode subtree = parse(data, ptr); ++ptr[0]; // 跳过右括号 return subtree; } public int parseInt(String data, int[] ptr) { int x = 0, sgn = 1; if (!Character.isDigit(data.charAt(ptr[0]))) { sgn = -1; ++ptr[0]; } while (Character.isDigit(data.charAt(ptr[0]))) { x = x * 10 + data.charAt(ptr[0]++) - \u0026#39;0\u0026#39;; } return x * sgn; } } References 1. 二叉树的序列化与反序列化 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-297/","summary":"思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（","title":"LeetCode 297"},{"content":"思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树\n详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] preorder, int preStart, int preEnd, int[] postorder, int postStart, int postEnd) { if (preStart \u0026gt; preEnd) { return null; } if (preStart == preEnd) { return new TreeNode(preorder[preStart]); } int val = preorder[preStart]; TreeNode root = new TreeNode(val); int leftIndex = valToIndex.get(preorder[preStart + 1]); int leftSize = leftIndex - postStart + 1; TreeNode left = build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, leftIndex); TreeNode right = build(preorder, preStart + leftSize + 1, preEnd, postorder, leftIndex + 1, postEnd - 1); root.left = left; root.right = right; return root; } public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { for (int i = 0; i \u0026lt; postorder.length; i++) { valToIndex.put(postorder[i], i); } return build(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1); } } References 1. 根据前序和后序遍历构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-889/","summary":"思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树 详见：https://blog.zhangmengya","title":"LeetCode 889"},{"content":"思路 同LeetCode-105，就是改一下递归的参数\n详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] postorder, int postStart, int postEnd, int[] inorder, int inStart, int inEnd) { if (postStart \u0026gt; postEnd) { return null; } int val = postorder[postEnd]; TreeNode root = new TreeNode(val); int index = valToIndex.get(val); int leftSize = index - inStart; TreeNode left = build(postorder, postStart, postStart + leftSize - 1, inorder, inStart, index - 1); TreeNode right = build(postorder, postStart + leftSize, postEnd - 1, inorder, index + 1, inEnd); root.left = left; root.right = right; return root; } public TreeNode buildTree(int[] inorder, int[] postorder) { for (int i = 0; i \u0026lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(postorder, 0, postorder.length - 1, inorder, 0, inorder.length - 1); } } References 1. 从后序和中序遍历序列构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-106/","summary":"思路 同LeetCode-105，就是改一下递归的参数 详见：https://blog.zhangmengyang.tk/posts/leetc","title":"LeetCode 106"},{"content":"思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据root在中序遍历的位置得到左右子树节点的个数，再构造左右子树即可\n注意这里可以用map优化通过元素的值找所在数组的索引，用一个valToIndex的hashmap即可\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { if (preStart \u0026gt; preEnd) { return null; } int val = preorder[preStart]; TreeNode root = new TreeNode(val); int index = valToIndex.get(val); int leftSize = index - inStart; TreeNode left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); TreeNode right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); root.left = left; root.right = right; return root; } public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i \u0026lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } } References 1. 从前序和中序遍历序列构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-105/","summary":"思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据ro","title":"LeetCode 105"},{"content":"思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即可\n代码 class Solution { private TreeNode build(int[] nums, int low, int high) { if (low \u0026gt; high) { return null; } int max = nums[low], index = low; for (int i = low + 1; i \u0026lt;= high; i++) { if (nums[i] \u0026gt; max) { max = nums[i]; index = i; } } TreeNode root = new TreeNode(max); TreeNode left = build(nums, low, index - 1); TreeNode right = build(nums, index + 1, high); root.left = left; root.right = right; return root; } public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0 , nums.length - 1); } } References 1. 最大二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-654/","summary":"思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即","title":"LeetCode 654"},{"content":"思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路\n将该问题分解为：左子树展开+右子树展开+将右子树接到左子树上，即可，不过需要注意左右子树为空的情况\n代码 class Solution { private TreeNode tranToLinkedList(TreeNode root) { if (root == null) { return null; } TreeNode left = root.left; TreeNode right = root.right; TreeNode leftLast = tranToLinkedList(left); TreeNode rightLast = tranToLinkedList(right); if (leftLast == null) { root.left = null; root.right = right; } else if (rightLast == null) { root.left = null; root.right = left; } else { root.left = null; root.right = left; leftLast.right = right; } return rightLast != null ? rightLast : (leftLast != null ? leftLast : root); } public void flatten(TreeNode root) { if (root == null) { return; } tranToLinkedList(root); } } References 1. 二叉树展开为链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-114/","summary":"思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路 将该问题分解为：左子树展开+右子树展开","title":"LeetCode 114"},{"content":"思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历\n思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的\n思路二 把间隙看成结点，那么间隙组成的数据结构就是一颗三叉树，遍历这个三叉树即可解决问题，每个间隙结点需要做的事是把这个间隙的两个结点连接起来，在前中后序位置都可以\n代码 思路一 class Solution { public Node connect(Node root) { if (root == null) { return null; } Deque\u0026lt;Node\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { Node cur = queue.poll(); if (cur.left != null) { queue.offer(cur.left); queue.offer(cur.right); } if (i == size - 1) { cur.next = null; } else { cur.next = queue.peek(); } } } return root; } } 思路二 class Solution { private void traverse(Node left, Node right) { if (left == null) { return; } left.next = right; traverse(left.left, left.right); traverse(left.right, right.left); traverse(right.left, right.right); } public Node connect(Node root) { if (root == null) { return null; } traverse(root.left, root.right); return root; } } References 1. 填充每个节点的下一个右侧节点指针 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-116/","summary":"思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历 思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的 思路二 把间隙看成结点，那","title":"LeetCode 116"},{"content":"思路 遍历方式和分解方式都可以\n遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可\n分解思路 利用二叉树的分解问题思想，将原问题分解为左子树的翻转和右子树的分解，然后翻转左右子树\n代码 遍历思路 class Solution { private void traverse(TreeNode root) { if (root == null) { return; } TreeNode temp = root.right; root.right = root.left; root.left = temp; traverse(root.left); traverse(root.right); } public TreeNode invertTree(TreeNode root) { traverse(root); return root; } } 分解思路 class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; } } References 1. 翻转二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-226/","summary":"思路 遍历方式和分解方式都可以 遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可 分解思路 利用二叉树的分解","title":"LeetCode 226"},{"content":"思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，因为只有后序遍历能获得左右子树的信息。\n代码 class Solution { int maxDiameter = 0; private int maxDeep(TreeNode root) { if (root == null) { return 0; } int leftDeep = maxDeep(root.left); int rightDeep = maxDeep(root.right); maxDiameter = Math.max(maxDiameter, leftDeep + rightDeep); return Math.max(leftDeep, rightDeep) + 1; } public int diameterOfBinaryTree(TreeNode root) { maxDeep(root); return maxDiameter; } } References 1. 二叉树的直径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-543/","summary":"思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，","title":"LeetCode 543"},{"content":"思路 有两种思路，分别是分解问题和遍历二叉树\n思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度\n思路二 把二叉树遍历一遍，同时用一个外部变量记录最大的深度，注意需要在前序位置deep++，后序位置deep\u0026ndash;\n代码 思路一 class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } } 思路二 class Solution { int res = 0, deep = 0; private void traverse(TreeNode root) { if (root == null) { return; } deep++; if (root.left == null \u0026amp;\u0026amp; root.right == null) { res = Math.max(res, deep); } traverse(root.left); traverse(root.right); deep--; } public int maxDepth(TreeNode root) { traverse(root); return res; } } References 1. 二叉树的最大深度 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-104/","summary":"思路 有两种思路，分别是分解问题和遍历二叉树 思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度 思路二 把二叉树","title":"LeetCode 104"},{"content":"思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可\n第二题 考察差分数组和异或的性质\n由a^b=c \u0026mdash;\u0026gt; a^a^b=a^c \u0026mdash;\u0026gt; 0^b=a^c \u0026mdash;\u0026gt; b=a^c，因为相同的数异或为0，任何数异或0都不变\n给你的数组相当于是前缀和数组，前缀和数组的差分既是原数组，知道了异或的结果，求异或前的值，用上述推断，然后遍历数组逐个异或即可\n第三题 考察贪心和栈\n哪里贪心了？答：因为题目要求给出字典序最小的字符串，也就是需要尽量把最小的字母放在前面，那么可以比较栈顶和没入栈的那些字母，看下没入栈的那些字母是否有比栈顶小的字母，如果没有，那直接出栈，如果有，那就入栈直到遇到最小的字符串，这样贪心，最后的结果一定是字典序最小的字符串。\n第四题 考察动态规划\n非常典型的动态规划，唯一要注意的就是动态规划数组里的元素不能是所有路径长度的list，因为逐个遍历list的元素会超时，需要使用map，key为路径长度，value为长度为key的路径的个数，还需要注意value有可能很大，需要取余1000000007，key有可能很多，所以需要取余k，因为最终只需要长度能整除k的路径个数，而不需要具体的路径长度。\n总结 本次周赛难度偏低，但是我刷题太少，做起来不熟练，需要多练习多总结。\n代码 第一题 class Solution { public int hardestWorker(int n, int[][] logs) { int[] time = new int[logs.length]; int id = logs[0][0], maxTime = logs[0][1]; time[0] = logs[0][1]; for (int i = 1; i \u0026lt; time.length; i++) { time[i] = logs[i][1] - logs[i - 1][1]; if (time[i] \u0026gt; maxTime || time[i] == maxTime \u0026amp;\u0026amp; id \u0026gt; logs[i][0]) { maxTime = time[i]; id = logs[i][0]; } } return id; } } 第二题 class Solution { public int[] findArray(int[] pref) { for (int i = pref.length - 1; i \u0026gt; 0; i--) { pref[i] = pref[i] ^ pref[i - 1]; } return pref; } } 第三题 class Solution { private boolean hasSmaller(int[] count, int i) { for (int j = 0; j \u0026lt; i; j++) { if (count[j] != 0) { return true; } } return false; } public String robotWithString(String s) { int[] count = new int[26]; for (int i = 0; i \u0026lt; s.length(); i++) { count[s.charAt(i) - \u0026#39;a\u0026#39;]++; } StringBuilder ans = new StringBuilder(); Deque\u0026lt;Character\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push((char) (\u0026#39;z\u0026#39; + 1)); int index = 0; while (ans.length() != s.length()) { Character peek = stack.peek(); if (hasSmaller(count, peek - \u0026#39;a\u0026#39;)) { stack.push(s.charAt(index)); count[s.charAt(index) - \u0026#39;a\u0026#39;]--; index++; } else { ans.append(peek); stack.pop(); } } return ans.toString(); } } 第四题 class Solution { public int numberOfPaths(int[][] grid, int k) { Map\u0026lt;Integer, Integer\u0026gt;[] path = new HashMap[grid[0].length]; path[0] = new HashMap\u0026lt;\u0026gt;(); path[0].put(grid[0][0] % k, 1); for (int i = 1; i \u0026lt; grid[0].length; i++) { path[i] = new HashMap\u0026lt;\u0026gt;(); for (Integer integer : path[i - 1].keySet()) { path[i].put((integer + grid[0][i]) % k, 1); } } for (int i = 1; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++) { HashMap\u0026lt;Integer, Integer\u0026gt; temp = new HashMap\u0026lt;\u0026gt;(path[j]); path[j].clear(); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : temp.entrySet()) { path[j].put((entry.getKey() + grid[i][j]) % k, entry.getValue()); } if (j != 0) { for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : path[j - 1].entrySet()) { int newKey = (entry.getKey() + grid[i][j]) % k; path[j].put(newKey, (path[j].getOrDefault(newKey, 0) + entry.getValue()) % 1000000007); } } } } return path[path.length - 1].getOrDefault(0, 0); } } References 1. 处理用时最长的那个任务的员工 2. 找出前缀异或的原始数组 3. 使用机器人打印字典序最小的字符串 4. 矩阵中和能被 K 整除的路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-314/","summary":"思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可 第二题 考察差分数组和异或的性质 由a^b=c \u0026mdash;\u0026gt; a^a^b=a^c \u0026mdash;\u0026gt; 0^b=a^c \u0026mdash;\u0026gt; b","title":"LeetCode 周赛 314"},{"content":"思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.length个格子里去，那么就可以把这些格子后面的不是黑名单的数字和前面黑名单的数字交换，这样就可以随机获取数字了\n又由于数组大部分元素的值和下标是一样的，所以可以省略数组，用map记录那些交换的元素\n代码 class Solution { int size; Set\u0026lt;Integer\u0026gt; blackSet = new HashSet\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; blackMap = new HashMap\u0026lt;\u0026gt;(); public Solution(int n, int[] blacklist) { size = n - blacklist.length; for (int num : blacklist) { if (num \u0026gt;= size) { blackSet.add(num); } } int last = n - 1; for (int num : blacklist) { if (num \u0026lt; size) { while (blackSet.contains(last)) { last--; } blackMap.put(num, last); last--; } } } public int pick() { int random = new Random().nextInt(size); if (blackMap.containsKey(random)) { return blackMap.get(random); } return random; } } References 1. 黑名单中的随机数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-710/","summary":"思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.le","title":"LeetCode 710"},{"content":"思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组\n代码 class RandomizedSet { private List\u0026lt;Integer\u0026gt; nums; private Map\u0026lt;Integer, Integer\u0026gt; valToIndex; public RandomizedSet() { nums = new ArrayList\u0026lt;\u0026gt;(); valToIndex = new HashMap\u0026lt;\u0026gt;(); } public boolean insert(int val) { if (valToIndex.containsKey(val)) { return false; } valToIndex.put(val, nums.size()); nums.add(val); return true; } public boolean remove(int val) { if (!valToIndex.containsKey(val)) { return false; } int index = valToIndex.get(val); int lastNum = nums.get(nums.size() - 1); valToIndex.put(lastNum, index); valToIndex.remove(val); nums.set(index, lastNum); nums.remove(nums.size() - 1); return true; } public int getRandom() { return nums.get(new Random().nextInt(nums.size())); } } References 1. O(1) 时间插入、删除和获取随机元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-380/","summary":"思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索","title":"LeetCode 380"},{"content":"思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍\n有两个需要注意的地方：\n”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了 寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见LeetCode-note的思想章节二分查找注意点第10条 代码 class Solution { int[] preSum; public Solution(int[] w) { preSum = new int[w.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + w[i - 1]; } } public int pickIndex() { int random = new Random().nextInt(preSum[preSum.length - 1]) + 1; // 二分法寻找random所在的索引 int left = 0, right = preSum.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (random \u0026lt;= preSum[mid]) { right = mid; } else { left = mid + 1; } } return left - 1; } } References 1. 按权重随机选择 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-528/","summary":"思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值","title":"LeetCode 528"},{"content":"思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/\n代码 class Solution { public int[][] generateMatrix(int n) { int upperBound = 0, lowerBound = n - 1; int leftBound = 0, rightBound = n - 1; int[][] matrix = new int[n][n]; int num = 1; while (num \u0026lt;= n * n){ if (upperBound \u0026lt;= lowerBound) { for (int i = leftBound; i \u0026lt;= rightBound; i++) { matrix[upperBound][i] = num; num++; } upperBound++; } if (leftBound \u0026lt;= rightBound) { for (int i = upperBound; i \u0026lt;= lowerBound; i++) { matrix[i][rightBound] = num; num++; } rightBound--; } if (upperBound \u0026lt;= lowerBound) { for (int i = rightBound; i \u0026gt;= leftBound; i--) { matrix[lowerBound][i] = num; num++; } lowerBound--; } if (leftBound \u0026lt;= rightBound) { for (int i = lowerBound; i \u0026gt;= upperBound; i--) { matrix[i][leftBound] = num; num++; } leftBound++; } } return matrix; } } References 1. 螺旋矩阵 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-59/","summary":"思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leet","title":"LeetCode 59"},{"content":"思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：\n需要注意水平遍历需要判断upperBound\u0026lt;=lowerBound，垂直遍历需要判断leftBound\u0026lt;=rightBound\n代码 class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { int row = matrix.length, col = matrix[0].length; int upperBound = 0, lowerBound = row - 1; int leftBound = 0, rightBound = col - 1; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (ans.size() \u0026lt; row * col) { if (upperBound \u0026lt;= lowerBound) { for (int i = leftBound; i \u0026lt;= rightBound; i++) { ans.add(matrix[upperBound][i]); } upperBound++; } if (leftBound \u0026lt;= rightBound) { for (int i = upperBound; i \u0026lt;= lowerBound; i++) { ans.add(matrix[i][rightBound]); } rightBound--; } if (upperBound \u0026lt;= lowerBound) { for (int i = rightBound; i \u0026gt;= leftBound; i--) { ans.add(matrix[lowerBound][i]); } lowerBound--; } if (leftBound \u0026lt;= rightBound) { for (int i = lowerBound; i \u0026gt;= upperBound; i--) { ans.add(matrix[i][leftBound]); } leftBound++; } } return ans; } } References 1. 螺旋矩阵 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-54/","summary":"思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界： 需要注意水平遍历需要判断upperBound\u0026lt","title":"LeetCode 54"},{"content":"思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可\n为什么这样做？因为旋转90°相当于把行变成列，而对折矩阵刚好可以把行变成列，但是位置不对，那再反转一下就行了\n代码 class Solution { public void rotate(int[][] matrix) { for (int i = 0; i \u0026lt; matrix.length; i++) { // 注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，相当于对折了两次，所以这里要写j = i + 1 for (int j = i + 1; j \u0026lt; matrix[0].length; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } for (int i = 0; i \u0026lt; matrix.length; i++) { reverse(matrix[i]); } } private void reverse(int[] s) { int left = 0, right = s.length - 1; while (left \u0026lt; right) { int temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 旋转图像 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-48/","summary":"思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的","title":"LeetCode 48"},{"content":"思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再reverse各个单词，但要注意一下细节，比如去空格什么的\n代码 class Solution { private void reverse(char[] s, int i, int j) { int left = i, right = j - 1; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } private void translate(char[] s, int i, int j, int step) { for (int k = i; k \u0026lt; j; k++) { s[k - step] = s[k]; } for (int k = j - step; k \u0026lt; j; k++) { s[k] = \u0026#39; \u0026#39;; } } public String reverseWords(String s) { char[] cs = s.toCharArray(); reverse(cs, 0, cs.length); int left = -1, step = 0; for (int i = 0; i \u0026lt; cs.length; i++) { if (cs[i] == \u0026#39; \u0026#39;) { if (left != -1) { reverse(cs, left, i); translate(cs, left, i, step); left = -1; } else { step++; } } else { if (left == -1) { left = i; } } } if (left != -1) { reverse(cs, left, cs.length); translate(cs, left, cs.length, step); } return new String(cs).trim(); } } References 1. 反转字符串中的单词 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-151/","summary":"思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再revers","title":"LeetCode 151"},{"content":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算\n代码 class Solution { public boolean carPooling(int[][] trips, int capacity) { int len = 0; for (int[] trip : trips) { len = len \u0026gt; trip[2] ? len : trip[2]; } int[] nums = new int[len]; Difference df = new Difference(nums); for (int[] trip : trips) { df.increment(trip[1], trip[2] - 1, trip[0]); } for (int num : df.result()) { if (num \u0026gt; capacity) { return false; } } return true; } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 拼车 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1094/","summary":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算 代码 class Solution { public boolean carPooling(int[][] trips, int","title":"LeetCode 1094"},{"content":"思路 标准差分数组，详见LeetCode-note\n代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 航班预订统计 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1109/","summary":"思路 标准差分数组，详见LeetCode-note 代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff;","title":"LeetCode 1109"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n代码 class NumMatrix { int[][] preSum; public NumMatrix(int[][] matrix) { preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { for (int j = 1; j \u0026lt; preSum[0].length; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } public int sumRegion(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } References 1. 二维区域和检索 - 矩阵不可变 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-304/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位 还需要","title":"LeetCode 304"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位\n代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } References 1. 区域和检索 - 数组不可变 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-303/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位 代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum =","title":"LeetCode 303"},{"content":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找出窗口最大时的长度就可以了\n代码 class Solution { public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, ans = 0; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) \u0026gt; 1) { char d = s.charAt(left); left++; window.put(d, window.get(d) - 1); } ans = Integer.max(ans, right - left); } return ans; } } References 1. 无重复字符的最长子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-3/","summary":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找","title":"LeetCode 3"},{"content":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/\n代码 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; p.length(); i++) { char c = p.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == p.length()) { ans.add(left); char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } } return ans; } } 另一种思路 vector\u0026lt;int\u0026gt; findAnagrams(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; vector\u0026lt;int\u0026gt; res; // 记录结果 while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 当窗口符合条件时，把起始索引加入 res if (valid == need.size()) res.push_back(left); char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } return res; } References 1. 找到字符串中所有字母异位词 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-438/","summary":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengya","title":"LeetCode 438"},{"content":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法的字符，当窗口的长度和s1的长度一样时，就找到了这个子串\nlabuladong的思路：利用滑动窗口的思想，始终保持窗口大小为s1.size()-1，每次移入窗口一个元素，检查一下是否找到子串，如果没有，再让一个元素移出窗口，直到找到这个子串\n代码 class Solution { public boolean checkInclusion(String s1, String s2) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s1.length(); i++) { char c = s1.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; while (right \u0026lt; s2.length()) { char c = s2.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s2.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == s1.length()) { return true; } } return false; } } 另一种思路 // 判断 s 中是否存在 t 的排列 bool checkInclusion(string t, string s) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 在这里判断是否找到了合法的子串 if (valid == need.size()) return true; char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } // 未找到符合条件的子串 return false; } References 1. 字符串的排列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-567/","summary":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法","title":"LeetCode 567"},{"content":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节\n代码 class Solution { public String minWindow(String s, String t) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; t.length(); i++) { char c = t.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, valid = 0, begin = 0, end = Integer.MAX_VALUE; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素 // 所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (need.containsKey(c)) { window.put(c, window.getOrDefault(c, 0) + 1); if (window.get(c).equals(need.get(c))) { valid++; } } while (valid == need.size()) { if (end - begin \u0026gt; right - left) { begin = left; end = right; } c = s.charAt(left); left++; if (need.containsKey(c)) { if (window.get(c).equals(need.get(c))) { valid--; } window.put(c, window.get(c) - 1); } } } return end == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(begin, end); } } References 1. 最小覆盖子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-76/","summary":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节 代码 class Solution {","title":"LeetCode 76"},{"content":"思路 第一题 排序，不解释\n第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了\n第三题 暴力会超时，利用动态规划的思想，从左往右遍历一遍找各元素左边递减的元素个数，从右往左遍历一遍找各元素右边递增的元素个数，然后和k比较就可以了\n代码 第一题 class Solution { public String[] sortPeople(String[] names, int[] heights) { People[] peoples = new People[names.length]; for(int i = 0; i \u0026lt; peoples.length; i++) { peoples[i] = new People(names[i], heights[i]); } Arrays.sort(peoples, (a, b) -\u0026gt; b.height - a.height); for (int i = 0; i \u0026lt; peoples.length; i++) { names[i] = peoples[i].name; } return names; } static class People { String name; int height; public People(String name, int height) { this.name = name; this.height = height; } } } 第二题 class Solution { public int longestSubarray(int[] nums) { int max = Integer.MIN_VALUE, ans = 0, count = 0; for (int num : nums) { if (num != max) { count = 0; if (num \u0026gt; max) { max = num; ans = 0; } } if (num == max) { count++; } if (count \u0026gt; ans) { ans = count; } } return ans; } } 第三题 动态规划：\nclass Solution { public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { int[] decre = new int[nums.length]; decre[0] = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026lt;= nums[i - 1]) { decre[i] = decre[i - 1] + 1; } else { decre[i] = 1; } } int[] incre = new int[nums.length]; incre[nums.length - 1] = 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { if (nums[i] \u0026lt;= nums[i + 1]) { incre[i] = incre[i + 1] + 1; } else { incre[i] = 1; } } ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (decre[i - 1] \u0026gt;= k \u0026amp;\u0026amp; incre[i+1] \u0026gt;= k) { ans.add(i); } } return ans; } } 暴力解法：\nclass Solution { private boolean isGoodIndex(int[] nums, int index, int k) { for (int i = index - 1; i \u0026gt; index - k; i--) { if (nums[i] \u0026gt; nums[i - 1]) { return false; } } for (int i = index + 1; i \u0026lt; index + k; i++) { if (nums[i] \u0026gt; nums[i + 1]) { return false; } } return true; } public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (isGoodIndex(nums, i, k)) { ans.add(i); } } return ans; } } References 1. 按身高排序 2. 按位与最大的最长子数组 3. 找到所有好下标 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-312/","summary":"思路 第一题 排序，不解释 第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了 第三题 暴力会超时，利用","title":"LeetCode 周赛-312"},{"content":"思路 经典进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，分别查找左边界或右边界即可，详见LeetCode-note-1\n代码 class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } return new int[]{searchLeft(nums, target), searchRight(nums, target)}; } private int searchLeft(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026lt;= nums[mid]) { right = mid; } else { left = mid + 1; } } return nums[left] == target ? left : -1; } private int searchRight(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if (target \u0026gt;= nums[mid]) { left = mid; } else { right = mid - 1; } } return nums[left] == target ? left : -1; } } References 1. 在排序数组中查找元素的第一个和最后一个位置 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-34/","summary":"思路 经典进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查","title":"LeetCode 34"},{"content":"思路 经典二分查找，不解释\n详见：https://labuladong.gitee.io/algo/2/20/29/\n代码 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } } References 1. 二分查找 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-704/","summary":"思路 经典二分查找，不解释 详见：https://labuladong.gitee.io/algo/2/20/29/ 代码 class Solution { public int search(int[] nums, int target) { int left","title":"LeetCode 704"},{"content":"思路 两种思路：\n中心扩展法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n动态规划 构建dp数组，数组的元素为[i\u0026hellip;j]是否为回文串，状态转移方程为：\nif (s.charAt(i) == s.charAt(j) \u0026amp;\u0026amp; (j - i \u0026lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; } 同时统计最长回文串即可，base case为j = i + 1和 j = i的情况，可以优化空间复杂度\n马拉车算法 感觉没什么用，没看，就是一个O(n)时间复杂度求最长回文串的一个算法\n代码 中心扩展法 class Solution { public String longestPalindrome(String s) { String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { // 从中心向两边寻找回文串 String s1 = findPalindrome(s, i, i); String s2 = findPalindrome(s, i, i + 1); res = res.length() \u0026gt;= s1.length() ? res : s1; res = res.length() \u0026gt;= s2.length() ? res : s2; } return res; } private String findPalindrome(String s, int left, int right) { while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(left) == s.charAt(right)) { left--; right++; } return s.substring(left + 1, right); } } 动态规划 class Solution { public String longestPalindrome(String s) { int n = s.length(), maxLen = 0, maxLeft = 0, maxRight = 0; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = i; j \u0026lt; n; j++) { if (s.charAt(i) == s.charAt(j) \u0026amp;\u0026amp; (j - i \u0026lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; if (j - i + 1 \u0026gt; maxLen) { maxLeft = i; maxRight = j; maxLen = j - i + 1; } } } } return s.substring(maxLeft, maxRight + 1); } } References 1. 最长回文子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-5/","summary":"思路 两种思路： 中心扩展法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。 动态规划 构建dp数组，数组的元素为[i\u0026hellip;","title":"LeetCode 5"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 反转字符串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-344/","summary":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值 代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1.","title":"LeetCode 344"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n代码 class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; while (left \u0026lt; right) { int sum = numbers[left] + numbers[right]; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { return new int[]{left + 1, right + 1}; } } return new int[]{0, 0}; } } References 1. 两数之和 II - 输入有序数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-167/","summary":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。 代","title":"LeetCode 167"},{"content":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题）\n26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n83 同26，只不过是链表，要注意去重后要把slow后面的链表断开，否则slow后面可能会有和slow重复的。\n27 同26，只不过不是比较slow和fast的元素，而是让fast和确定的值比较。\n283 同27，只不过得把slow后面的改成0。\n代码 26 class Solution { public int removeDuplicates(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow + 1; } } 83 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { slow.next = fast; slow = slow.next; } fast = fast.next; } slow.next = null; return head; } } 27 class Solution { public int removeElement(int[] nums, int val) { if (nums.length == 0) { return 0; } int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } 283 class Solution { public void moveZeroes(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != 0) { nums[slow] = nums[fast]; slow++; } fast++; } while (slow \u0026lt; nums.length) { nums[slow] = 0; slow++; } } } References 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-26+83+27+283/","summary":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题） 26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的","title":"LeetCode 26+83+27+283"},{"content":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找中点 ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } // 如果是奇数个节点，slow需要后移一位 if (fast != null) { slow = slow.next; } // 反转slow之后的 ListNode right = reverse(slow), left = head; // 判断回文 while (right != null) { if (left.val != right.val) { return false; } left = left.next; right = right.next; } return true; } private ListNode reverse(ListNode head) { ListNode pre = null, cur = head; while (cur != null) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88+%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。 代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找","title":"LeetCode 234 快慢指针+反转链表"},{"content":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private boolean traverse(ListNode right) { if (right == null) { return true; } boolean res = traverse(right.next); res = res \u0026amp;\u0026amp; (left.val == right.val); left = left.next; return res; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E9%93%BE%E8%A1%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。 代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private","title":"LeetCode 234 链表后序遍历"},{"content":"思路 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n代码 class Solution { private ListNode reverse(ListNode a, ListNode b) { // 这个做法需要对第一个节点特殊判断 // if (head == null) { // return null; // } // // ListNode pre = head, cur = head.next; // head.next = null; // while (cur != null) { // ListNode temp = cur.next; // cur.next = pre; // cur = temp; // } // // return pre; // 这个做法不需要对第一个节点特殊判断 ListNode pre = null, cur = a; while (cur != b) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } public ListNode reverseKGroup(ListNode head, int k) { ListNode p = head; // 找出前k个节点，不满k个直接return for (int i = 0; i \u0026lt; k; i++) { if (p == null) { return head; } p = p.next; } // 反转前k个 ListNode newHead = reverse(head, p); // 拼接后面反转后的链表 head.next = reverseKGroup(p, k); return newHead; } } References 1. K 个一组翻转链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-25/","summary":"思路 1、先反转以 head 开头的 k 个元素。 2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。 3、将上述两个过程的结果连接起来。 注意base case为最后元素","title":"LeetCode 25"},{"content":"思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n代码 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } public ListNode reverseBetween(ListNode head, int left, int right) { if (left == 1) { return reverseN(head, right); } head.next = reverseBetween(head.next, left - 1, right - 1); return head; } } References 1. 反转链表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-92/","summary":"思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right","title":"LeetCode 92"},{"content":"思路 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n代码 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } } ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA%E8%8A%82%E7%82%B9/","summary":"思路 解决思路和反转整个链表差不多，只要稍加修改即可： 1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。 2、刚才我们直接","title":"反转链表前n个节点"},{"content":"思路 利用递归的思想，先反转head后面的，然后把head也反转即可。\n代码 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } } References 1. 反转链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-206/","summary":"思路 利用递归的思想，先反转head后面的，然后把head也反转即可。 代码 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next =","title":"LeetCode 206"},{"content":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n分析过程 难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：\n如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n转载于： https://labuladong.gitee.io/algo/2/19/18/\n代码 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headB; while (p1 != p2) { if (p1 == null) { p1 = headB; } else { p1 = p1.next; } if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } } References 1. 相交链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-160/","summary":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等","title":"LeetCode 160"},{"content":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n分析过程 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：\nfast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。\n假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。\n巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：\n所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。\n转载于：https://labuladong.gitee.io/algo/2/19/18/\n代码 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; // 寻找相遇点 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (slow == fast) { break; } } if (fast == null || fast.next == null) { return null; } // 再次相遇即为环起始点 fast = head; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } References 1. 环形链表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-142/","summary":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次","title":"LeetCode 142"},{"content":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表有环 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } } References 1. 环形链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-141/","summary":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环 代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表","title":"LeetCode 141"},{"content":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n代码 class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; // 经典快慢指针 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } } References 1. 链表的中间结点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-876/","summary":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 需要注意的是，如果链表","title":"LeetCode 876"},{"content":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n代码 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让p1指针走n步 for (int i = 0; i \u0026lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // p1指针走到头，p2指针指向的就是需要找的节点 while (p1 != null) { p1 = p1.next; p2 = p2.next; } return p2; } public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; // 找到倒数第n+1个节点 ListNode node = findFromEnd(dummy, n + 1); node.next = node.next.next; return dummy.next; } } References 1. 删除链表的倒数第 N 个结点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-19/","summary":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指","title":"LeetCode 19"},{"content":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n代码 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.val; }); for (ListNode head : lists) { if (head != null) { pq.add(head); } } // 每次取出来一个最小的 while (!pq.isEmpty()) { ListNode node = pq.poll(); p.next = node; p = p.next; if (node.next != null) { pq.add(node.next); } } return dummy.next; } } References 1.合并K个升序链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-23/","summary":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。 代码 class Solution { public ListNode mergeKLists(ListNode[] lists) {","title":"LeetCode 23"},{"content":"链表 合并两个有序链表 解法 略\n题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-21/\n单链表的分解 解法 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n题目 1. 分隔链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-86/\n合并 k 个有序链表 解法 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n题目 1. 合并K个升序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-23/\n寻找单链表的倒数第 k 个节点 解法 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n题目 1. 删除链表的倒数第 N 个结点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-19/\n单链表的中点 解法 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n题目 1. 链表的中间结点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-876/\n判断链表是否包含环 解法 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n题目 1. 环形链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-141/\n存在环的链表中寻找环起点 解法 利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n题目 1. 环形链表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-142/\n2. 寻找重复数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-287/\n判断两个链表是否相交 解法 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n题目 1. 相交链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-160/\n反转单链表 解法 利用递归的思想，先反转head后面的，然后把head也反转即可。\n思想 反转的过程就是改变指针方向的过程并且最后一个指向null，比如反转第2个\u0026mdash;第5个：\n1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null\n反转后为：\n1 -\u0026gt; 2 \u0026lt;- 3 \u0026lt;- 4 \u0026lt;- 5\n​ null\n题目 1. 反转链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-206/\n反转链表前n个节点 解法 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n题目 无\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/反转链表前n个节点/\n反转链表节点(m, n) 解法 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n题目 1. 反转链表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-92/\nK 个一组翻转链表 解法 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n题目 1. K 个一组翻转链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-25/\n链表的前后序遍历 void traverse(ListNode head) { // 前序遍历代码 traverse(head.next); // 后序遍历代码 } 回文串 寻找回文串 核心思想是从中心向两端扩展\n判断回文串 核心思想是从两端向中间逼近\n判断回文链表 解法 可以将链表全部反转，也可以部分反转\n链表全部反转 链表全部反转的方法共3种：\n将原链表反转，然后与原链表比较 略\n链表后序遍历 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-链表后序遍历/\n利用栈 同链表后序遍历\n链表部分反转 快慢指针+反转链表 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-快慢指针+反转链表/\n题目 1. 回文链表 数组 快慢指针在数组中的应用 数组元素去重 解法 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n具体变种详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-26+83+27+283/\n题目 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 滑动窗口 解法 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n详见思想章节\n题目 1. 最小覆盖子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-76/\n2. 字符串的排列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/\n3. 找到字符串中所有字母异位词 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-438/\n4. 无重复字符的最长子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-3/\n5. 每种字符至少取 K 个 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-6270/\n6. 统计好子数组的数目 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-周赛-328/\n左右指针在数组中的应用 解法 见题解\n题目 1. 颜色分类 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-75/\n二分查找 解法 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度，详见思想章节\n题目 1. 在排序数组中查找元素的第一个和最后一个位置 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-34/\n2. 二分查找 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-704/\n3. 搜索二维矩阵 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-240/\n4. 寻找两个正序数组的中位数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-4/\n5. 搜索旋转排序数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-33/\n6. 正整数和负整数的最大计数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-周赛-327/\n7. 最大化城市的最小供电站数目 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-双周赛-95/\n8. 每个小孩最多能分到多少糖果 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-2226/\n两数之和 解法 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n题目 1. 两数之和 II - 输入有序数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-167/\n三数之和 解法 先排序，然后确定一个数，剩下两个数用双指针确定，同两数之和，详见题解\n题目 1. 三数之和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-15/\n反转数组 解法 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n扩展 反转字符数组里的单词 先反转整个数组，然后再反转各个单词即可\n旋转矩阵 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可\n题目 1. 反转字符串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-344/\n2. 反转字符串中的单词 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-151/\n3. 旋转图像 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-48/\n回文串判断 解法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n题目 1. 最长回文子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-5/\n前缀和 一维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的时nums前n个元素的和，整体往后挪一位\n题目 1. 区域和检索 - 数组不可变 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-303/\n2. 和为 K 的子数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-560/\n3. 除自身以外数组的乘积 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-238/\n二维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n题目 1. 二维区域和检索 - 矩阵不可变 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/\n二叉树中的前缀和 解法 我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上所有节点的前缀和，并且将该前缀和加入数据结构中，并且遍历完当前结点记得将前缀和从数据结构中去除，以免影响其他结点的前缀和\n题目 1. 路径总和 III 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-437/\n差分数组 一维差分数组 解法 详见思想章节\n题目 1. 航班预订统计 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1109/\n2. 拼车 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1094/\n二维差分数组 解法 详见题解\n题目 1. 子矩阵元素加 1 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-周赛-328/\n矩阵的螺旋遍历 解法 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：\n需要注意水平遍历需要判断upperBound\u0026lt;=lowerBound，垂直遍历需要判断leftBound\u0026lt;=rightBound\n题目 1. 螺旋矩阵 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/\n2. 螺旋矩阵 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-59/\n带权重的随机选择算法 解法 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍\n有两个需要注意的地方：\n”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了 寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见思想章节二分查找注意点第10条 题目 1. 按权重随机选择 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-528/\n常数时间删除/查找数组中的任意元素 解法 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组\n核心思想就是为了随机选取元素，肯定得用数组存，并且得是紧凑的\n题目 1. O(1) 时间插入、删除和获取随机元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-380/\n2. 黑名单中的随机数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-710/\n原地哈希 解法 将元素和索引一一对应，不对应的交换元素使其对应\n题目 1. 找到所有数组中消失的数字 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-448/\n2. 寻找重复数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-287/\n3. 缺失的第一个正数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-41/\n二叉树 遍历问题 解法 利用前中后序遍历模板（见思想），用一个 traverse 函数配合外部变量来实现。\n搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n题目 1. 二叉树的最大深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/\n2. 二叉树的前序遍历 题解略\n3. 翻转二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/\n4. 填充每个节点的下一个右侧节点指针 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/\n5. 二叉树的中序遍历 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-94/\n分解问题 解法 主要思想就是定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案\n首先写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)。\n搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n题目 1. 二叉树的最大深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/\n2. 二叉树的直径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-543/\n3. 翻转二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/\n4. 二叉树展开为链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-114/\n层序遍历 解法 就是一个BFS，可以计算一些类似结点与root之间的距离的问题。详见思想里的模板\n题目 1. 填充每个节点的下一个右侧节点指针 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/\n构造二叉树 解法 二叉树的构造问题一般都是使用「分解问题」的思想：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。\n题目 1. 最大二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-654/\n2. 从前序和中序遍历序列构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n3. 从后序和中序遍历序列构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-106/\n4. 根据前序和后序遍历构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-889/\n二叉搜索树性质 解法 只需要利用二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列就可以了\n题目 1. 二叉搜索树中第 K 小的元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-230/\n2. 把二叉搜索树转换为累加树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-538/\n二叉搜索树合法性 解法 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去\n题目 1. 验证二叉搜索树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-98/\n二叉搜索树增删改查 解法 见思想\n题目 1. 二叉搜索树中的搜索 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-700/\n2. 二叉搜索树中的插入操作 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-701/\n3. 删除二叉搜索树中的节点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-504/\nn个结点的BST的种类 解法 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类\n动态规划 递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划\n题目 1. 不同的二叉搜索树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-96/\n2. 不同的二叉搜索树 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-95/\n扁平化嵌套列表迭代器 解法 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码\n思路二 思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代\n题目 1. 扁平化嵌套列表迭代器 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-341/\n最近公共祖先 解法 主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA\n题目 1. 二叉树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/\n2. 二叉搜索树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/\n最近公共祖先 解法 主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA\n题目 1. 二叉树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/\n2. 二叉搜索树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/\n完全二叉树的结点个数 解法 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树\n这种做法时间复杂度是O(logn*logn)，详见：https://labuladong.gitee.io/algo/2/21/48/\n题目 1. 完全二叉树的节点个数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-222/\n合并二叉树 解法 详见题解\n题目 1. 合并二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-617/\n图 图的遍历 解法 直接套模板，详见思想章节\n题目 1. 所有可能的路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-797/\n环检测 解法 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回\n思路二 利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列，出队相当于访问该节点，环里的结点不会入队列，最后判断访问过的结点个数是否等于总结点个数即可\n题目 1. 课程表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-207/\n拓扑排序 解法 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序\n思路二 利用图的BFS，只不过只把入度为零的结点加入队列，出队相当于访问该节点，队列出队的序列就是该图的拓扑排序\n题目 1. 课程表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-210/\n二分图的判断 解法 利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节\n题目 1. 判断二分图 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-785/\n2. 可能的二分法 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-886/\n并查集 解法 利用并查集模板即可，详见思想章节\n题目 1. 被围绕的区域 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-130/\n2. 等式方程的可满足性 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-990/\n3. 寻找图中是否存在路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1971/\n4. 除法求值 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-399/\ndijkstra问题 解法 利用dijkstra模板即可，注意dijkstra的变种需要修改adj和weight函数，详见思想章节\n题目 1. 网络延迟时间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-743/\n2. 最小体力消耗路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1631/\n3. 概率最大的路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1514/\nkruskal问题 解法 利用kruskal算法即可，详见思想章节\n题目 1. 连接所有点的最小费用 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/\nprim问题 解法 利用prim算法即可，详见思想章节\n题目 1. 连接所有点的最小费用 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/\n设计数据结构 LRU 解法 直接套LRU模板即可，详见思想篇章\n题目 1. LRU 缓存 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-146/\nLFU 解法 直接套LFU模板即可，详见思想篇章\n题目 1. LFU 缓存 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-460/\nTrieMap和TrieSet 解法 直接套模板即可，详见思想篇章\n题目 1. 实现 Trie (前缀树) 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-208/\n2. 单词替换 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-648/\n3. 添加与搜索单词 - 数据结构设计 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-211/\n4. 键值映射 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-677/\n数据流的中位数 解法 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg\n题目 1. 数据流的中位数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-295/\n单调栈问题 下一个更大元素 解法 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充当下一个更大元素的角色（中间去除的元素是无法充当这种角色的），那么此时栈顶就是当前元素下一个更大元素\n题目 1. 下一个更大元素 I 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-496/\n2. 每日温度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-739/\n3. 下一个更大元素 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-503/\n4. 接雨水 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-42/\n单调队列问题 滑动窗口最大值 解法 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色），详见思想篇章\n题目 1. 滑动窗口最大值 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-239/\n用栈实现队列 解法 直接套栈实现队列模板即可，详见思想篇章\n题目 1. 用栈实现队列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-232/\n用队列实现栈 解法 直接套用队列实现栈的模板即可，详见思想篇章\n题目 1. 用队列实现栈 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-225/\n最小栈 解法 这道题的关键是getMin的实现，可以用一个辅助栈来存储每个元素入栈时的最小值，这样的话当元素出栈时也可以很容易的获取最小值\n题目 1. 最小栈 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-155/\n排序 快速选择 解法 详见题解\n题目 1. 数组中的第K个最大元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-215/\n2. 前 K 个高频元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-347/\n思想 双指针 就是两个指针，分为左右指针和快慢指针，只要数组有序，就应该想到双指针技巧\n左右指针 两个指针一个左一个右\n使用时一定要确定什么时候动左指针，什么时候动右指针，对于已排序的数组一般是相加的和，小了动左指针，大了动右指针\n二分查找 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度\n经典思路 public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } 这种就是一边缩减搜索空间，一边寻找要找的元素。\n但是有时候问题并不是这么简单，比如寻找一个可能在数组里不存在，或者是找边界这样的问题，这时使用进阶思路 ，在循环体内排除一定不存在目标元素的区间会更简单一些。\n经典思路是寻找元素\n进阶思路是排除n-1个不可能的元素\n进阶思路 class Solution { public int search(int[] nums, int target) { // 此思路搜索空间为[left, right]，闭闭空间 int left = 0, right = nums.length - 1; // 循环条件写成left\u0026lt;right，因为循环体内把数组分成两部分，那么一定会达到left和right重合的状态 // 所以循环条件写成left\u0026lt;right，可以保证退出循环时left等于right while (left \u0026lt; right) { // 求中点，left=mid+1时不需要向上取整 int mid = left + (right - left) / 2; // left=mid时需要向上取整，记忆方式：left和mid要有一个+1 // 这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left //int mid = left + (right - left + 1) / 2; // 下面是核心逻辑，分成两个区间是因为这样扩展性更强 // 这块主要就是筛选不可能的区间，然后缩减搜索空间，具体问题具体分析，注意left没加一时mid要加一 // 左边界，记忆方式：左边界是小于等于，下面的语句是...=mid，第二个语句和第一个语句互补，left没加一时mid要加一 /*if (target \u0026lt;= nums[mid]) { right = mid; } else { left = mid + 1; }*/ // 右边界 /*if (target \u0026gt;= nums[mid]) { left = mid; } else { right = mid -1; }*/ } // 此时left一定等于right，所以返回left或者right都一样 // 排除了n-1个不可能的元素，还剩下[left, right]区间的元素，而left=right，就看剩下这个是不是要寻找的元素了 // 如果该题一定存在指定的元素，那么下一步可以省略，直接return left就好了 /* 如果查找与target相等的值 */ if (nums[left] == target) { return -1; } /* 如果查找target的左侧边界 */ if (nums[left] \u0026lt; target) { return -1; } /* 如果查找target的右侧边界 */ if (nums[left] \u0026gt; target) { return -1; } return left; } } 步骤 left和right分别设置为搜索空间的左右端点，注意是闭区间 循环条件写成left\u0026lt;right 求中点，先写成int mid = left + (right - left) / 2; 根据具体问题将搜索空间分成两部分，其中一部分必须是不可能的区域，然后根据这个不可能区域的特征写出第一个if，然后else里写和if互补的区域就好了，注意如果结果是left=mid，上面求中点要改成int mid = left + (right - left + 1) / 2; 如果根据题意不能判断出一定存在寻找的元素，需要判断下nums[left]是不是寻找的元素，是则return left，否则未找到该元素；如果根据题意能判断出一定存在寻找的元素，那直接return left就好了 注意点 可以把这里的nums[i] = x看成一个函数，只要是具有单调性的函数都可以使用二分查找，比如y = func(x)，给定一个y让你找对应的x也可以用二分查找，二分查找的使用很广泛，只要函数有单调性即可 此思路搜索空间为[left, right]，闭闭空间 循环条件写成left\u0026lt;right，因为循环体内把数组分成两部分，并且根据left的取值选择mid是向上或向下取整，那么一定会达到left和right重合的状态（把所有情况都模拟一边就可以得出这个结论），所以循环条件写成left\u0026lt;right，可以保证退出循环时left等于right 求中点时，如果使用(left + right) / 2有可能相加溢出，为了防止溢出使用left + (right - left) / 2 求中点时，left=mid+1时不需要向下取整，left=mid时需要向上取整，记忆方式：left和mid要有一个+1。这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left。right=mid时需要向下取整，原因同理 把搜索空间分成两个区间是因为这样扩展性更强 缩减搜索空间时，将搜索空间分成两部分需要注意分出不可能的区间，然后缩减搜索空间，具体问题具体分析，根据这个不可能区间的特征写出第一个if，然后else里写和if互补的区域 注意left没加一时mid要加一 退出循环后left和right相等，并且是唯一有希望的元素（只是有希望，有可能不是它，还要再判断一下，如果该题一定存在指定的元素，那么直接return left就好了） 对于寻找左右侧边界的二分查找，在缩减搜索空间时一定要考虑\u0026gt;=或\u0026lt;=的情况，因为这样才能使用找左或右侧这个性质，比如target \u0026lt;= nums[mid]，可以寻找左边界，因为这时左边界不可能在mid右边所以直接right=mid就可以找到左边界，右边界同理。为什么找到的是左边界，也可以这么理解：target \u0026lt;= nums[mid]-\u0026gt;right=mid，所以target \u0026gt; nums[mid]-\u0026gt;left=mid + 1，此时left左边全部都小于target，因为退出循环时如果能找到target，left指向的就是target，又因为left左边全部都小于target，所以此时left指向左边界。找右边界同理。 对于寻找左侧边界的二分查找，说是寻找该元素的左侧边界，实际上是寻找大于等于target的所有元素的左侧边界，同理，寻找右侧边界的二分查找实际上是寻找小于等于target的所有元素的右侧边界，也可以理解成左侧边界的左边都小于target，右侧边界的右边都大于target，并且左右边界不一定等于target，所以如果target不存在时，左边界是比target大的第一个元素，右边界是比target小的第一个元素 详见：leetcode笔记word版和https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/\n其他 见上面各知识点章节\n快慢指针 两个指针一个快一个慢\n滑动窗口 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n模板 /* 滑动窗口算法模板 */ void slidingWindow(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素，所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { // 获取移入窗口的元素，并扩大窗口 char c = s.charAt(right); right++; // 进行扩大窗口时数据的一系列更新 ... // debug位置 // System.out.println(\u0026#34;left:\u0026#34; + left + \u0026#34;\\t\u0026#34; + \u0026#34;right:\u0026#34; + right); // 判断左侧窗口是否要收缩 while (window needs shrink) { // 获取移出窗口的元素，并收缩窗口 char d = s.charAt(left); left++; // 进行收缩窗口时数据的一系列更新，一般与上面扩大窗口时数据更新相反 ... } } } 步骤 设置存储窗口内元素的数据结构，并且设置循环while (right \u0026lt; s.length()) 扩大窗口，并更新相关的数据 判断是否需要收缩窗口，如需要，则收缩窗口，并更新相关的数据 退出循环后，返回相应的数据 注意点 此模板采用闭开区间，循环条件用\u0026lt;而不用\u0026lt;=是因为right当前位置的元素是我们下一个要入窗口的元素 收缩窗口和扩大窗口对数据的更新一般是相反的（更新顺序和加减等都是相反的） 详见：https://labuladong.gitee.io/algo/2/20/27/\n进阶 ==RABIN KARP 字符匹配算法==，详见：https://labuladong.gitee.io/algo/2/20/28/\n其他 见上面各知识点章节\n递归 一个问题 = 规模更小的同类问题 + 扩展成该问题要解决的问题\n这种情况就可以用递归，递归的关键是不要跳进递归，而是明确递归函数的定义\n递归由两部分组成：递归出口和递归公式\n注意递归需要递归出口（也就是base case）\n值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。\n前缀和与差分 前缀和数组的差分是原数组，差分数组的前缀和是原数组，两者互逆。\n前缀和 对于一个数组，求此数组[left, right]区域内的和时，不需要从left\u0026ndash;right逐个相加，直接right+1前的和减去left前的和即可，要想使用这种方式就得有一个前缀和数组，用来存该数组前k个的和。注意也可能是二维数组，稍作修改即可。\n主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。\n详见：https://labuladong.gitee.io/algo/2/20/24/\n标准模板 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } 二维前缀和，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/\n差分数组 差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减\n类似前缀和构造的 preSum 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差，通过这个 diff 差分数组是可以反推出原始数组 nums 的，理解：diff[0]就是原数组的第一个元素，其他元素就是比前一个元素高多少\n这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可\n原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 又意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对 nums[i..j] 中的所有元素都加 3 了\n详见：https://labuladong.gitee.io/algo/2/20/25/\n标准模板 class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } 二维差分数组，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-周赛-328/\n二叉树 前中后序理解 前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点：\n前序位置的代码在刚刚进入一个二叉树节点的时候执行；\n后序位置的代码在将要离开一个二叉树节点的时候执行；\n中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。\n比如快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历\n遍历模板 void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 } 多叉树的遍历模板：\n/* 多叉树遍历框架 */ void traverse(TreeNode root) { if (root == null) return; // 前序位置 for (TreeNode child : root.children) { traverse(child); } // 后序位置 } 做题思路 有两种思路，分别是分解问题和遍历二叉树\n遇到一道二叉树的题目时的通用思考过程是：\n1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。\n2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)，这样的话递归函数就会一直分解这个问题，直到该问题不能再分解，所以我们还需要考虑base case(递归出口)。\n3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n后序位置的特殊之处 因为前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的，所以：\n前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。\n层序遍历 就是一个BFS，可以计算一些类似结点与root之间的距离的问题。\n模板 // 输入一棵二叉树的根节点，层序遍历这棵二叉树 void levelTraverse(TreeNode root) { if (root == null) return; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); // 从上到下遍历二叉树的每一层 while (!q.isEmpty()) { int sz = q.size(); // 从左到右遍历每一层的每个节点 for (int i = 0; i \u0026lt; sz; i++) { TreeNode cur = q.poll(); // 将下一层节点放入队列 if (cur.left != null) { // 注意不要把null放队列里面 q.offer(cur.left); } if (cur.right != null) { // 注意不要把null放队列里面 q.offer(cur.right); } } } } 注意点 前序中序，后序中序可以唯一确定一颗二叉树，或者带空指针的任意一个遍历序列都可以唯一确定一棵二叉树\n前序后序不能唯一确定一颗二叉树，因为：\n当节点左右子树都存在时，可以确定左右子树，但是当其中一个为空时，无法确定不为空的子树是左子树还是右子树\n二叉搜索树 性质 二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列，并且中序遍历到一个结点时，比该结点小的结点全部都遍历过了，这个性质可以用于二叉搜索树的累加上，二叉搜索树最左边是最小的结点，最右边是最大的结点\n合法性 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去，如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。\n增删改查 在二叉树递归框架之上，扩展出一套 BST 代码框架：\nvoid BST(TreeNode root, int target) { if (root.val == target) // 找到目标，做点什么 if (root.val \u0026lt; target) BST(root.right, target); if (root.val \u0026gt; target) BST(root.left, target); } 根据代码框架掌握了 BST 的增删查改操作。\n图 存储方式 邻接表 优点：省空间\n// 邻接表 // graph[x] 存储 x 的所有邻居节点以及对应的权重 List\u0026lt;int[]\u0026gt;[] graph; 邻接矩阵 优点：可以随机访问\n// 邻接矩阵 // matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻 int[][] matrix; 遍历模板 DFS 和多叉树类似，只不过需要记录访问过的结点\n// 记录被遍历过的节点 boolean[] visited; // 记录从起点到当前节点的路径 boolean[] onPath; /* 图遍历框架 */ void traverse(Graph graph, int s) { if (visited[s]) return; // 进入结点时 // 经过节点 s，标记为已遍历 visited[s] = true; // 做选择：标记节点 s 在路径上 onPath[s] = true; for (int neighbor : graph.neighbors(s)) { traverse(graph, neighbor); } // 离开结点时 // 撤销选择：节点 s 离开路径 onPath[s] = false; } BFS // 记录被遍历过的节点 boolean[] visited; void traverse(Graph graph, int s) { Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(s); while (!queue.isEmpty()) { int node = queue.poll(); visited[node] = true; for (int neighbor : graph.neighbors(s)) { if (!visited[neighbor]) { queue.offer(next); } } } } 图的拓扑排序 拓扑排序 直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的\n如果一个图里存在环，是无法进行拓扑排序的，反之，如果图里没有环那么一定可以拓扑排序\n注意有向无环图不一定是树\n如何拓扑排序 将后序遍历的结果进行反转，就是拓扑排序的结果。至于原因由于需要严格的数学证明，就不用看了，可以自己画个图看一看 利用图的BFS，每次只让入度为零的结点入队列，此时遍历的结果就是拓扑排序的结果 二分图 如图所示就是二分图，可以使用染色法判断一个图是否为二分图，如下所示：\n在某些场景下二分图也可以作为存储键值对的数据结构（符号表）\n判断二分图（染色）模板 其实就是图的遍历，只不过一边遍历一边染色\nDFS /* 判断二分图框架(DFS) */ private boolean[] color; private boolean[] visited; void traverse(Graph graph, int v) { visited[v] = true; // 遍历节点 v 的所有相邻节点 neighbor for (int neighbor : graph.neighbors(v)) { if (!visited[neighbor]) { // 相邻节点 neighbor 没有被访问过 // 那么应该给节点 neighbor 涂上和节点 v 不同的颜色 color[neighbor] = color[v]; traverse(graph, neighbor); } else { // 相邻节点 neighbor 已经被访问过 // 那么应该比较节点 neighbor 和节点 v 的颜色 // 若相同，则此图不是二分图 } } } BFS /* 判断二分图框架(BFS) */ private boolean[] color; private boolean[] visited; void traverse(Graph graph, int start) { Deque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); visited[start] = true; queue.offer(start); while (!queue.isEmpty()) { int v = queue.poll(); // 从节点 v 向所有相邻节点扩散 for (int w : graph[v]) { if (!visited[w]) { // 相邻节点 w 没有被访问过 // 那么应该给节点 w 涂上和节点 v 不同的颜色 color[w] = !color[v]; // 标记 w 节点，并放入队列 visited[w] = true; queue.offer(w); } else { // 相邻节点 w 已经被访问过 // 根据 v 和 w 的颜色判断是否是二分图 if (color[w] == color[v]) { // 若相同，则此图不是二分图 return; } } } } } 并查集 就是可以1、方便的合并两个集合，2、快速的判断两个结点是否处于一个集合中的树状数据结构，长下面这个样子\n模板 class UF { // 连通分量个数 private int count; // 存储每个节点的父节点 private int[] parent; // n 为图中节点的个数 public UF(int n) { this.count = n; parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } // 将节点 p 和节点 q 连通 public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootQ] = rootP; // 两个连通分量合并成一个连通分量 count--; } // 判断节点 p 和节点 q 是否连通 public boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } // 返回图中的连通分量个数 public int count() { return count; } } 这里做了路径压缩的优化，在 find 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 size 数组的平衡优化。\ndijkstra问题 dijkstra是求最短路径的算法，实际上是由图的BFS演化而来，模板如下：\nclass State { // 图节点的 id int id; // 从 start 节点到当前节点的距离 int distFromStart; State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } // 返回节点 from 到节点 to 之间的边的权重 int weight(int from, int to); // 输入节点 s 返回 s 的相邻节点 List\u0026lt;Integer\u0026gt; adj(int s); // 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离 int[] dijkstra(int start, List\u0026lt;Integer\u0026gt;[] graph) { // 图中节点的个数 int V = graph.length; // 记录最短路径的权重，你可以理解为 dp table // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重 int[] distTo = new int[V]; // 求最小值，所以 dp table 初始化为正无穷 Arrays.fill(distTo, Integer.MAX_VALUE); // base case，start 到 start 的最短距离就是 0 distTo[start] = 0; // 优先级队列，distFromStart 较小的排在前面 Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.distFromStart - b.distFromStart; }); // 从起点 start 开始进行 BFS pq.offer(new State(start, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeID = curState.id; int curDistFromStart = curState.distFromStart; // 如果只需要start到end的最短距离加上这句就可以了 // if (curNodeID == end) { // return curDistFromStart; // } if (curDistFromStart \u0026gt; distTo[curNodeID]) { // 已经有一条更短的路径到达 curNode 节点了 continue; } // 将 curNode 的相邻节点装入队列 for (int nextNodeID : adj(curNodeID)) { // 看看从 curNode 达到 nextNode 的距离是否会更短 int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID); if (distTo[nextNodeID] \u0026gt; distToNextNode) { // 更新 dp table distTo[nextNodeID] = distToNextNode; // 将这个节点以及距离放入队列 pq.offer(new State(nextNodeID, distToNextNode)); } } } return distTo; } 解释：同一个结点可能会入队多个State，一定会先遍历到dist较小的那个，结点的第一次遍历，就确定了这个结点的最短距离，然后按照这个最短距离刷新start到其他节点的距离，之后这个结点的任务就算是结束了，以后再碰到这个结点直接continue就可以了。\n注意dijkstra的变种需要修改adj和weight函数\nkruskal问题 用于求解最小生成树问题，主要思路就是先把边按权重排序，从小到大添加边，同时判断边添加后是否有环（这一步可以用并查集做），模板如下：\nint minimumCost(int n, int[][] edges) { UF uf = new UF(n); // 对所有边按照权重从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; (a[2] - b[2])); // 记录最小生成树的权重之和 int mst = 0; for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; // 若这条边会产生环，则不能加入 mst if (uf.connected(u, v)) { continue; } // 若这条边不会产生环，则属于最小生成树 mst += weight; uf.union(u, v); } // 保证所有节点都被连通 // uf.count() == 1 说明所有节点被连通 return uf.count() == 1 ? mst : -1; } class UF { // 见上文并查集模板 } 详见：https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w\nprim问题 用于求解最小生成树问题，原理就是横切边中最小的一定是最小生成树的一条边，可以每次添加一个结点找横切边（这样比较方便），然后把最小生成树的边都找到就可以了，模板如下：\nclass Prim { // 核心数据结构，存储「横切边」的优先级队列 private PriorityQueue\u0026lt;int[]\u0026gt; pq; // 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分 private boolean[] inMST; // 记录最小生成树的权重和 private int weightSum = 0; // graph 是用邻接表表示的一幅图， // graph[s] 记录节点 s 所有相邻的边， // 三元组 int[]{from, to, weight} 表示一条边 private List\u0026lt;int[]\u0026gt;[] graph; public Prim(List\u0026lt;int[]\u0026gt;[] graph) { this.graph = graph; this.pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { // 按照边的权重从小到大排序 return a[2] - b[2]; }); // 图中有 n 个节点 int n = graph.length; this.inMST = new boolean[n]; // 随便从一个点开始切分都可以，我们不妨从节点 0 开始 inMST[0] = true; cut(0); // 不断进行切分，向最小生成树中添加边 while (!pq.isEmpty()) { int[] edge = pq.poll(); int to = edge[1]; int weight = edge[2]; if (inMST[to]) { // 节点 to 已经在最小生成树中，跳过 // 否则这条边会产生环 continue; } // 将边 edge 加入最小生成树 weightSum += weight; inMST[to] = true; // 节点 to 加入后，进行新一轮切分，会产生更多横切边 cut(to); } } // 将 s 的横切边加入优先队列 private void cut(int s) { // 遍历 s 的邻边 for (int[] edge : graph[s]) { int to = edge[1]; if (inMST[to]) { // 相邻接点 to 已经在最小生成树中，跳过 // 否则这条边会产生环 continue; } // 加入横切边队列 pq.offer(edge); } } // 最小生成树的权重和 public int weightSum() { return weightSum; } // 判断最小生成树是否包含图中的所有节点 public boolean allConnected() { for (int i = 0; i \u0026lt; inMST.length; i++) { if (!inMST[i]) { return false; } } return true; } } 详见：https://labuladong.gitee.io/algo/2/22/55/\n回溯 回溯和DFS的区别：\n回溯关注的是树枝，DFS关注的是结点，反映到代码上：\n// DFS 算法，关注点在节点 void traverse(TreeNode root) { if (root == null) return; printf(\u0026#34;进入节点 %s\u0026#34;, root); for (TreeNode child : root.children) { traverse(child); } printf(\u0026#34;离开节点 %s\u0026#34;, root); } // 回溯算法，关注点在树枝 void backtrack(TreeNode root) { if (root == null) return; for (TreeNode child : root.children) { // 做选择 printf(\u0026#34;从 %s 到 %s\u0026#34;, root, child); backtrack(child); // 撤销选择 printf(\u0026#34;从 %s 到 %s\u0026#34;, child, root); } } 设计数据结构 LRU 即Least Recently Used，也就是每次淘汰那些最久没被使用的数据，主要就是利用了哈希链表（在Java中是LinkedHashMap）这种数据结构，如下图所示：\n手写轮子模板：\nclass LRUCache { // key -\u0026gt; Node(key, val) private Map\u0026lt;Integer, Node\u0026gt; map; // Node(k1, v1) \u0026lt;-\u0026gt; Node(k2, v2)... private DoubleList cache; // 最大容量 private int capacity; public LRUCache(int capacity) { this.capacity = capacity; map = new HashMap\u0026lt;\u0026gt;(); cache = new DoubleList(); } public int get(int key) { if (!map.containsKey(key)) { return -1; } // 将该数据提升为最近使用的 makeRecently(key); return map.get(key).val; } public void put(int key, int val) { if (map.containsKey(key)) { // 删除旧的数据 deleteKey(key); // 新插入的数据为最近使用的数据 addRecently(key, val); return; } if (cap == cache.size()) { // 删除最久未使用的元素 removeLeastRecently(); } // 添加为最近使用的元素 addRecently(key, val); } /* 将某个 key 提升为最近使用的 */ private void makeRecently(int key) { Node x = map.get(key); // 先从链表中删除这个节点 cache.remove(x); // 重新插到队尾 cache.addLast(x); } /* 添加最近使用的元素 */ private void addRecently(int key, int val) { Node x = new Node(key, val); // 链表尾部就是最近使用的元素 cache.addLast(x); // 别忘了在 map 中添加 key 的映射 map.put(key, x); } /* 删除某一个 key */ private void deleteKey(int key) { Node x = map.get(key); // 从链表中删除 cache.remove(x); // 从 map 中删除 map.remove(key); } /* 删除最久未使用的元素 */ private void removeLeastRecently() { // 链表头部的第一个元素就是最久未使用的 Node deletedNode = cache.removeFirst(); // 同时别忘了从 map 中删除它的 key int deletedKey = deletedNode.key; map.remove(deletedKey); } class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class DoubleList { // 头尾虚节点 private Node head, tail; // 链表元素数 private int size; public DoubleList() { // 初始化双向链表的数据 head = new Node(0, 0); tail = new Node(0, 0); head.next = tail; tail.prev = head; size = 0; } // 在链表尾部添加节点 x，时间 O(1) public void addLast(Node x) { x.prev = tail.prev; x.next = tail; tail.prev.next = x; tail.prev = x; size++; } // 删除链表中的 x 节点（x 一定存在） // 由于是双链表且给的是目标 Node 节点，时间 O(1) public void remove(Node x) { x.prev.next = x.next; x.next.prev = x.prev; size--; } // 删除链表中第一个节点，并返回该节点，时间 O(1) public Node removeFirst() { if (size == 0) { return null; } Node first = head.next; remove(first); return first; } // 返回链表长度，时间 O(1) public int size() { return size; } } } 使用LinkedHashMap模板：\nclass LRUCache { int cap; LinkedHashMap\u0026lt;Integer, Integer\u0026gt; cache = new LinkedHashMap\u0026lt;\u0026gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() \u0026gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); } } LFU Least Frequently Used，也就是每次淘汰那些使用次数最少的数据，主要利用了keyToVal，keyToFreq，freqToKeys三个数据结构相互配合，详见：https://mp.weixin.qq.com/s/oXv03m1J8TwtHwMJEZ1ApQ，模板如下：\nclass LFUCache { // key 到 val 的映射，我们后文称为 KV 表 HashMap\u0026lt;Integer, Integer\u0026gt; keyToVal; // key 到 freq 的映射，我们后文称为 KF 表 HashMap\u0026lt;Integer, Integer\u0026gt; keyToFreq; // freq 到 key 列表的映射，我们后文称为 FK 表 HashMap\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; // 记录最小的频次 int minFreq; // 记录 LFU 缓存的最大容量 int cap; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.cap = capacity; this.minFreq = 0; } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } // 增加 key 对应的 freq increaseFreq(key); return keyToVal.get(key); } public void put(int key, int val) { if (this.cap \u0026lt;= 0) return; /* 若 key 已存在，修改对应的 val 即可 */ if (keyToVal.containsKey(key)) { keyToVal.put(key, val); // key 对应的 freq 加一 increaseFreq(key); return; } /* key 不存在，需要插入 */ /* 容量已满的话需要淘汰一个 freq 最小的 key */ if (this.cap \u0026lt;= keyToVal.size()) { removeMinFreqKey(); } /* 插入 key 和 val，对应的 freq 为 1 */ // 插入 KV 表 keyToVal.put(key, val); // 插入 KF 表 keyToFreq.put(key, 1); // 插入 FK 表 freqToKeys.putIfAbsent(1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(1).add(key); // 插入新 key 后最小的 freq 肯定是 1 this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); /* 更新 KF 表 */ keyToFreq.put(key, freq + 1); /* 更新 FK 表 */ // 将 key 从 freq 对应的列表中删除 freqToKeys.get(freq).remove(key); // 将 key 加入 freq + 1 对应的列表中 freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(freq + 1).add(key); // 如果 freq 对应的列表空了，移除这个 freq if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); // 如果这个 freq 恰好是 minFreq，更新 minFreq if (freq == this.minFreq) { this.minFreq++; } } } private void removeMinFreqKey() { // freq 最小的 key 列表 LinkedHashSet\u0026lt;Integer\u0026gt; keyList = freqToKeys.get(this.minFreq); // 其中最先被插入的那个 key 就是该被淘汰的 key int deletedKey = keyList.iterator().next(); /* 更新 FK 表 */ keyList.remove(deletedKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 问：这里需要更新 minFreq 的值吗？ // 这里不用修改minFreq因为后面会置为1 } /* 更新 KV 表 */ keyToVal.remove(deletedKey); /* 更新 KF 表 */ keyToFreq.remove(deletedKey); } } TrieMap和TrieSet Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。结构如下所示：\n底层是Trie树的Map就是TrieMap，TrieMap就是key是字符串，value是任何类型的map，TrieSet就是没用到value的TrieMap，详见：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==\u0026amp;mid=2247495471\u0026amp;idx=1\u0026amp;sn=fd180d7e207e92a87a9c9cce69b8cdb9\nTrieMap模板如下：\nclass TrieMap\u0026lt;V\u0026gt; { // ASCII 码个数 private static final int R = 256; // 当前存在 Map 中的键值对个数 private int size = 0; // Trie 树的根节点 private TrieNode\u0026lt;V\u0026gt; root = null; private static class TrieNode\u0026lt;V\u0026gt; { V val = null; TrieNode\u0026lt;V\u0026gt;[] children = new TrieNode[R]; } /***** 增/改 *****/ // 在 map 中添加或修改键值对 public void put(String key, V val) { if (!containsKey(key)) { // 新增键值对 size++; } // 需要一个额外的辅助函数，并接收其返回值 root = put(root, key, val, 0); } // 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点 private TrieNode\u0026lt;V\u0026gt; put(TrieNode\u0026lt;V\u0026gt; node, String key, V val, int i) { if (node == null) { // 如果树枝不存在，新建 node = new TrieNode\u0026lt;\u0026gt;(); } if (i == key.length()) { // key 的路径已插入完成，将值 val 存入节点 node.val = val; return node; } char c = key.charAt(i); // 递归插入子节点，并接收返回值 node.children[c] = put(node.children[c], key, val, i + 1); return node; } /***** 删 *****/ // 在 Map 中删除 key public void remove(String key) { if (!containsKey(key)) { return; } // 递归修改数据结构要接收函数的返回值 root = remove(root, key, 0); size--; } // 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点 private TrieNode\u0026lt;V\u0026gt; remove(TrieNode\u0026lt;V\u0026gt; node, String key, int i) { if (node == null) { return null; } if (i == key.length()) { // 找到了 key 对应的 TrieNode，删除 val node.val = null; } else { char c = key.charAt(i); // 递归去子树进行删除 node.children[c] = remove(node.children[c], key, i + 1); } // 后序位置，递归路径上的节点可能需要被清理 if (node.val != null) { // 如果该 TireNode 存储着 val，不需要被清理 return node; } // 检查该 TrieNode 是否还有后缀 for (int c = 0; c \u0026lt; R; c++) { if (node.children[c] != null) { // 只要存在一个子节点（后缀树枝），就不需要被清理 return node; } } // 既没有存储 val，也没有后缀树枝，则该节点需要被清理 return null; } /***** 查 *****/ // 搜索 key 对应的值，不存在则返回 null public V get(String key) { // 从 root 开始搜索 key TrieNode\u0026lt;V\u0026gt; x = getNode(root, key); if (x == null || x.val == null) { // x 为空或 x 的 val 字段为空都说明 key 没有对应的值 return null; } return x.val; } // 判断 key 是否存在在 Map 中 public boolean containsKey(String key) { return get(key) != null; } // 判断是和否存在前缀为 prefix 的键 public boolean hasKeyWithPrefix(String prefix) { // 只要能找到一个节点，就是存在前缀 return getNode(root, prefix) != null; } // 在所有键中寻找 query 的最短前缀 public String shortestPrefixOf(String query) { TrieNode\u0026lt;V\u0026gt; p = root; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; query.length(); i++) { if (p == null) { // 无法向下搜索 return \u0026#34;\u0026#34;; } if (p.val != null) { // 找到一个键是 query 的前缀 return query.substring(0, i); } // 向下搜索 char c = query.charAt(i); p = p.children[c]; } if (p != null \u0026amp;\u0026amp; p.val != null) { // 如果 query 本身就是一个键 return query; } return \u0026#34;\u0026#34;; } // 在所有键中寻找 query 的最长前缀 public String longestPrefixOf(String query) { TrieNode\u0026lt;V\u0026gt; p = root; // 记录前缀的最大长度 int max_len = 0; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; query.length(); i++) { if (p == null) { // 无法向下搜索 break; } if (p.val != null) { // 找到一个键是 query 的前缀，更新前缀的最大长度 max_len = i; } // 向下搜索 char c = query.charAt(i); p = p.children[c]; } if (p != null \u0026amp;\u0026amp; p.val != null) { // 如果 query 本身就是一个键 return query; } return query.substring(0, max_len); } // 搜索前缀为 prefix 的所有键 public List\u0026lt;String\u0026gt; keysWithPrefix(String prefix) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); // 找到匹配 prefix 在 Trie 树中的那个节点 TrieNode\u0026lt;V\u0026gt; x = getNode(root, prefix); if (x == null) { return res; } // DFS 遍历以 x 为根的这棵 Trie 树 traverse(x, new StringBuilder(prefix), res); return res; } // 遍历以 node 节点为根的 Trie 树，找到所有键 private void traverse(TrieNode\u0026lt;V\u0026gt; node, StringBuilder path, List\u0026lt;String\u0026gt; res) { if (node == null) { // 到达 Trie 树底部叶子结点 return; } if (node.val != null) { // 找到一个 key，添加到结果列表中 res.add(path.toString()); } // 回溯算法遍历框架 for (char c = 0; c \u0026lt; R; c++) { // 做选择 path.append(c); traverse(node.children[c], path, res); // 撤销选择 path.deleteCharAt(path.length() - 1); } } // 通配符 . 匹配任意字符 public List\u0026lt;String\u0026gt; keysWithPattern(String pattern) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); traverse(root, new StringBuilder(), pattern, 0, res); return res; } // 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..] private void traverse(TrieNode\u0026lt;V\u0026gt; node, StringBuilder path, String pattern, int i, List\u0026lt;String\u0026gt; res) { if (node == null) { // 树枝不存在，即匹配失败 return; } if (i == pattern.length()) { // pattern 匹配完成 if (node.val != null) { // 如果这个节点存储着 val，则找到一个匹配的键 res.add(path.toString()); } return; } char c = pattern.charAt(i); if (c == \u0026#39;.\u0026#39;) { // pattern[i] 是通配符，可以变化成任意字符 // 多叉树（回溯算法）遍历框架 for (char j = 0; j \u0026lt; R; j++) { path.append(j); traverse(node.children[j], path, pattern, i + 1, res); path.deleteCharAt(path.length() - 1); } } else { // pattern[i] 是普通字符 c path.append(c); traverse(node.children[c], path, pattern, i + 1, res); path.deleteCharAt(path.length() - 1); } } // 判断是和否存在前缀为 prefix 的键 public boolean hasKeyWithPattern(String pattern) { // 从 root 节点开始匹配 pattern[0..] return hasKeyWithPattern(root, pattern, 0); } // 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配 private boolean hasKeyWithPattern(TrieNode\u0026lt;V\u0026gt; node, String pattern, int i) { if (node == null) { // 树枝不存在，即匹配失败 return false; } if (i == pattern.length()) { // 模式串走到头了，看看匹配到的是否是一个键 return node.val != null; } char c = pattern.charAt(i); // 没有遇到通配符 if (c != \u0026#39;.\u0026#39;) { // 从 node.children[c] 节点开始匹配 pattern[i+1..] return hasKeyWithPattern(node.children[c], pattern, i + 1); } // 遇到通配符 for (int j = 0; j \u0026lt; R; j++) { // pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回 if (hasKeyWithPattern(node.children[j], pattern, i + 1)) { return true; } } // 都没有匹配 return false; } // 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null private TrieNode\u0026lt;V\u0026gt; getNode(TrieNode\u0026lt;V\u0026gt; node, String key) { TrieNode\u0026lt;V\u0026gt; p = node; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; key.length(); i++) { if (p == null) { // 无法向下搜索 return null; } // 向下搜索 char c = key.charAt(i); p = p.children[c]; } return p; } public int size() { return size; } } TrieSet模板如下：\nclass TrieSet { // 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用 // 值的类型可以随便设置，我参考 Java 标准库设置成 Object private final TrieMap\u0026lt;Object\u0026gt; map = new TrieMap\u0026lt;\u0026gt;(); /***** 增 *****/ // 在集合中添加元素 key public void add(String key) { map.put(key, new Object()); } /***** 删 *****/ // 从集合中删除元素 key public void remove(String key) { map.remove(key); } /***** 查 *****/ // 判断元素 key 是否存在集合中 public boolean contains(String key) { return map.containsKey(key); } // 在集合中寻找 query 的最短前缀 public String shortestPrefixOf(String query) { return map.shortestPrefixOf(query); } // 在集合中寻找 query 的最长前缀 public String longestPrefixOf(String query) { return map.longestPrefixOf(query); } // 在集合中搜索前缀为 prefix 的所有元素 public List\u0026lt;String\u0026gt; keysWithPrefix(String prefix) { return map.keysWithPrefix(prefix); } // 判断集合中是否存在前缀为 prefix 的元素 public boolean hasKeyWithPrefix(String prefix) { return map.hasKeyWithPrefix(prefix); } // 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素 public List\u0026lt;String\u0026gt; keysWithPattern(String pattern) { return map.keysWithPattern(pattern); } // 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素 public boolean hasKeyWithPattern(String pattern) { return map.hasKeyWithPattern(pattern); } // 返回集合中元素的个数 public int size() { return map.size(); } } 单调栈 就是元素单调递增或递减的栈，比如单减栈，入栈的时候将小于入栈元素的栈顶出栈，就可以保证栈的单调递减，一般可以用在「下一个更大元素」，「上一个更小元素」等问题上，「下一个更大元素」模板如下：\nint[] nextGreaterElement(int[] nums) { int n = nums.length; // 存放答案的数组 int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); // 倒着往栈里放 for (int i = n - 1; i \u0026gt;= 0; i--) { // 判定个子高矮 while (!s.isEmpty() \u0026amp;\u0026amp; s.peek() \u0026lt;= nums[i]) { // 矮个起开，反正也被挡着了。。。 s.pop(); } // nums[i] 身后的更大元素 res[i] = s.isEmpty() ? -1 : s.peek(); s.push(nums[i]); } return res; } 单调队列 就是元素单调递增或递减的队列，比如单减队列，入队的时候将小于入队元素的队尾出队，就可以保证队的单调递减，一般可以用在「滑动窗口最大值」问题上，模板如下：\n/* 单调队列的实现 */ class MonotonicQueue { LinkedList\u0026lt;Integer\u0026gt; maxq = new LinkedList\u0026lt;\u0026gt;(); public void push(int n) { // 将小于 n 的元素全部删除 while (!maxq.isEmpty() \u0026amp;\u0026amp; maxq.getLast() \u0026lt; n) { maxq.pollLast(); } // 然后将 n 加入尾部 maxq.addLast(n); } public int max() { return maxq.getFirst(); } public void poll(int n) { if (n == maxq.getFirst()) { maxq.pollFirst(); } } } 二叉堆 就是最大堆或最小堆，是一颗完全二叉树，所以可以放在数组里面，用简单的计算就能得到结点的父节点和左右孩子，基于二叉堆开发出了优先队列，优先队列插入时将插入结点放到数组最后面然后对该节点执行上浮操作，删除时将堆顶删除，然后将数组最后面的结点放到堆顶的位置，然后对堆顶做下沉操作。模板如下：\npublic class MaxPQ \u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { // 存储元素的数组 private Key[] pq; // 当前 Priority Queue 中的元素个数 private int size = 0; public MaxPQ(int cap) { // 索引 0 不用，所以多分配一个空间 pq = (Key[]) new Comparable[cap + 1]; } /* 返回当前队列中最大元素 */ public Key max() { return pq[1]; } /* 插入元素 e */ public void insert(Key e) { size++; // 先把新元素加到最后 pq[size] = e; // 然后让它上浮到正确的位置 swim(size); } /* 删除并返回当前队列中最大元素 */ public Key delMax() { // 最大堆的堆顶就是最大元素 Key max = pq[1]; // 把这个最大元素换到最后，删除之 swap(1, size); pq[size] = null; size--; // 让 pq[1] 下沉到正确位置 sink(1); return max; } /* 上浮第 x 个元素，以维护最大堆性质 */ private void swim(int x) { // 如果浮到堆顶，就不能再上浮了 while (x \u0026gt; 1 \u0026amp;\u0026amp; less(parent(x), x)) { // 如果第 x 个元素比上层大 // 将 x 换上去 swap(parent(x), x); x = parent(x); } } /* 下沉第 x 个元素，以维护最大堆性质 */ private void sink(int x) { // 如果沉到堆底，就沉不下去了 while (left(x) \u0026lt;= size) { // 先假设左边节点较大 int max = left(x); // 如果右边节点存在，比一下大小 if (right(x) \u0026lt;= size \u0026amp;\u0026amp; less(max, right(x))) max = right(x); // 结点 x 比俩孩子都大，就不必下沉了 if (less(max, x)) break; // 否则，不符合最大堆的结构，下沉 x 结点 swap(x, max); x = max; } } /* 交换数组的两个元素 */ private void swap(int i, int j) { Key temp = pq[i]; pq[i] = pq[j]; pq[j] = temp; } /* pq[i] 是否比 pq[j] 小？ */ private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) \u0026lt; 0; } // 父节点的索引 private int parent(int root) { return root / 2; } // 左孩子的索引 private int left(int root) { return root * 2; } // 右孩子的索引 private int right(int root) { return root * 2 + 1; } } 队列实现栈以及栈实现队列 栈实现队列用两个栈即可，入栈相当于入队，出栈时先将一个栈里的元素出栈到另一个栈中，栈顶就是队头，模板如下：\nclass MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } /** 添加元素到队尾 */ public void push(int x) { s1.push(x); } /** 返回队头元素 */ public int peek() { if (s2.isEmpty()) // 把 s1 元素压入 s2 while (!s1.isEmpty()) s2.push(s1.pop()); return s2.peek(); } /** 删除队头的元素并返回 */ public int pop() { // 先调用 peek 保证 s2 非空 peek(); return s2.pop(); } /** 判断队列是否为空 */ public boolean empty() { return s1.isEmpty() \u0026amp;\u0026amp; s2.isEmpty(); } } 栈实现队列简单粗暴，pop的时候把除了队尾的其他都出队再加入到队尾即可，模板如下：\nclass MyStack { Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); int top_elem = 0; /** 添加元素到栈顶 */ public void push(int x) { // x 是队列的队尾，是栈的栈顶 q.offer(x); top_elem = x; } /** 返回栈顶元素 */ public int top() { return top_elem; } /** 删除栈顶的元素并返回 */ public int pop() { int size = q.size(); // 留下队尾 2 个元素 while (size \u0026gt; 2) { q.offer(q.poll()); size--; } // 记录新的队尾元素 top_elem = q.peek(); q.offer(q.poll()); // 删除之前的队尾元素 return q.poll(); } /** 判断栈是否为空 */ public boolean empty() { return q.isEmpty(); } } 排序 快速排序 快速排序的确定中枢位置的过程叫做快速选择，可以快速确定一个数在排序以后的位置，模板如下：\n/** * @Description 一趟快速排序：將序列分片，基准元素左边的都是小于它的，右边的都是大于它的 * @Param [arr, left, right] */ public static int partition(int[] arr, int left, int right){ int pivot = arr[left]; // 选取第一个为基准元素 while(left\u0026lt;right){ /* 先从右往移动，直到遇见小于 pivot 的元素 */ while (left\u0026lt;right \u0026amp;\u0026amp; arr[right]\u0026gt;=pivot){ right--; } arr[left] = arr[right]; // 记录小于 pivot 的值 /* 再从左往右移动，直到遇见大于 pivot 的元素 */ while(left\u0026lt;right \u0026amp;\u0026amp; arr[left]\u0026lt;=pivot){ left++; } arr[right] = arr[left]; // 记录大于 pivot 的值 } arr[left] = pivot; // 记录基准元素到当前指针指向的区域 return left;\t// 返回基准元素的索引 } 快速选择可以解决数组中的第K个最大元素这种问题\n快速排序模板如下：\npublic static void quickSort(int[] arr, int left, int right){ if (left \u0026lt; right){ // 把数组分块 int pivot = partition(arr, left, right); // 基准元素左边递归 quickSort(arr, left, pivot-1); // 基准元素右边递归 quickSort(arr, pivot+1, right); } } public static int partition(int[] arr, int left, int right){ int pivot = arr[left]; // 选取第一个为基准元素 while(left\u0026lt;right){ /* 先从右往移动，直到遇见小于 pivot 的元素 */ while (left\u0026lt;right \u0026amp;\u0026amp; arr[right]\u0026gt;=pivot){ right--; } arr[left] = arr[right]; // 记录小于 pivot 的值 /* 再从左往右移动，直到遇见大于 pivot 的元素 */ while(left\u0026lt;right \u0026amp;\u0026amp; arr[left]\u0026lt;=pivot){ left++; } arr[right] = arr[left]; // 记录大于 pivot 的值 } arr[left] = pivot; // 记录基准元素到当前指针指向的区域 return left;\t// 返回基准元素的索引 } 其他 零碎 从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。\n数据结构的物理存储方式就是链式和顺序两种，基本操作就是增删改查，遍历方式无非迭代和递归。\n计算机算法的本质就是枚举，只不过这里枚举需要做到两个方面：无遗漏和无冗余，有时候还可以利用一些定理进行优化（缩小搜索范围），比如剪枝和数学定理\n难点在无遗漏的问题：\n难点在无冗余的问题：递归类问题（动态规划）\n难点在优化的问题：非递归类问题（并查集，贪心，KMP）\nJava里优先队列就是二叉堆，也就是PriorityQueue\nbase case就是最基本的情况，从递归的角度理解就是递归出口，从分解问题(分治)的角度理解就是最基本的问题（不能再分了）\n如果需要通过值找到其在数组的索引，将数组遍历一遍是一种做法，还可以创建一个valToIndex的hashmap\n序列化就是把结构化的数据（比如树）打平（比如转换为字符串）\n序列化和反序列化的目的：以某种特定格式组织数据，使得数据可以独立于编程语言。\nBoyer-Moore(摩尔) 投票算法详见：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/\n负数取余得到的结果还是负数\n注意二分查找的左边界是第一个大于等于target的数，右边界是从右往左第一个小于等于target的数\npython里自带了二分查找左边界和右边界的函数，Java里有基本版的二分查找\n看到「最大化最小值」或者「最小化最大值」（其实就是那种要求一堆数字尽量平均的题）就要想到二分答案，这是一个固定的套路。为什么？一般来说，二分的值越大，越能/不能满足要求；二分的值越小，越不能/能满足要求，有单调性，可以二分。\n前缀和中preSum[i + 1]是[0\u0026hellip;i]的元素之和\n差分数组的前缀和就是原数组\n待做 https://labuladong.gitee.io/algo/1/3/的那几个算法框架及之后的几个框架文章都没看\nhttps://labuladong.gitee.io/algo/2/21/41/没看\nhttps://labuladong.gitee.io/algo/2/21/45/没看\nhttps://labuladong.gitee.io/algo/2/22/57/没看\nhttps://labuladong.gitee.io/algo/2/23/67/没看\nhttps://labuladong.gitee.io/algo/2/20/29/没看\n技巧 dummy（虚拟头结点)：可以很好的避免第一个节点的特殊性，将第一个节点当作第二个节点，也即是所有节点统一处理\n把 return 语句都放在函数开头，因为一般 return 语句都是 base case，集中放在一起可以让算法结构更清晰。\n将二维坐标映射到一维的常用技巧：将二维坐标 (x,y) 转换成 x * n + y 这个数（m 是棋盘的行数，n 是棋盘的列数）\n方向数组 d 是上下左右搜索的常用手法：int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};\n学习方法 以后做题，先想这道题考察什么知识点。\n","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/","summary":"链表 合并两个有序链表 解法 略 题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetc","title":"LeetCode Note 1"},{"content":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n代码 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.next = p; p2 = p2.next; } ListNode temp = p.next; p.next = null; p = temp; } p1.next = dummy2.next; return dummy1.next; } References 1. 分隔链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-86/","summary":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。 代码 class","title":"LeetCode 86"},{"content":"思路 两种思路：\n迭代 不解释\n递归 不解释\n代码 迭代 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2 != null) { p.next = list2; } return dummy.next; } } 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) { return list2; } else if (list2 == null) { return list1; } if (list1.val \u0026lt; list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } References 1. 合并两个有序链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-21/","summary":"思路 两种思路： 迭代 不解释 递归 不解释 代码 迭代 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p","title":"LeetCode 21"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://blog.zhangmengyang.tk/en/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文","title":"🤝友链"},{"content":"about me\nname: ZMY occupation: Postgraduate student hobby: coding、game、wangshangchonglang ","permalink":"https://blog.zhangmengyang.tk/en/about/","summary":"about me name: ZMY occupation: Postgraduate student hobby: coding、game、wangshangchonglang","title":"🙋🏻‍♂️about"}]