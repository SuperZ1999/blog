[{"content":"思路 和二叉树的层序遍历差不多，只不过需要注意每层需要用一个flag来判断这层是正序的还是倒序的\n代码 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return res; } Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); boolean flag = true; while (!queue.isEmpty()) { int size = queue.size(); LinkedList\u0026lt;Integer\u0026gt; level = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { TreeNode cur = queue.poll(); if (flag) { level.addLast(cur.val); } else { level.addFirst(cur.val); } if (cur.left != null) { queue.offer(cur.left); } if (cur.right != null) { queue.offer(cur.right); } } res.add(level); flag = !flag; } return res; } } References 1. 二叉树的锯齿形层序遍历 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-103/","summary":"思路 和二叉树的层序遍历差不多，只不过需要注意每层需要用一个flag来判断这层是正序的还是倒序的 代码 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return res; }","title":"LeetCode 103"},{"content":"思路 和合并有序链表一样，只不过这里为了防止多次移动数组元素，从后面往前合并，使用逆序双指针\n代码 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1, j = n - 1, k = m + n - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0) { if (nums1[i] \u0026gt; nums2[j]) { nums1[k] = nums1[i]; k--; i--; } else { nums1[k] = nums2[j]; k--; j--; } } while (j \u0026gt;= 0) { nums1[k] = nums2[j]; k--; j--; } } } References 1. 合并两个有序数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-88/","summary":"思路 和合并有序链表一样，只不过这里为了防止多次移动数组元素，从后面往前合并，使用逆序双指针 代码 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1, j = n","title":"LeetCode 88"},{"content":"思路 有两种思路：\n中序遍历法 先中序遍历一次，得到遍历序列，然后从序列里找到当前待查找的结点，然后再找到这个节点的下一个节点\n分类直接寻找法 可以分成三种情况\n该结点存在右子树，那么下一个节点就是右子树最左边的结点 该结点不存在右子树，且该结点是父结点的左子树，那么下一个节点就是父结点 该结点不存在右子树，且该结点是父结点的右子树，则先要沿着左上方父节点爬树，一直爬到当前结点是其父节点的左子节点为止，返回的就是这个父节点；或者没有满足上述情况的则返回为NULL 其中第二三种情况可以合并，合并成从当前结点开始找，找到当前结点是其父节点的左子节点为止\n代码 中序遍历法 public class Solution { ArrayList\u0026lt;TreeLinkNode\u0026gt; nodes = new ArrayList\u0026lt;\u0026gt;(); public TreeLinkNode GetNext(TreeLinkNode pNode) { // 获取根节点 TreeLinkNode root = pNode; while(root.next != null) root = root.next; // 中序遍历打造nodes InOrder(root); // 进行匹配 int n = nodes.size(); for(int i = 0; i \u0026lt; n - 1; i++) { TreeLinkNode cur = nodes.get(i); if(pNode == cur) { return nodes.get(i+1); } } return null; } // 中序遍历 void InOrder(TreeLinkNode root) { if(root != null) { InOrder(root.left); nodes.add(root); InOrder(root.right); } } } 分类直接寻找法 public class Solution { public TreeLinkNode GetNext(TreeLinkNode pNode) { if (pNode.right != null) { TreeLinkNode node = pNode.right; while (node.left != null) { node = node.left; } return node; } while (pNode != null) { if (pNode.next == null) { return null; } if (pNode.next.left == pNode) { return pNode.next; } pNode = pNode.next; } return null; } } References 1. 二叉树的下一个结点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/nowcoder-jz8/","summary":"思路 有两种思路： 中序遍历法 先中序遍历一次，得到遍历序列，然后从序列里找到当前待查找的结点，然后再找到这个节点的下一个节点 分类直接寻找法 可以分","title":"nowcoder JZ8"},{"content":"思路 经典层序遍历，BFS即可\n代码 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { if (root == null) { return new ArrayList\u0026lt;\u0026gt;(); } Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int size = queue.size(); ArrayList\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); while (size-- != 0) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } res.add(level); } return res; } } References 1. 二叉树的层序遍历 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-102/","summary":"思路 经典层序遍历，BFS即可 代码 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { if (root == null) { return new ArrayList\u0026lt;\u0026gt;(); } Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while (!queue.isEmpty()) { int size = queue.size(); ArrayList\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); while (size-- != 0) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null)","title":"LeetCode 102"},{"content":"思路 经典快排不解释，注意数组如果本来就有序，快排会变得很慢，这时可以随机选中枢，而不是以left为中枢\n代码 class Solution { public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums; } private void quickSort(int[] nums, int left, int right) { if (left \u0026gt;= right) { return; } int pivotIndex = new Random().nextInt(right - left + 1) + left; swap(nums, left, pivotIndex); int pivot = nums[left], l = left, r = right; while (l \u0026lt; r) { while (l \u0026lt; r \u0026amp;\u0026amp; nums[r] \u0026gt;= pivot) { r--; } nums[l] = nums[r]; while (l \u0026lt; r \u0026amp;\u0026amp; nums[l] \u0026lt;= pivot) { l++; } nums[r] = nums[l]; } nums[l] = pivot; quickSort(nums, left, l - 1); quickSort(nums, l + 1, right); } private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } References 1. 排序数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-912/","summary":"思路 经典快排不解释，注意数组如果本来就有序，快排会变得很慢，这时可以随机选中枢，而不是以left为中枢 代码 class Solution { public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums; } private","title":"LeetCode 912"},{"content":"项目 一般问题 碰到的bug 最有技术含量的部分 动态代理 见：https://juejin.cn/post/7011357346018361375\njdk动态代理 原理 就是先实现代理接口的方法，生成一个匿名内部类，这个匿名内部类里的操作都是调用InvocationHandler的invoke方法，在invoke方法里完成代理\n使用步骤 创建被代理类及接口（JDK代理是接口代理） 创建Handle类实现 InvocationHandler接口 ，重写invoke方法 通过Proxy的newProxyInstance()方法获取代理类对象 通过代理类对象调用被代理类的方法 jdk动态代理的反射体现在什么地方 调用代理对象方法，会调用handler的invoke方法，invoke方法里面调用原始对象方法就是使用的反射\ncglib动态代理 原理 就是修改需要代理的那个类的字节码，生成该类的子类并重写父类的方法，这个子类的方法都会调用回调函数intercept方法，从而完成代理\n使用步骤 new Enhancer() 设置需要代理的类 设置回调 创建 jdk动态代理和cglib动态代理的区别 **原理不同：**JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。 CGLib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。所以jdk动态代理的方式创建代理对象效率较高，执行效率较低（因为调用方法的时候需要反射），CGLib创建效率较低，执行效率高。 **适用场景不同：**jdk动态代理目标类必须是接口类，cglib代理目标类不需要实现接口，但是不能是final类 **机制不同：**jdk动态代理是委托机制，因为代理类里无法直接调用被代理类的方法，所以委托InvocationHandler去调用目标类的方法，cglib动态代理是继承机制，代理类和被代理类是父子关系，所以代理类可以调用被代理类的方法，所以通过回调函数MethodInterceptor调用父类方法执行原始逻辑 静态代理 为需要代理的类抽象出一个接口，然后编写代理类实现这个接口，实现接口方法时就可以添加代理的逻辑\n缺点：1、每个被代理类都要有一个代理类，代码比较冗余 2、一旦改动被代理类，代理类也得改动\n静态代理与动态代理的区别 静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件 动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成的 Netty 什么是Netty Netty就是Java里NIO的封装，让用户可以很方便的使用Java的非阻塞IO\nNetty跟Java NIO有什么不同，为什么不直接使用JDK NIO类库？ 说说NIO有什么缺点吧：\nNIO的类库和API还是有点复杂，比如Buffer的使用、Selector编写复杂，如果对某个事件注册后，业务代码过于耦合，需要了解很多多线程的知识，熟悉网络编程，面对断连重连、保丢失、粘包等，处理复杂 NIO存在BUG，根据网上言论说是selector空轮询导致CPU飙升 Netty主要的优点有：\n统一的 API，支持多种传输类型，阻塞和非阻塞的。（对NIO的封装，使用起来比较简单） 简单而强大的线程模型。（Reactor模型） 自带编解码器解决 TCP 粘包/拆包问题，自带各种协议栈。 比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。（零拷贝技术） 社区活跃，成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty， 比如我们经常接触的 Dubbo、RocketMQ 等等。 Netty 应用场景了解么？ 理论上来说，NIO 可以做的事情 ，使用 Netty 都可以做并且更好。Netty 主要用来做网络通信：\n作为 RPC 框架的网络通信工具 实现一个自己的 HTTP 服务器 实现一个即时通讯系统 实现消息推送系统 基本只要是网络通信的都可以用Netty做\nNetty的核心组件 EventLoop EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。\nChannel Channel 接口是 Netty 对网络操作抽象类，它包括基本的 I/O 操作，如 bind()、connect()、read()、write() 等。\n比较常用的Channel接口实现类是NioServerSocketChannel（服务端）和NioSocketChannel（客户端），这两个 Channel 可以和 BIO 编程模型中的ServerSocket以及Socket两个概念对应上。Netty 的 Channel 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。\nChannelFuture Netty 是异步非阻塞的，所有的 I/O 操作都为异步的。所以我们不能立刻得到操作的结果，我们可以通过 ChannelFuture 接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行完后，监听就会自动触发返回结果。\nChannelHandler 和 ChannelPipeline ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连在一起了，连在一起形成的链就是 ChannelPipeline\nBootstrap 和 ServerBootstrap 了解么？ Bootstrap是客户端，ServerBootstrap是服务端 Bootstrap调用connect连接，ServerBootstrap调用bind开启服务 Bootstrap 只需要配置一个EventLoopGroup ,而 ServerBootstrap需要配置两个线程组EventLoopGroup ，一个用于处理连接事件，一个用于处理读写事件。 Netty的线程模型 Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。\n单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。\n多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。\n主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作\nReactor模型 建立新连接和处理读写操作分开就是Reactor模型\n详见：https://www.cnblogs.com/coding400/p/10865333.html\nNetty的执行流程 服务端 创建ServerBootStrap实例 设置并绑定Reactor线程池（线程模型）：EventLoopGroup，EventLoop可以处理所有注册到本线程的Selector上面的Channel 设置并绑定服务端的channel（IO模型） 创建处理网络事件的ChannelPipeline和handler 绑定并启动监听端口 当轮询到准备就绪的channel后，由Reactor线程：NioEventLoop执行pipline中的方法，最终调度并执行channelHandler 客户端 创建BootStrap实例 设置并绑定Reactor线程池（线程模型）：EventLoopGroup，EventLoop可以处理所有注册到本线程的Selector上面的Channel 设置并绑定服务端的channel（IO模型） 创建处理网络事件的ChannelPipeline和handler 发起连接 TCP 粘包/拆包的原因及解决方法 原因 粘包：\n应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。 接收方法不及时读取套接字缓冲区数据，这将发生粘包。 拆包：\n应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度\u0026gt;MSS的时候将发生拆包。 解决办法 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。（LengthFieldBasedFrameDecoder） 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。（FixedLengthFrameDecoder） 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。（DelimiterBasedFrameDecoder） 通过自定义协议进行粘包和拆包的处理。（MessageToByteEncoder和ByteToMessageDecoder） Netty 长连接、心跳机制 长连接 Netty的长连接其实就是TCP的长连接\nTCP 在进行读写之前，server 与 client 之间必须提前建立一个连接。建立连接的过程，需要我们常说的三次握手，释放/关闭连接的话需要四次挥手。这个过程是比较消耗网络资源并且有时间延迟的。\n所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的优点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。\n长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。\n心跳机制 在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，他们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入 心跳机制 。\n心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性.\nTCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：SO_KEEPALIVE。但是，TCP 协议层面的长连接灵活性不够。所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 IdleStateHandler 。\nNetty 的零拷贝 操作系统的零拷贝 传统意义的拷贝是在发送数据的时候， 传统的实现方式是：\n\\1. File.read(bytes)\n\\2. Socket.send(bytes)\n这种方式需要四次数据拷贝和四次上下文切换：\n\\1. 数据从磁盘读取到内核的read buffer\n\\2. 数据从内核缓冲区拷贝到用户缓冲区\n\\3. 数据从用户缓冲区拷贝到内核的socket buffer\n\\4. 数据从内核的socket buffer拷贝到网卡接口（硬件）的缓冲区\n零拷贝的概念明显上面的第二步和第三步是没有必要的，通过java的FileChannel.transferTo方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）\n\\1. 调用transferTo,数据从文件由DMA引擎拷贝到内核read buffer\n\\2. 接着DMA从内核read buffer将数据拷贝到网卡接口buffer上面的两次操作都不需要CPU参与，所以就达到了零拷贝。\nNetty 的零拷贝 Netty 的零拷贝主要包含三个方面：\nNetty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存（注意直接内存可以与内核态的缓冲区内存进行内存映射，也就是mmap）进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝（不是堆外直接内存吗）。 Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。 Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。 NIO的空轮询bug 原因 若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%\n解决方案 对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数， 若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。 重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。 Netty 高性能表现在哪些方面 **IO 线程模型：**使用IO多路复用（同步非阻塞），用最少的资源做更多的事。 **零拷贝技术：**尽量减少不必要的内存拷贝，实现了更高效率的传输。 **内存池设计：**申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 **串形化处理读写：**避免使用锁带来的性能开销。即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优（这种串形化处理读写的设计相当于每个线程都有一个任务队列，使用时不用加锁，所以性能较高）。 **高性能序列化协议：**支持 protobuf 等高性能序列化协议。 **高效并发编程：**volatile的大量使用；CAS和原子类的广泛使用。 Netty的内存池是怎么实现的 有点复杂\n首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。 Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。 当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。 五种IO模型 阻塞IO、非阻塞IO、IO多路复用、信号驱动IO，异步IO\n同步与异步、阻塞与非阻塞 同步和异步描述的是消息通信的机制。\n假如A调用B\n同步：A发送request，B返回A需要的response\n异步：A发送request，B马上返回空的response或者不返回，B操作完成后，调用A的callback或者给A发信号，将A需要的数据返回给B\n阻塞和非阻塞描述的是程序在等待调用结果（消息，返回值）时的状态。\n阻塞：阻塞调用是指调用方发出request的线程因为某种原因（如：等待系统资源）被服务方挂起，当服务方得到response后就唤醒挂起线程，并将response返回给调用方。\n非阻塞：非阻塞调用是指调用方发出request的线程在没有等到结果时不会被挂起，直到得到response后才返回。\nBIO、NIO、AIO分别是什么？ BIO（Blocking I/O）：采用阻塞式 I/O 模型，线程在等待 I/O 操作时，无法处理其他任务，适用于连接数较少且稳定的场景。\nNIO（New I/O 或 Non-blocking I/O）：使用非阻塞 I/O 模型，线程在等待 I/O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，提高性能和可伸缩性，适用于高并发场景。\nAIO（Asynchronous I/O）：采用异步 I/O 模型，线程发起 I/O 请求后立即返回，当 I/O 操作完成时通过回调函数通知线程，进一步提高了并发处理能力，适用于高吞吐量场景。\nselect、poll、epoll的机制及其区别？ 单个进程打开的文件描述符（fd文件句柄）不一致 select ：有最大连接数限制数为1024，单个进程所能打开的最大连接数由FD_ZETSIZE宏定义。\npoll：poll本质上与select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。\nepoll：虽然连接有上限，但是很大，1G内存的机器可以打开10万左右的连接，以此类推。\n监听Socket的方式不一致 select ：轮询的方式，一个一个的socket检查过去，发现有socket活跃时才进行处理，当线性socket增多时，轮询的速度将会变得很慢，造成线性造成性能下降问题。\npoll：对select稍微进行了优化，只是修改了文件描述符，但是监听socket的方式还是轮询。\nepoll：epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，通知epoll来处理这个socket。（会将连接的socket注册到epoll中, 相当于socket的花名册, 如果有一个socket活跃了, 会回调一个函数, 通知epoll,赶紧过来处理）\nselect、poll、epoll时间复杂度分别是：O(n)、O(n)、O(1)\n内存空间拷贝方式（消息传递方式）不一致 select：内核想将消息传递到用户态，需要将数据从内核态拷贝到用户态,这个过程非常的耗时\npoll：同上\nepoll：epoll的内核和用户空间共享一块内存，因此内核态数据和用户态数据是共享的\nNetty底层用的什么？ Java层面用的NIO的Selector机制，操作系统层面Linux用的epoll，Windows用的IOCP\n序列化 序列化和反序列化有什么作用 实现了数据的持久化：永久性保存对象，保存对象的字节序列到本地文件或者数据库中 序列化实现远程通信：通过序列化以字节流的形式使对象在网络中进行传递和接收 通过序列化在进程间传递对象 Serializable接口的作用 其实Serializable接口只是一个标识，序列化由ObjectInputStream和ObjectOutputStream执行，具体操作在jvm里\nSerializable和Externalizable的区别 Serializable只用来标识一个类是可序列化的，但是序列化操作是由jvm实现的，程序员不能控制，而Externalizable不但是可序列的标识（继承了Serializable），还可以自定义序列化操作（因为接口里有两个方法）\nRPC 不同序列化协议的优缺点 优点 缺点 Kryo 速度快，序列化后体积小 跨语言支持较复杂 Hessian 默认支持跨语言 较慢 Protostuff 速度快，基于protobuf 需静态编译 Protostuff-Runtime 无需静态编译，但序列化前需预先传入schema 不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值 Java 使用方便，可序列化所有类 速度慢，占空间 各种序列化协议的特点 详见：https://blog.csdn.net/qq_38685503/article/details/114633168?spm=1001.2014.3001.5501\n为什么选KRYO序列化 因为Kryo序列化速度快，序列化之后体积小\n各种序列化方式的原理 自定义的协议头里包括哪些内容 魔数、包类型，序列化方式、包长度\n负载均衡 什么是负载均衡 指将工作任务分摊到多个节点上进行运行\n比如轮询负载均衡算法，就是将任务按照节点的顺序逐个分配\n有哪些负载均衡算法 随机算法、轮询算法、最少活跃调用数、一致性哈希\n原理 **随机算法：**就是随机选择一个结点，但是有时候结点是有权重的，这时候可以把权重加起来，然后随机选择0-权重和之间的数，然后再根据这个数进行选择\n**轮询算法：**就是依次的调用所有的结点\n**最少活跃算法：**就是每个结点都维护一个计数器，每次一个请求交给它处理时，计数器加一，请求处理完毕后计数器减一，每次选择计数器最小的那个结点，如果计数器最小的结点有多个，那就随机选择一个\n**一致性Hash算法：**就是根据哈希值来确定处理请求的结点，但不是普通的取余哈希，因为取余哈希，如果添加或删除结点的话，改动会比较大，一致性hash是先创建一个环形Hash空间，然后将结点的虚拟结点（一般是ip+port+虚拟结点编号）哈希到环上，然后再把请求哈希到环上，然后根据请求哈希到环上的位置，顺时针往下找，找到的第一个虚拟结点就是要发送的结点，详见：https://www.cnblogs.com/twoheads/p/10135896.html\n优缺点 随机算法\u0026amp;轮询算法：\n优点：使用简单 缺点：不能根据当前的场景动态的改变策略 最少活跃算法：\n优点：根据服务器当前的请求处理情况，动态分配； 缺点：算法实现相对复杂，需要监控服务器请求连接数； 一致性hash算法：\n优点：当某一台提供者挂时，原本该发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动 缺点：实现复杂 负载均衡作用 根据集群中每个节点的负载情况将用户请求转发到合适的节点上, 以避免单点压力过大的问题 负载均衡可实现集群高可用及伸缩性 负载均衡如何保证健壮性 采用心跳机制检测宕机节点\nHTTP 和 RPC RPC 有没有可能会用 HTTP 协议 会，grpc就是用的HTTP协议\nHTTP vs RPC 相同点 都可以完成远程调用\n不同点 传输协议\nRPC：可以基于TCP协议，也可以基于HTTP协议。 HTTP：基于HTTP协议。 传输效率\nRPC：基于TCP可以自定义应用层协议，可以让请求报文体积更小，提高传输效率\nHTTP：如果时基于HTTP1.1的协议，请求中会包含很多无用的内容，很臃肿\n性能消耗\nRPC：序列化时可以选择二进制序列化方式\nHTTP：一般序列化都是json方式，体积和序列化耗时都比二进制序列化要更消耗性能\n负载均衡\nRPC：基本都自带了负载均衡策略\nHTTP：需要配置Nginx实现\n服务治理\nRPC：能做到自动通知，不影响上游 HTTP：需要事先通知，修改Nginx配置 使用场景 如果对效率要求更高，并且开发过程使用统一的技术栈，那么可以用RPC 如果需要更加灵活，跨语言、跨平台，HTTP更合适 服务注册中心 Nacos vs Zookeeper vs Eureka CAP理论 CAP理论是分布式架构中重要理论：\n一致性(Consistency)：所有节点在同一时间具有相同的数据； 可用性(Availability) ：保证每个请求不管成功或者失败都有响应； 分隔容忍(Partition tolerance) ：系统中任意信息的丢失或失败不会影响系统的继续运作。 CAP不最多能保证两个，不能都保证，原因不清楚\nNacos可以保证AP或者CP\n为什么选择Nacos 因为Eureka已经停止维护了，zookeeper本质上是个文件系统，使用起来比较麻烦，所以选择了Nacos\nNacos服务注册表结构是什么样的？ Nacos最外层是namespace隔离环境，然后是group对服务进行分组，然后就是服务，一个服务下 有多个集群，集群下有多个实例。 对应Java代码，Map\u0026lt;String,Map\u0026lt;String,Service\u0026gt;\u0026gt;，最外层的key是namespaceId，值是map，内部map大的key是group拼接serviceName（group@@serviceName），值是service对象； service对象内部又是一个map，key是集群名称，值是Cluster对象，Cluster对象内部维护了实例对象集合。\nNacos配置中心宕机，还能读取到配置吗 可以，客户端读取到配置信息以后会缓存在本地内存，因此可以在内存中拿到数据。\n服务提供者如何向Nacos注册中心续约 利用心跳机制，如果注册中心发现服务结点还活着就会续约\n如何确定实例状态 通过发送心跳包，5秒发送一次，如果15秒没有回应，则说明服务出现了问题， 如果30秒后没有回应，则说明服务已经停止。\n为什么要使用配置中心 因为用配置中心可以很好的管理项目配置，比如修改配置，不用每个结点都修改一次，而且用配置中心可以动态发布配置\n网络 基础 OSI 和 TCP/IP 网络分层模型 OSI 七层模型是什么？每一层的作用是什么？ TCP/IP 四层模型是什么？每一层的作用是什么？ 应用层：应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。 传输层：传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。 网络层：网络层负责为网上的不同主机之间提供通信服务。 网络接口层：可以看做是数据链路层和物理层的合体 数据链路层：数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 物理层：实现相邻计算机节点之间比特流的透明传送，尽可能向上屏蔽掉具体传输介质和物理设备的差异 为什么网络要分层？ 跟开发程序时的高内聚低耦合思想很接近\n各层之间相互独立，不需要关心其他层是怎么是实现的，只需要知道怎么调用下层提供的接口就行，大问题化小，可以降低系统的复杂度 提高了整体灵活性，每一层都可以使用最适合的技术来实现，只需要提供规范的接口就可以，比较灵活 应用层有哪些常见的协议？ HTTP、SMTP、POP3/IMAP、FTP、Telnet、SSH\nHTTP（超文本传输协议） 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的，访问网页的时候用的就是http协议。\nHTTP 协基于 TCP协议，目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。\n另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。\nSMTP（简单邮件传输(发送)协议） 基于 TCP 协议，用来发送电子邮件。\n电子邮件的发送过程？ 通过SMTP协议把邮件发送到我的邮件服务器 我的邮件服务器通过SMTP协议在互联网上发送给对方的邮件服务器 对方的邮件服务器通知对方来取，对方使用POP3协议取走 如何判断邮箱是真正存在的？ 查找邮箱域名对应的 SMTP 服务器地址 尝试与服务器建立连接 连接成功后尝试向需要验证的邮箱发送邮件 根据返回结果判定邮箱地址的真实性 POP3/IMAP（邮件接收的协议） POP3 和 IMAP 两者都是负责邮件接收的协议 SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP IMAP相当于POP3的升级版 FTP（文件传输协议） 基于 TCP 实现可靠的传输 两条tcp连接，21端口的用于控制，20端口用于传输数据 Telnet（远程登陆协议） 建立在可靠的传输协议 TCP 之上，但是传输的数据都是明文，很不安全，所以被SSH取代\nSSH（安全的网络传输协议） 建立在可靠的传输协议 TCP 之上\nTelnet 和 SSH 之间的主要区别？ SSH 协议会对传输的数据进行加密保证数据安全性。\nTCP和UDP TCP 与 UDP 的区别？（重要） 简化版：\n是否面向连接 ：TCP是面向连接的，UDP是面向无连接的\n是否是可靠传输：TCP是可靠的，UDP是不可靠的\n是否有状态 ：TCP是有状态的，比如会记录发送了那些数据，接受了哪些数据，UDP是无状态的\n传输效率 ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。\n传输形式 ： TCP 是面向字节流的，UDP 是面向报文的。\n首部开销 ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。\n是否提供广播或多播服务 ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多。\n详细版：\n是否面向连接 ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。\n是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。\n是否有状态 ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。\n传输效率 ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。\n传输形式 ： TCP 是面向字节流的，UDP 是面向报文的。\n首部开销 ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。\n是否提供广播或多播服务 ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多。\n表格版：\nTCP UDP 是否面向连接 是 否 是否可靠 是 否 是否有状态 是 否 传输效率 较慢 较快 传输形式 字节流 数据报文段 首部开销 20 ～ 60 bytes 8 bytes 是否提供广播或多播服务 否 是 什么时候选择 TCP,什么时候选 UDP? UDP 一般用于即时通信\nTCP 用于对传输准确性要求特别高的场景\nHTTP 基于 TCP 还是 UDP？ HTTP3.0之前基于TCP，3.0之后基于基于UDP的QUIC协议，目的是为了解决队头阻塞\n队头阻塞 HTTP1.1的队头阻塞是因为1.1是一问一答模式，所以当一个大的响应没回来的时候，其他请求都要等待\nHTTP2.0使用了多路复用，就是一个HTTP连接上可以同时发送多个HTTP请求，解决了1.1的队头阻塞，但是只解决了应用层的队头阻塞，传输层依然有队头阻塞，因为如果发送3个包，第一个包丢了，那么服务端为了保证有序接受就会等待直到接收到1，但是http包都是独立的，这个时候完全可以处理2和3包，这就是HTTP2.0的队头阻塞\nHTTP3.0为了解决2.0的队头阻塞使用了基于UDP的QUIC协议\n使用 TCP 的协议有哪些？ HTTP 协议 ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。\nHTTPS 协议 ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议\nFTP 协议：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。\nSMTP 协议：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。\nPOP3/IMAP 协议： POP3 和 IMAP 两者都是负责邮件接收的协议。\nTelnet 协议：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。\nSSH 协议 : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。\n使用 UDP 的协议有哪些？ DHCP 协议：动态主机配置协议，动态配置 IP 地址\nDNS ： 域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。\nTCP 三次握手和四次挥手（非常重要） 详见：https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html\n为什么要三次握手？ 三次握手的目的是建立可靠的通信信道，那三次握手是怎么建立起可靠的通信通道的呢？\n第一次握手 ：Client不能确保对方收到了自己的请求\n第二次握手 ：Server不能确保对方收到了自己的回应\n第三次握手 ：双方都能确保对方收到了自己的请求\n第2次握手传回了ACK，为什么还要传回SYN？ 回传ACK代表收到了对方的信息，回传SYN代表同意连接\n为什么要四次挥手？ 因为通信双方都能收发数据，所以必须保证两者都没有数据要发送的时候才能断开连接，那四次挥手是怎么保证的呢？\n第一次挥手 ：只能保证A没有信息发送了，但是B可能还有信息待发送\n第二次挥手 ：只是让A知道B收到了断开连接请求，但是这个时候B有可能还有信息没有发完\n第三次挥手 ：可以保证A和B都没有信息发送了，但是如果第三次挥手包丢了的话无法保证A知道B发送完了\n第四次挥手 ：可以保证A和B都没有信息发送了，并且A知道B发送完了，B也知道A接收到了自己发送完的信息\n为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？ 因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。\n如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？ 客户端没有收到 ACK 确认，会重新发送 FIN 请求。\n为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？ 防止 Server 未收到 ACK\n解释：第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。\n为什么是2*MSL呢 因为加入第四次挥手的包在第一个MSL丢失，那么重发的第三次挥手的包一定在第二个MSL到达\nTCP 如何保证传输的可靠性？ 精简版：\n基于数据块传输 ：应用数据被分割成数据块，再传输给网络层\n对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号就可以对包进行排序和去重了\n校验和 : TCP 将保持它报文的检验和。如果收到段的检验和有差错，TCP 将丢弃这个报文段\n超时重传 : 当发送方发送数据之后，如果一段时间之后没有收到这个包的回应就会重传\n流量控制 : 如果接收端来不及处理接收到的数据，就会提示发送方降低速率，起到流量控制的效果，具体是使用滑动窗口来实现的\n拥塞控制 : 当网络拥塞时，减少数据的发送。\n详细版：\n基于数据块传输 ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。\n对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。\n校验和 : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。\n超时重传 : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失open in new window并进行重传。\n流量控制 : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。\n拥塞控制 : 当网络拥塞时，减少数据的发送。\nTCP 如何实现流量控制？ TCP 利用滑动窗口实现流量控制。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n为什么需要流量控制？ 因为发送方的速率与接收方的速率是不一定相等，如果发送方的速率大于接受方的速率，就会导致接受方丢掉处理不过来的包\n滑动窗口是什么？ 就是发送端和接收端各有一个窗口，发送窗口里是可以发送的报文，接受窗口里是可以接受的报文，如果发送窗口收到回应之后就会向前滑动知道碰到没收到回应的那个窗口，接收窗口同理\n见：https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html\nTCP 如何实现拥塞控制？ 主要就是通过四个算法实现的拥塞控制：\n慢启动：当TCP开始发送数据时，它会先发送一小部分数据，然后每次乘2逐渐扩大拥塞窗口 拥塞避免：一旦慢启动进入拥塞避免阶段，那么拥塞窗口就会从每次乘2变成每次加1 快重传： 快恢复： 见：https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html\nARQ 协议是什么 就是自动重传请求协议，包括停止等待 ARQ 协议和连续 ARQ 协议。\nARQ协议也用到了滑动窗口，和流量控制里面的滑动窗口的区别是流量控制在传输层，ARQ协议在传输层和数据链路层。\n停止等待 ARQ 协议和连续 ARQ 协议的区别是什么？ 停止等待 ARQ 协议，发送并接收到确认消息才发下一个\n连续 ARQ 协议，维持一个发送窗口，可以连续发送多个数据包\nHTTP 从输入URL 到页面展示到底发生了什么？ 详见：从输入URL到页面加载发生了什么？\n浏览器从输入网址到页面展示的过程\nHTTP 状态码有哪些？ HTTP 和 HTTPS 有什么区别？（重要） 端口号 ：HTTP 默认是 80，HTTPS 默认是 443。 URL 前缀 ：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。 安全性和资源消耗 ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文。HTTPS相对于HTTP多了一层SSL加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。 HTTP 1.0 和 HTTP 1.1 有什么区别？ 默认连接方式 : HTTP 1.0 默认为短连接，HTTP 1.1 默认为长连接。 状态响应码 : HTTP/1.1中新加入了大量的状态码 缓存处理：HTTP/1.1中新加入了很多缓存头来控制缓存策略 带宽优化及网络连接的使用：HTTP1.0 中，只能发送完成的资源，而HTTP1.1里可以发送部分数据 Host头处理 : HTTP/1.1在请求头中加入了Host字段。 HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。\n1.1 vs 2.0 vs 3.0 1.1是收到上一个请求的响应后才能发送下一个请求，这样就产生了队头阻塞问题，而HTTP2.0相对于1.1可以连续发送多个请求，在应用层解决了队头阻塞，但是传输层还是有队头阻塞，3.0使用基于UDP的QUIC协议替代TCP协议解决了传输层的队头阻塞问题\nHTTP 是不保存状态的协议, 如何保存用户状态？ 使用session来保存状态，服务端为每个客户端创建一个session，然后将sessionID随响应一起发给客户端，客户端下次发请求带着这个sessionID（放在cookie中），服务端就知道是谁发送的请求了，通过这种方式能保存用户状态\nCookie 被禁用怎么办? 最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。注意URL重写指的是服务端将页面响应给客户端之前将里面的URL全部重写，加上Session ID作为参数\nURI 和 URL 的区别是什么？ URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\nURL(Uniform Resource Locator) 是统一资源定位符，不但可以唯一标识一个资源还可以定位这个资源\nURI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。\nGET和POST的区别 一般情况下GET是用来获取资源的，参数是放在URL里面，POST是用来处理资源的，参数一般放在请求体里面\nWebSocket vs HTTP TCP 协议本身是全双工的，但是HTTP协议不是全双工的，只能是客户端一问一答模式，服务端不能主动发送信息，为了解决这个问题提出了WebSocket，WebSocket是全双工的，握手阶段使用HTTP协议，握手完成后服务端可以主动发消息到客户端\nWebSocket TCP 协议本身是全双工的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是半双工的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用定时轮询或者长轮询的方式实现服务器推送(comet)的效果。 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。 WebSocket 和 socket 几乎没有任何关系，只是叫法相似。 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。 ARP 什么是 Mac 地址？ 每个网络设备都有一个标识，这个标识就是MAC地址\nMAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。\nARP 协议解决了什么问题地位如何？ ARP协议就是解决了IP到MAC地址的映射，因为我们在网络上定位一个主机用的是IP地址，但是在传输的时候需要知道下一跳的物理地址，所以就需要IP到MAC的映射\nARP 协议的工作原理？ 详见：https://javaguide.cn/cs-basics/network/arp.html\n操作系统 基础 什么是操作系统？ 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。\n操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。\n操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。\n操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。\n什么是系统调用？ 就是系统给用户提供的接口\n见：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html\n进程和线程 进程和线程的区别？ 拥有资源不同，进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度不同，线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 系统开销不同，线程是轻量级进程，在切换或者新建或者撤销的时候线程的开销比进程小 通信方面不同，线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 进程有哪几种状态？ 共5种状态：\n创建状态(new) ：进程正在被创建，尚未到就绪状态。\n就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。\n运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。\n阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。\n结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\n如图：\n进程间的通信常见的的有哪几种方式？ 大概有 7 种常见的进程间的通信方式\n管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\n有名管道(Named Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\n信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。\n信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\n共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n线程间的同步的方式有哪些呢？ 线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：\n互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。 信号量(Semaphore) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。 操作系统中进程的调度算法有哪些？ 为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：\n先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。 优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。 什么是死锁？ 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而循环等待的这种现象，若无外力作用，它们都将无法推进下去\n产生死锁的四个必要条件是什么？ 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。\n占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。\n不可剥夺：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。\n循环等待：有一组等待进程 {P0, P1, P2}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，P2 等待的资源被 P0 占有。\n怎么解决死锁？ 解决死锁的方法可以从多个角度去分析，一般的情况下，有预防，避免，检测和解除四种。\n预防 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。 避免则是系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生 检测是指系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。 解除 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来。 死锁如何预防？ 破坏 死锁产生的四个必要条件之一就可以成功 预防系统发生死锁\n见：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95\n第二种方法换成顺序资源分配法\n顺序资源分配法：首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源R;，则该进程在以后的资源申请中就只能申请编号大于 R的资源。\n死锁如何避免？ 死锁的预防会导致 低效的进程运行 和 资源使用率 。而死锁的避免相反，它的角度是允许系统中同时存在四个必要条件 ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 明智和合理的选择 ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。\n见：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95\nhttp://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81.html#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D\n死锁如何检测？ 对资源的分配加以限制可以 预防和避免 死锁的发生，但是都不利于各进程对系统资源的充分共享。解决死锁问题的另一条途径是 死锁检测和解除。这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 定时地运行一个 “死锁检测” 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。\n具体操作见王道操作系统\n死锁如何解除？ 当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：\n立即结束所有进程的执行，重新启动操作系统 ：这种方法简单，但以前所在的工作全部作废，损失很大。 撤销涉及死锁的所有进程，解除死锁后继续运行 ：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。 抢占资源 ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。 操作系统内存管理基础 操作系统的内存管理主要是做什么？ 内存的分配与回收 逻辑地址映射为物理地址 操作系统的内存管理机制了解吗？内存管理有哪几种方式？ 可以分为连续分配管理方式和非连续分配管理方式：\n连续分配管理方式就是为一个用户程序分配一个连续的内存空间，比如块式管理 非连续分配管理方式就是为一个用户程序分配内存空间不一定是连续的，比如页式管理，段式管理，段页式管理 见：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D\n注意看下流程\n快表和多级页表是什么？ 见：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D\n注意看下流程\n分页机制和分段机制有哪些共同点和区别呢？ 共同点 分页机制和分段机制都是为了提高内存利用率，减少内存碎片。 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。 区别 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。 逻辑地址和物理地址是什么？ 我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。\nCPU 寻址是什么？为什么需要虚拟地址空间？ 为什么要有虚拟地址空间呢？ 都见：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D\n和其他书籍，这个说的不是很好，可以看一下所有流程\n什么是虚拟内存？ 这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以这样呢？ 正是因为 虚拟内存 的存在，通过 虚拟内存 可以让程序拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。\n虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。\n局部性原理是什么？ 局部性原理表现在以下两个方面：\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存技术是怎么实现的？ 见：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D\n页面置换算法的作用？常见的页面置换算法有哪些？ 缺页中断时，如果当前内存已经满了就需要选择页移除内存，那么移除哪个页就是页面置换算法，有FIFO，LRU，LFU\n见：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D\nMySQL 基础 drop、delete 与 truncate 区别？ drop会把表删掉，delete和truncate不会\ndelete删除的时候有回滚日志，truncate没有\nMySQL 基础架构 连接器： 身份认证和权限相关(登录 MySQL 的时候)。\n查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。\n分析器： 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。\n优化器： 按照 MySQL 认为最优的方案去执行。\n执行器： 执行语句，然后从存储引擎返回数据。\n简单来说 MySQL 主要分为 Server 层和存储引擎层：\nServer 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。 存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。 总结：\nMySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。\n引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。\n详见：https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html#_1-2-server-%E5%B1%82%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D\n一个 SQL 语句在 MySQL 中的执行流程 查询语句的执行流程如下：连接器权限校验（如果命中缓存）\u0026mdash;\u0026gt;查询缓存\u0026mdash;\u0026gt;分析器\u0026mdash;\u0026gt;优化器\u0026mdash;\u0026gt;权限校验\u0026mdash;\u0026gt;执行器\u0026mdash;\u0026gt;引擎\n更新语句执行流程如下：连接器权限校验\u0026mdash;-\u0026gt;分析器\u0026mdash;-\u0026gt;权限校验\u0026mdash;-\u0026gt;执行器\u0026mdash;\u0026gt;引擎\u0026mdash;redo log(prepare 状态)\u0026mdash;\u0026gt;binlog\u0026mdash;\u0026gt;redo log(commit状态)\n详见：https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html#_1-2-server-%E5%B1%82%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D\nMySQL存储引擎 MyISAM 和 InnoDB 有什么区别？ MyISAM 不支持行级锁、事务、外键、MVCC，而 InnoDB 支持。 MyISAM 的索引数据与key是分开的，InnoDB是在一起的 MyISAM 不支持数据库异常崩溃后的安全恢复（redolog），而 InnoDB 支持。 InnoDB 的性能比 MyISAM 更强大。 MyISAM 和 InnoDB 如何选择？ 大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的\nMySQL日志 日志分为redo log、undo log、bin log\nredo log redo log（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力（即crash-safe）。\n刷盘时机 redo log有三种模式\n0，事务提交时，不写盘 1，事务提交时，写盘 2，事务提交时，将数据写到操作系统的page cache里，等待操作系统的fsync 注意page cache之上还有一个redo log buffer，用来存储需要写盘的redo log\n除了事务提交时写盘，redo log还有一个后台线程每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。\n日志文件组 日志文件共4个，循环在一起，如下图所示：\n有两个指针，write pos表示目前redo log写到哪了，checkpoint表示目前把redo log里的东西哪些写到数据库了\n有功夫刷redo log，为什么不直接刷数据？ 因为redo log是连续访问并且数据量小，刷写速度快，直接刷数据，是随机访问并且数据量大，刷写速度慢\nbinlog redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。\n而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。\n不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。\n那 binlog 到底是用来干嘛的？\n可以说MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。\n记录格式 binlog记录格式有三种\nstatement，sql语句原文 row，会将now()等函数换成具体的时间 mixed，上述两个东西的混合 写入机制 binlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。\n两阶段提交 redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。\nbinlog（归档日志）保证了MySQL集群架构的数据一致性。\n两者的写时机不一样，redo log是事务执行的同时就会写，binlog事务执行完毕才会写，那么有可能出现不一致的情况，为了解决这个问题提出了两阶段提交方案\n原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是两阶段提交，如下所示\nundo log 就是记录之前的版本的集合，用链表的结构串起来，也是MVCC的基础之一\n有很多考点\n详见：https://javaguide.cn/database/mysql/mysql-logs.html\n为什么需要undo log 实现事务回滚，保障事务的原子性 实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据 为什么需要redo log 实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失； 将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能。因为写数据时先写redo log，以后有时间再写入数据库 redo log 和 undo log 区别 redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值； undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值； redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？ 因为redo log是连续访问并且数据量小，刷写速度快，直接刷数据，是随机访问并且数据量大，刷写速度慢\nredo log 什么时候刷盘 刷盘策略有一个参数：\n0 ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作，只写到redo log buffer\n1 ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）\n2 ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache\n除此之外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。\nredo log 文件写满了怎么办 因为redo log的日志文件组是循环写，如果 write pos 追上了 checkpoint，就意味着 redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞\n为什么需要 binlog 因为需要做数据备份或者主从复制\nredo log 和 binlog 有什么区别 **层级不同：**redo log处于引擎层，binlog处于server层 **文件格式不同：**binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，redo log 是物理日志，记录的是在某个数据页做了什么修改 **写入方式不同：**binlog 是追加写，写满一个文件，就创建一个新的文件继续写，redo log 是循环写 **用途不同：**binlog 用于备份恢复、主从复制，redo log 用于掉电等故障恢复。 能使用 redo log 文件恢复数据吗 不能，因为redo log是会覆盖的\nbinlog 什么时候刷盘 sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘； sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync； sync_binlog =N(N\u0026gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。 update 语句的执行过程 具体更新一条记录 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 的流程如下:\n执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录： 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新； 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。 执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样： 如果一样的话就不进行后续更新流程； 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作； 开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。 InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。 至此，一条记录更新完了。 在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。 事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）： prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘； commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）； 至此，一条更新语句执行完成。 数据是什么时候刷新进硬盘的 脏页被写入到磁盘的时候数据才真正被写进磁盘了，脏页被写入磁盘有四种情况：\nredo log满了，此时停止所有更新操作，根据redo log将buffer pool里的脏页刷新到硬盘，然后checkpoint向后移动 buffer pool已经满了，需要淘汰数据页时，如果淘汰的数据页是脏页就会刷新到硬盘 系统空闲时也会刷盘 Mysql关闭时会将buffer pool的所有脏页刷新到硬盘 为什么需要两阶段提交 因为redo log 和 binlog的写盘的独立的，有可能出现一个写入了，一个没写入的情况，redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决，两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」\n两阶段提交的过程是怎样的 两阶段提交中异常重启会出现什么现象 记住异常重启之后以binlog的为准\nMySQL 索引 索引是什么 索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引的作用就相当于书的目录。MySQL一般使用B+树\n理解 就是B+树，用来加速查找过程的，主键会自动建一个索引，也可以手动建索引，但是非主键索引是非聚簇索引，需要回表再查一次主键索引，为了避免回表，产生了覆盖索引，覆盖索引就是索引里的key包含了要查询的字段，联合索引符合最左前缀匹配原则\nMyISAM的索引都是非聚簇索引，但是叶子节点的存的不是主键而是数据的指针，而InnoDB的非聚簇索引存的主键\n索引的分类 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。 按「字段个数」分类：单列索引、联合索引。 聚簇索引可以是哪些列生成 如果有主键，默认会使用主键作为聚簇索引的索引键（key） 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key） 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key） B+树 vs B树 B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以B树非叶子节点的指针少，那么树就会变高，树变高了就会增加磁盘IO次数，性能比B+树低 B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点 B+树 vs 二叉树 B+树由于一个结点里存的数据多，所以比二叉树矮，所以磁盘IO次数少\nB+树 vs Hash索引 Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。\n但是 Hash 表不适合做范围查询，它更适合做等值的查询\n联合索引的最左匹配原则 如果不满足最左匹配原则的话，索引会失效，因为除了最左边的索引，其他索引都不是全局有序的，需要注意的是where后面条件因为有优化器的存在，即使最左边的字段没有放在最左边也会优化到最左边\n联合索引的最左匹配原则，在遇到范围查询（如 \u0026gt;、\u0026lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 \u0026gt;=、\u0026lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配\n索引下推优化 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数\n索引的缺点 占用物理空间 维护和创建索引需要时间，会降低增删改的性能 什么时候适用索引 字段有唯一性限制的 经常用于 WHERE 查询条件的字段 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了 什么时候不适用索引 WHERE 条件，GROUP BY，ORDER BY 里用不到的字段 字段中存在大量重复数据，不需要创建索引，比如性别字段 表数据太少的时候，不需要创建索引； 经常更新的字段不用创建索引，因为维护索引是会影响数据库性能的。 优化索引的方法 前缀索引优化 覆盖索引优化 主键索引最好是自增的 防止索引失效 索引失效的几种情况 当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效； 当我们在查询条件中对索引列使用函数，就会导致索引失效。 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。 索引设计 MySQL事务 事务就是为了处理并发请求时保持数据一致性提出的解决方案，一般用ACID性质来判断事务隔离的等级\n并发事务会带来脏读、丢失修改、不可重复读、幻读等问题\n为了解决这些问题，提出了4个事务隔离级别，分别解决一个问题（实际上mysql的可重复读级别能解决幻读问题），事务隔离是通过锁和MVCC来实现的\n有很多考点\n详见：https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E4%BA%8B%E5%8A%A1\n事务有哪些特性？ 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成 一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态 隔离性（Isolation）：隔离性可以防止并发事务由于交叉执行而导致数据的不一致 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 InnoDB如何保证四个特性 持久性是通过 redo log （重做日志）来保证的； 原子性是通过 undo log（回滚日志） 来保证的； 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的； 一致性则是通过持久性+原子性+隔离性来保证； 并行事务会引发什么问题 MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。\n那么在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。\nMySQL事务隔离级别 为了解决事务并发带来的问题，提出了4个事务隔离级别：\n读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到； 读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到，可以解决脏读问题 可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别，可以解决不可重复读问题 串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行，可以解决幻读问题 mysql的RR级别能在一定程度上解决幻读问题，快照读用MVCC解决，当前读用临键锁来解决\n注意真正解决幻读问题必须用锁，因为快照读的情况下可以使用MVCC解决，当前读的情况下必须加临键锁解决\n快照读（一致性非锁定读），使用MVCC机制，读取快照 当前读（一致性锁定读），使用锁机制，加S锁或者X锁，读取最新数据 有很多考点\n详见：https://javaguide.cn/database/mysql/transaction-isolation-level.html\nMVCC MVCC即多版本并发控制，就是事务并发的时候保留记录的多个版本，以实现事务的各个隔离等级\n数据库并发的时候有三种情况，读读，读写，写写，读读不用管，写写加乐观锁或者悲观锁即可，那么读写呢？\n读写最开始是用加锁的方式解决的，但是加锁效率太低，所以进入了MVCC来解决读写问题，使读写的时候不需要阻塞\nMVCC依赖于记录的隐藏字段、undolog、readview来实现的：\n隐藏字段：包括隐含的自增ID、最近修改(修改/插入)事务ID、回滚指针、删除flag undolog：就是记录的多个版本组成的链表 readview：就是一个结构体，里面包含未提交的事务id、未提交事务id的最小的id、readview生成时最大的事务id+1 MVCC是怎么实现快照功能的 所以MVCC的流程就是第一次读取的时候生成一个readview，然后以后每次读取的时候都走这个生成的readview，具体流程就是，看读取记录隐藏字段的最后修改事务id是否大于readview生成时的最大事务id，或者最后修改事务id在生成readview时没有提交，这两种情况需要从undolog里找，否则直接读即可\n根据这个流程，每次读取都必定读取到第一次读取时的结果，所以可以把readview看成一个快照，所以这时候的读称为快照读\n基于MVCC就可以解决不可重复读和在一定程度上解决幻读问题，实现RR（可重复读）隔离等级\n注意RC隔离级别也会使用MVCC，但是和RR级别生成readview的时机不一样，RC级别每次都都会生成readview，RR级别只有第一次读会生成\n有很多考点\n详见：https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html\n数据库事务并发控制 在数据库系统领域，并发控制机制主要有两种，即锁和多版本机制。\n1.事务在加锁时有多种方式：\n一次性锁协议，事务开始时，即一次性申请所有的锁，之后不会再申请任何锁，如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，在事务尾端，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。\n两阶段锁协议，整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。\n2.多版本机制：\n锁是针对集中式数据管理设计的，缺点是降低了事务的并发，并且锁本身有开销。在分布式系统，尤其是读多写少的系统中，采用多版本机制更合适。每个数据项都有多个副本，每个副本都有一个时间戳，根据多版本并发控制协议(MVCC)维护各个版本。\nMySQL锁 有几种锁呢？\n按照锁的粒度划分：行锁、表锁 按照锁的使用方式划分：共享锁、排它锁(悲观锁的一种实现) 还有两种思想上的锁：悲观锁、乐观锁。 InnoDB中有几种行级锁类型：Record Lock、Gap Lock、Next-key Lock 一种特殊的锁，意向锁 行锁和表锁 一个锁行一个锁表，注意行级锁是锁索引的，所以如果加锁查询中where条件中字段索引失效的话就会全表扫描，导致全表上锁，然后过滤之后再解锁，而且如果查询字段是一个非聚簇索引，那么就会对该非聚簇索引和聚簇索引相应的记录都加锁，而且如果字段命中的是普通索引，会使用临键锁类型的行锁，因为普通索引会有相同的key，为了保证查询范围内的记录都不能更改（为了防止幻读），所以都得加锁，所以会使用临键锁类型的行锁\n共享锁和排他锁 排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。\n悲观锁和乐观锁 是思想上的东西，mysql里没有具体的实现，乐观锁读取时不加锁，写入时判断版本时候已经更新，悲观锁读取时即加锁\nRecord Lock和Gap Lock和Next-key Lock Record Lock只对记录加锁，Gap Lock对间隙加锁，Next-key Lock对记录和间隙加锁，主要是为了解决幻读问题的\n至于到底加什么样的锁，主要看加什么样的锁能保证不会出现幻读问题，比如查询条件是唯一索引的列==一个具体的值，那么只需要对这条记录加锁（其实是对索引加锁）就可以了，但是如果是普通索引或者范围查找的话，就需要加临键锁了\n意向锁 如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。\n意向锁是表级锁，共有两种：\n意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。 意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。 意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。\n意向锁之间是互相兼容的。\nIS 锁 IX 锁 IS 锁 兼容 兼容 IX 锁 兼容 兼容 意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。\nIS 锁 IX 锁 S 锁 兼容 互斥 X 锁 互斥 互斥 有很多考点\n详见：https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81\nhttps://ost.51cto.com/posts/11812\nMySQL优化 读写分离 https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB\n分库分表 https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8\nMySQL执行计划 有三个比较重要的字段：\ntype：查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system \u0026gt; const \u0026gt; eq_ref \u0026gt; ref \u0026gt; fulltext \u0026gt; ref_or_null \u0026gt; index_merge \u0026gt; unique_subquery \u0026gt; index_subquery \u0026gt; range \u0026gt; index \u0026gt; ALL key：使用到的索引列 Extra：这列包含了 MySQL 解析查询的额外信息，如下所示 Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。 Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。 Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。 Using index condition：表示查询优化器选择使用了索引条件下推这个特性。 Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。 Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。 详见：https://javaguide.cn/database/mysql/mysql-query-execution-plan.html\n慢SQL 可以通过慢查询日志查找慢sql\n导致慢sql的原因有以下几种：\n未加索引或索引失效或选错了索引，具体排查可以用explain命令查看有没有走索引，如果走了索引说明是走错索引了，有如下三种解决方案，如果没走索引就得加索引，如果已经加了索引那就说明索引失效了，具体索引失效的情况见上方。\n使用强制索引：force index 重写 SQL，引导它使用我们期望的索引 新建一个更合适的索引 limit 深分页，深分页会导致扫描很多行，扫描很多行也导致回表很多次，所以导致了慢SQL，有以下两种解决方案：\n通过子查询优化，先找到需要的行的id，再通过id查询聚簇索引减少回表次数（使用in） 通过内连接延迟关联，先找到需要的行的id，再通过id与原表内连接（这时会走id的索引）减少回表次数 单表数据量太大，三层B+树最多保存2000w行数据，如果超过2000w行数据，B+树就会变成四层，由于树变高了，那IO次数就会变高，IO次数变多了，性能就会下降，解决方案如下：\n历史数据归档，就是把哪些不常访问的数据放到归档库里去，比如三年前的订单 分库分表，具体见上方 join或者子查询过多，由于join和子查询出产生临时表，性能太低，导致慢sql，解决方案为：可以在应用层完成join和子查询\nin元素过多，可以分批查询\n数据库在刷新脏页，redo log满了或者一个查询要淘汰多个脏页都会导致刷新脏页\norder by触发文件排序，order by一般在sort_buffer里排序，如果排序的数据大小超过了buffer的限制，就会触发文件排序，可以使用explain命令看一下，如果Extra列显示Using filesort，则使用了文件排序，解决方案有两个：\n对order by的字段建立索引 调整sort_buffer的大小 等待锁，需要等待锁的释放，这种情况可以使用show processlist命令查看语句处于什么状态\ndelete + in子查询不走索引\ngroup by 使用临时表和文件排序，由于group by会使用临时表，如果临时表过大会使用磁盘临时表，group by还默认排序，如果排序的数据量过大也会使用文件排序，解决方案有个：\norder by null禁用排序\ngroup by 后面的字段加索引，这样就不会使用到临时表了\nsql编写时注意临时表不要太大，避免使用磁盘临时表\n参考资料：\n对线面试官：12个MySQL慢查询的原因分析 | Laravel China 社区 (learnku.com)\n[10 MySQL为什么有时候会选错索引？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/MySQL实战45讲/10 MySQL为什么有时候会选错索引？.md)\n实战！聊聊如何解决MySQL深分页问题 - 掘金 (juejin.cn)\n长文图解：单张表数据量太大问题怎么解决？请记住这六个字 - 掘金 (juejin.cn)\nMySQL整体流程 mysql默认隔离等级是RR，需要解决不可重复读和幻读的问题，如果是普通的select，那么由于MVCC机制就可以解决这个问题，这种读就是快照读，如果是带锁的select，就是当前读，带锁的select如果加记录锁可以解决不可重复读的问题，但是不能解决幻读的问题，为了解决幻读问题，需要用到临键锁（记录锁+间隙锁），所以通过MVCC和加锁可以让mysql在RR等级下解决幻读问题，而且如果where条件没有命中索引的话，需要全表扫描，也就会全表加锁（临键锁），如果where条件没有命中唯一索引或者查询的是个范围的话，会加临键锁，如果where条件命中唯一索引且只查找具体的记录的话，只加记录锁（更一般的说，只要是需要加锁的操作，都是这个模式）\nRedis 直接看小林coding吧\n数据结构 Redis 数据类型以及使用场景分别是什么？ Redis有5种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。\nRedis 五种数据类型的应用场景：\nString 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。 List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。 Hash 类型：缓存对象、购物车等。 Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。 Zset 类型：排序场景，比如排行榜、电话和姓名排序等。 五种常见的 Redis 数据类型是怎么实现？ String 类型 底层使用SDS数据结构，相当于封装好的字符串类型\nList 类型 底层使用压缩列表或者双向链表，数据量小的时候使用压缩列表，不过新版本已经全部换成quicklist了\nHash 类型 底层使用压缩列表或者哈希表，数据量小的时候使用压缩列表，不过新版本压缩列表已经废弃了，换成listpack了\nSet 类型 底层使用哈希表或者整数集合，如果数据都是整数并且数据量较小的话就用整数集合，否则用哈希表\nZSet 类型 底层使用压缩列表或者跳表，数据量小的时候使用压缩列表，不过新版本压缩列表已经废弃了，换成listpack了\n数据结构 SDS 看图\n压缩列表 zlbytes：占用的字节数\nzltail：尾结点的偏移量\nzllen：结点的个数\nzlend：结束的标识符，0xFF\nprevlen：前一个结点的长度，为了实现从后向前遍历\nencoding：当前结点的类型和长度\ndata：当前结点的真实数据\n会发生连锁反应，因为压缩列表在内存中是连续的，一个结点如果修改了之后变大了，那么后一个结点的prevlen就有可能从1字节变成5字节，这样就会导致后面节点变大了，后面节点变大了又会导致后面后面的结点变大了，以此类推\n双向链表 就是很正常的双向链表，看图\n哈希表 跟Java的map一样都是链地址法，dict里的两个ht是用来rehash的，为什么要rehash？因为随着数据量的增加，哈希桶不变的情况下，hash碰撞会越来越多，链表也越来越长，所以要适当增加哈希桶，那么就需要rehash，先在ht[1]里rehash，然后交换ht[0]和ht[1]，但是rehash阻塞太久了，所以可以采用渐进式rehash，就是redis增删改查的时候顺便给操作的元素rehash了，只要时间足够久，就能把元素全部rehash到另一个表上\n整数集合 整数集合就是整数数组，有时候整数数组的元素类型是int，但是传进来一个long，那么就需要升级，升级的操作就是先开辟一个2倍空间的数组，然后将原元素均匀的分布在新数组上\n跳表 普通链表查询只能从左往右找一遍，但是跳表是有顺序的，可以直接从最高层找，这样就可以加快查找速度\n为什么用跳表而不用平衡树？范围查找方便、内存占用少、算法实现简单\nquicklist 融合了双向链表和压缩列表\n线程模型 redis是单线程IO多路复用\nRedis 采用单线程为什么还这么快？ Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构 Redis 采用单线程模型可以避免了多线程之间的竞争 Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求 持久化 为了实现数据不丢失，所以redis需要持久化\nAOF 就是把命令存到AOF文件里\n流程：\n三种写回策略：\n如果AOF过大就会重写，重写的原理就是读取内存的数据，然后写到新的AOF文件里，但是这样会阻塞很久，所以有了后台重写的方案，就是开一个子进程，子进程和父进程的页表一样，所以指向同一块内存，由于写时复制技术，当一个进程修改内存时，会把该内存复制一份，所以就好像两个进程各自有一块内存，那么子进程就可以读取此时的内存并写入AOF文件中，但是注意这时候的子进程的内存是个快照，在写入AOF文件的时候，主进程依然在接受命令，所以将这些命令存到AOF重写缓冲区中，等子进程重写完AOF就把这个缓冲区的命令加到AOF文件里面，这样就保证了新AOF文件和内存数据的一致性\nAOF 日志过大，会触发什么机制？ 会触发重写机制，会把内存里的数据用命令表示一遍，然后把这些命令写入AOF文件\nAOF重写流程 主进程就会创建重写 AOF 的子进程 重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到新的 AOF 文件 重写过程中，主进程依然可以正常处理命令，如果主进程修改数据会发生写时复制技术，并且会出现内存数据与新AOF文件数据不一致的情况，所以需要AOF 重写缓冲区，这个缓冲区在存储从开始重写的写命令，当子进程完成 AOF 重写工作后再把这个缓冲区的内容写到AOF文件后面 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件 RDB 就是把当前的内存全量复制到RDB文件里\n也是用到了写时复制技术，所以写到RDB文件里的实际上是快照\n混合持久化 由于RDB恢复速度快，但是如果发生意外丢失的数据比较多\nAOF发生意外丢失的数据少，但是恢复速度慢，所以出现了混合持久化的方案\n就是AOF文件重写的时候，先将内存数据以RDB的方式保存到AOF文件，然后追加命令像普通的AOF方式一样\n优点：\n混合持久化结合了 RDB 和 AOF 持久化的优点，恢复速度快，如果发生意外丢失的数据少 缺点：\nAOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差； 兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。 集群 集群就是多个redis节点统一提供服务，哨兵就是如果主节点挂了那就由哨兵选出来一个新的主节点，内容比较碎，直接看：\nhttps://www.xiaolincoding.com/redis/cluster/sentinel.html\nhttps://www.xiaolincoding.com/redis/cluster/master_slave_replication.html\nRedis 如何实现服务高可用 主从复制 哨兵模式 主从复制 主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。\n主从服务器之间的命令复制是异步进行的\n并且主服务器不会等待从服务器执行完毕之后再返回响应给客户端，所以从服务器接收到主服务器的写命令之前，是存在数据不一致的现象的\n哨兵模式 在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。\n为了解决这个问题，Redis 增加了哨兵模式（Redis Sentinel），因为哨兵模式做到了可以监控主从服务器，并且提供主从节点故障转移的功能。\n集群脑裂导致数据丢失怎么办 脑裂问题是什么 由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。\n解决方案 当主节点发现从节点下线或者通信超时的总数量大于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。\n出现主节点网络不通畅的时候原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了。\n等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。\n过期删除与内存淘汰 过期删除是删除过期的键值对，内存淘汰是，内存满了，怎么把一些淘汰掉即使这些键值对没有过期\n过期删除 有三种策略：\n定时删除：设置key的时候就设置一个定时删除事件 惰性删除：不主动删除，每次访问键值对的时候，如果过期了就删除 定期删除：每隔一段时间随机选出来一定数量的key删除 redis使用的惰性删除+定期删除\n内存淘汰 常用的有两种：\nlru：淘汰最久未使用的键值 lfu：淘汰最少使用的键值 Redis 持久化时，对过期键会如何处理 RDB RDB 文件生成阶段：过期的键「不会」被保存到新的 RDB 文件中 RDB 加载阶段：如果是主服务器的话，过期键「不会」被载入到数据库中，如果是从服务器的话，过期键「会」被载入到数据库中，因为反正以后数据同步的时候会清空 AOF AOF 文件写入阶段：如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。 AOF 重写阶段：已过期的键不会被保存到重写后的 AOF 文件中 Redis 主从模式中，对过期键会如何处理 从库不会进行过期扫描，从库对过期的处理是被动的，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库\nLRU vs LFU lru：淘汰整个键值中最久未使用的键值 lfu：淘汰整个键值中最少使用的键值 缓存 缓存雪崩、击穿、穿透 雪崩 击穿 穿透 如何避免缓存雪崩 将缓存失效时间随机打散 设置缓存不过期，我们可以通过后台服务来更新缓存数据 如何避免缓存击穿 互斥锁方案，保证同一时间只有一个业务线程请求缓存 不给热点数据设置过期时间，由后台异步更新缓存 如何避免缓存穿透 限制非法请求 设置空值或者默认值：当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值 使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在 什么是布隆过滤器 布隆过滤器可以快速判断数据是否存在\n具体原理：布隆过滤器由位图数组和哈希函数组成，写入数据的时候，将该数据哈希映射后在位图数组中的位置做个标记，那么如果之后查询到数据对应的位置如果没有标记说明一定不存在，如果有标记则不一定存在。\nps：哈希函数有多个\n数据库和缓存如何保证一致性？ 先更新数据库，再删除缓存，因为比如是先删除缓存，再更新数据库的话，可能还没更新数据库呢，缓存就被另一个线程给填上了\n具体原因看：https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html\n缓存更新策略 Cache Aside（旁路缓存）策略：Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。 Read/Write Through（读穿 / 写穿）策略：Read/Write Through（读穿 / 写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。 Write Back（写回）策略：Write Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。 实战 实现延迟队列 看小林coding\n大key怎么删除 先查找大key，可以用\nredis-cli \u0026ndash;bigkeys 查找大key 使用 SCAN 命令查找大 key 使用 RdbTools 工具查找大 key 然后删除，可以用\n分批次删除 unlink异步删除 Redis 管道有什么用？ 可以一次发送多条指令\nRedis 事务支持回滚吗？ 不支持\n如何用 Redis 实现分布式锁的？ 分布式锁就是分布式的应用访问同一个资源的锁，对于多个应用，加锁方式是在redis里面设置一个值，添加NX参数，这个字段说明这个值必须不存在才能添加成功，那么谁能添加值成功，谁就拿到了分布式锁\n**问题1：**客户端拿到锁后发生异常，导致锁一直无法释放，需要设置过期时间，添加EX/PX参数即可，但是很难设置一个合理的过期时间，所以可以开启一个守护线程定时续约，等任务执行完就停止续约\n**问题2：**在释放锁时，出现误释放操作，使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端，释放锁的时候，我们要先判断锁的 value 是否为加锁客户端，是的话，才将锁删除。因为是两个操作，所以可以使用lua脚本保证原子性\n优点：\n性能高效 实现方便 可以避免单点故障 缺点：\n超时时间不好设置 Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性 ps：解决分布式锁的不可靠性可以使用redlock算法，是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\nredlock算法能保证分布式锁的可靠性的原因是：不过有没有结点故障，最多只有一个能获得锁（因为只有一个能获取半数以上的锁）。\n加锁时统计加锁用了多长时间，如果超过了锁的过期时间那就是加锁失败，否则就是加锁成功。\n释放锁和单节点一样，只不过需要对所有 Redis 节点发起释放锁的操作。\nJava 基础 抽象类和接口的区别 分为两个层面：\n语法层面上：\n抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract 方法； 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的； 接口中不能含有静态代码块，而抽象类可以有静态代码块； 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 设计层面上：\n抽象类是对事物整体的抽象，子类和抽象类是is-a的关系，接口是对行为或能力的抽象。 抽象类是模板式设计，接口是规范，是一种辐射类设计，抽象类是模板所以如果抽象类更改之后子类不一定需要更改，而接口是行为规范，接口发生了更改的话实现这个接口的类都需要更改。 详见：https://javabetter.cn/oo/abstract-vs-interface.html\n未看 https://javaguide.cn/java/basis/unsafe.html\nhttps://javaguide.cn/java/basis/spi.html\nhttps://javaguide.cn/java/basis/syntactic-sugar.html\nhttps://javaguide.cn/java/collection/concurrent-hash-map-source-code.html\nhttps://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html\n并发 线程生命周期 NEW: 初始状态，线程被创建出来但没有被调用 start() 。\nRUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。\nBLOCKED ：阻塞状态，需要等待锁释放。\nWAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。\nTIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。\nTERMINATED：终止状态，表示该线程已经运行完毕。\njoin()和sleep()方法会进入WAITING或者TIME_WAITING状态，IO操作Java线程的状态是RUNNABLE，操作系统的状态是Sleep\n创建线程的三种方式的对比 采用实现Runnable. Callable接口的方式创建多线程 优势是：\n线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。\n在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU. 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。\n劣势是：\n编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。\n使用继承Thread类的方式创建多线程 优势是：\n编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。\n劣势是：\n线程类已经继承了Thread类，所以不能再继承其他父类。\nRunnable和Callable的区别 Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。 Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。 Call方法可以抛出异常，run方法不可以。 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 sleep() 方法和 wait() 方法对比 共同点 ：两者都可以暂停线程的执行。\n区别 ：\nsleep() 方法没有释放锁，而 wait() 方法释放了锁 。 wait() 通常被用于线程间交互/通信，sleep()通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。 sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。为什么这样设计呢？ wait()和notify() 在synchronized内部可以调用wait()使线程进入等待状态； 必须在已获得的锁对象上调用wait()方法； 在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程； 必须在已获得的锁对象上调用notify()或notifyAll()方法；TODO 为什么？ 已唤醒的线程还需要重新获得锁后才能继续执行。 volatile的作用和原理 volatile的两层语义：\nvolatile保证变量对所有线程的可见性：当volatile变量被修改，会立即刷新主存里的值，并且使得其他线程共享的该volatile变量无效化，所以每个线程都可以获得最新的值。 jdk1.5以后volatile完全避免了指令重排优化，实现了有序性。 volatile的原理:\nvolatile多加了lock addl指令，这个操作相当于一个内存屏障，使得lock指令后的指令不能重排序到内存屏障前的位置。这也是为什么JDK1.5以后可以使用双锁检测实现单例模式。\nlock前缀的另一层意义是使得本线程工作内存中的volatile变量值立即写入到主内存中，并且使得其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。\nCAS是什么 CAS：全称 Compare and swap，即比较并交换。当变量值等于预期值的时候才更新变量值，否则不会执行任何操作，CAS是一种原子操作，执行过程中不会被打断\nCAS的缺陷 1. ABA 问题\n并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。\n可以通过AtomicStampedReference解决ABA问题，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。\n2. 循环时间长开销\n自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。\n很多时候，CAS思想体现，是有个自旋次数的，就是为了避开这个耗时问题~\n3. 只能保证一个变量的原子操作。\nCAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。\n可以通过这两个方式解决这个问题：\n使用互斥锁来保证原子性； 将多个变量封装成对象，通过AtomicReference来保证原子性。 Synchronized的作用 原子性：确保线程互斥的访问同步代码； 可见性：保证共享变量的修改能够及时可见，因为在加锁和解锁的时候都会更新为最新变量的值 有序性：可有效解决重排序问题 synchronized 底层实现原理 synchronized 同步代码块的实现是通过 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。\n其内部包含一个计数器，当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止\nsynchronized 锁升级 synchronized 和 volatile 的区别是什么 synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！\nvolatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 ReentrantLock是什么 ReetrantLock是一个可重入的独占锁，主要有两个特性，一个是支持公平锁和非公平锁，一个是可重入。 ReetrantLock实现依赖于AQS(AbstractQueuedSynchronizer)。\nReetrantLock主要依靠AQS维护一个阻塞队列，多个线程对加锁时，失败则会进入阻塞队列。等待唤醒，重新尝试加锁。\nsynchronized 和 ReentrantLock 的联系与区别 相同点：\n两者都是可重入锁 不同点：\nsynchronized 依赖于 JVM 而 ReentrantLock 依赖于 API ReentrantLock 比 synchronized 增加了一些高级功能： 等待可中断 可实现公平锁（synchronized 是非公平锁） 可实现选择性通知（锁可以绑定多个条件） ReadWriteLock是什么 首先ReentrantLock某些时候有局限，如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。\n因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能\nThreadLocal是什么 ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。\n原理 ThreadLocal里面每个线程都有一个Map，Map的key就是threadLocal对象本身，value是副本对象\n内存泄漏问题 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\n这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法\nexecute()和submit()的区别 execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否 submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功 线程池核心参数 corePoolSize ： 核心线程大小。线程池一直运行，核心线程就不会停止。\nmaximumPoolSize ：线程池最大线程数量。非核心线程数量=maximumPoolSize-corePoolSize\nkeepAliveTime ：非核心线程的心跳时间。如果非核心线程在keepAliveTime内没有运行任务，非核心线程会消亡。\nworkQueue ：阻塞队列。ArrayBlockingQueue，LinkedBlockingQueue等，用来存放线程任务。\ndefaultHandler ：饱和策略。ThreadPoolExecutor类中一共有4种饱和策略。通过实现\nRejectedExecutionHandler\n接口。\nAbortPolicy ： 线程任务丢弃报错。默认饱和策略。 DiscardPolicy ： 线程任务直接丢弃不报错。 DiscardOldestPolicy ： 将workQueue队首任务丢弃，将最新线程任务重新加入队列执行。 CallerRunsPolicy ：线程池之外的线程直接调用run方法执行。 ThreadFactory ：线程工厂。新建线程工厂。\n线程池执行任务的流程 常用的JAVA线程池有哪几种 newCachedThreadPool newFixedThreadPool newSingleThreadExecutor newScheduleThreadPool 线程池常用的阻塞队列有哪些 如何合理配置线程池线程数 CPU密集型：corePoolSize = CPU核数 + 1\nIO密集型：corePoolSize = CPU核数 * 2\nAtomic 原子类是什么 就是操作都是原子操作的类\n原理 AtomicInteger 类主要利用 CAS和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\nAQS JVM 参考资料：\nhttps://javabetter.cn/jvm/zongjie.html\nJava内存区域详解（重点） | JavaGuide(Java面试 + 学习指南)\nJava内存区域 JDK7及之前：\nJDK8及之后：\n程序计数器：当前线程所执行的字节码的行号指示器 Java虚拟机栈：线程每调用一个方法，就会把这个方法的变量和其他信息封装成一个栈帧，放到Java虚拟机栈里面 本地方法栈：和Java虚拟机栈类似，只不过这里是调用的本地方法 堆：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存 方法区（元空间）：存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据 直接内存：在本地内存上分配的内存 堆空间的基本结构 内存分配原则 对象优先在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。Minor GC会把存活的对象放到Survivor 1区，然后继续在Eden区分配对象，如果当前存活的对象大于S1区的空间，通过分配担保机制，会把当前存活的对象放到老年代里去，新生代对象进入老年代有四种情况：\nMinor GC时存活对象大于S1区的空间，通过分配担保机制，当前存活的对象会进入老年代 大对象会直接进入老年代 在新生代中经过15次Minor GC（长期存活）的对象会进入老年代 新生代存活对象中相同年龄的对象占用空间之和如果大于S区的50%，大于等于该年龄的对象都会进入老年代 内存回收原则 GC种类 Minor GC/Young GC：只对新生代进行垃圾收集 Major GC/Old GC：只对老年代进行垃圾收集 Full GC：收集整个 Java 堆和方法区 所有GC都需要Stop The World\n内存回收的是死亡对象，所以第一步要判断哪些对象是死亡对象\n死亡对象判断方法 引用计数法 每个Java对象都保存一个计数器，代表该Java对象的引用个数，引用为零则代表该对象已死亡，但是会用循环依赖问题，所以没有使用这种方法\n可达性分析算法 通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，能到达的对象都是存活着的，不能到达的对象都是死亡的，需要回收，可以作为GC Roots的对象有：\n虚拟机栈(栈帧中的局部变量表)中引用的对象 本地方法栈(Native 方法)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 所有被同步锁持有的对象 JNI（Java Native Interface）引用的对象 ps：死亡的对象不一定都被回收，因为在回收之前要调用finalize方法，如果finalize方法里又把该对象和GC Roots关联起来了，那么就不会回收\n四种引用类型 强引用：如果对象有强引用，那么不会回收他 软引用：如果对象只有软引用，那么这个对象可有可无，在内存不足的的时候会回收它 弱引用：如果对象只有弱引用，那么这个对象可有可无，在内存充足的的时候也会回收它 虚引用：如果对象只有弱引用，那就跟没有引用一样 垃圾回收算法 标记-清除算法 有两个问题：\n效率问题：标记和清除两个过程效率都不高。 空间问题：标记清除后会产生大量不连续的内存碎片。 复制算法 有两个问题：\n可用内存变小：可用内存缩小为原来的一半。 复制占用性能：如果存活对象数量比较大，复制性能会变得很差。 标记-整理算法 有一个问题：\n多了整理这一步，性能变低 分代收集算法 根据对象存活周期的不同将内存分为几个区域，我们可以根据各个区域的特点选择合适的垃圾收集算法。\n垃圾收集器 Serial 收集器 单线程 垃圾收集时必须STW 新生代采用标记-复制算法，老年代采用标记-整理算法 G1 收集器 并行与并发 分代收集 空间整合，从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的 可预测的停顿，能让使用者明确指定在一个时间间隔内消耗在垃圾收集上的时间不得超过 N 毫秒。 ps：从JDK9开始G1成为默认的垃圾收集器\n类加载 类加载过程 类加载过程：加载-\u0026gt;连接-\u0026gt;初始化。 连接过程又可分为三步：验证-\u0026gt;准备-\u0026gt;解析。 加载的作用就是读取class文件，将class文件解析为class对象保存到方法区里面\n类加载器 JVM 中内置了三个重要的 ClassLoader：\nBootstrapClassLoader(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ %JAVA_HOME%/lib目录下的 rt.jar、resources.jar、charsets.jar等 jar 包和类）以及被 -Xbootclasspath参数指定的路径下的所有类。 ExtensionClassLoader(扩展类加载器)：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。 AppClassLoader(应用程序类加载器)：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。 自定义类加载器：继承 ClassLoader抽象类，并且重写方法\n双亲委派模型 查找类是否被加载时从下往上找，加载类时从上往下找能加载类的类加载器\n使用双亲委派模型的好处 双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。\nSpring 详见https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html中及这里的其他文章\nSpring是如何解决的循环依赖 Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects）,二级缓存为早期曝光对象earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工厂的getObject方法来获取到对应的对象，得到这个对象后将其放到二级缓存中并删除三级缓存的ObjectFactory，并将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！\n流程图如下：\n详见：面试必杀技，讲一讲Spring中的循环依赖-阿里云开发者社区 (aliyun.com)\nSpring中的循环依赖及解决 - 掘金 (juejin.cn)\nps：\n自引用也是循环依赖的一种 注入bean的时候首先getBean，如果有缓存就找缓存，没有缓存就createBean，所以A注入B的时候会创建B，但是B注入A的时候会找缓存 三级缓存都是什么 singletonObjects：缓存经过完整生命周期的bean\nearlySingletonObjects：如果没有使用AOP就缓存还没有进行依赖注入的bean，如果使用了AOP就缓存代理对象（通过调用ObjectFactory来获取代理对象）\nsingletonFactories：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的，如果bean使用了AOP就返回AOP对象，如果没使用AOP就返回原始对象\n为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？ 如果要使用二级缓存解决循环依赖，意味着所有需要AOP的Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。\n系统设计 超卖问题 有两种解决方案：\n对数据库加锁，可以使用乐观锁或者悲观锁 使用Redis的单线程预减库存，就是在减真正的库存前先减Redis里面的库存，只有成功减Redis库存的请求才能减真正的库存，这种做法是基于Redis是单线程的不会出现并发的特性 详见：如何解决高并发下的超卖问题？ - BearBrick0 - 博客园 (cnblogs.com)\n零碎 匿名内部类也会生成class文件 transferTo方法是什么？ 是Java提供的零拷贝文件传输函数，需要操作系统的支持，Netty的文件传输就采用了Java的transferTo方法，详见上面Netty 的零拷贝的解释\n待做 高优先级 各种序列化方式的原理 12306里面的系统设计问题 分库分表 中优先级 看一下常用的线程池和阻塞队列 synchronized 锁升级：浅析synchronized锁升级的原理与实现 - 小新成长之路 - 博客园 (cnblogs.com)、java对象的内存布局 - 小新成长之路 - 博客园 (cnblogs.com) AQS 整理mysql优化、索引怎么设计 把mysql的流程从头到尾过一遍 小林coding看一遍 低优先级 主从多线程模型到底是什么 Netty的内存池是怎么实现的 五种IO模型 CAP为什么不能保证三个 内存相关，从头到尾捋一遍 mysql深入学一遍 事务提交的时候做了哪些操作 ","permalink":"https://blog.zhangmengyang.tk/en/posts/tech/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0-%E8%83%8C%E8%AF%B5%E7%89%88/","summary":"项目 一般问题 碰到的bug 最有技术含量的部分 动态代理 见：https://juejin.cn/post/7011357346018361375 j","title":"面试题笔记 背诵版"},{"content":"思路 同LeetCode-15，只不过每次找到一个三元组，都判断一下跟target的距离，去最小距离的三元组\n代码 class Solution { public int threeSumClosest(int[] nums, int target) { int n = nums.length, res = 100000; Arrays.sort(nums); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1, right = n - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == target) { return target; } if (Math.abs(sum - target) \u0026lt; Math.abs(res - target)) { res = sum; } if (sum \u0026gt; target) { right--; } else { left++; } } } return res; } } References 1. 最接近的三数之和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-16/","summary":"思路 同LeetCode-15，只不过每次找到一个三元组，都判断一下跟target的距离，去最小距离的三元组 代码 class Solution { public int threeSumClosest(int[] nums, int target) { int n = nums.length, res","title":"LeetCode 16"},{"content":"思路 两种思路：\n递归 因为是判断树是否镜像对称，所以需要递归判断左子树的左子树与右子树的右子树和左子树的右子树与右子树的左子树是否镜像对称，这样就找到了递归的地方，详见代码\n迭代 创建一个队列，首先从队列中拿出两个节点(left 和 right)比较，将 left 的 left 节点和 right 的 right 节点放入队列，将 left 的 right 节点和 right 的 left 节点放入队列，再比较，循环往复即可\n代码 递归 class Solution { public boolean isSymmetric(TreeNode root) { return isSymmetric(root.left, root.right); } private boolean isSymmetric(TreeNode leftRoot, TreeNode rightRoot) { if (leftRoot == null \u0026amp;\u0026amp; rightRoot == null) { return true; } if (leftRoot == null || rightRoot == null) { return false; } if (leftRoot.val != rightRoot.val) { return false; } return isSymmetric(leftRoot.right, rightRoot.left) \u0026amp;\u0026amp; isSymmetric(leftRoot.left, rightRoot.right); } } 迭代 class Solution { public boolean isSymmetric(TreeNode root) { LinkedList\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root.left); queue.add(root.right); while (!queue.isEmpty()) { TreeNode left = queue.remove(); TreeNode right = queue.remove(); if (left == null \u0026amp;\u0026amp; right == null) { continue; } if (left == null || right == null) { return false; } if (left.val != right.val) { return false; } queue.add(left.left); queue.add(right.right); queue.add(left.right); queue.add(right.left); } return true; } } References 1. 对称二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-101/","summary":"思路 两种思路： 递归 因为是判断树是否镜像对称，所以需要递归判断左子树的左子树与右子树的右子树和左子树的右子树与右子树的左子树是否镜像对称，这样","title":"LeetCode 101"},{"content":"思路 第一题 模拟即可，直接看代码\n第二题 从左往右遍历字符串，每碰到一个数字，就计算前面mod m的余数 * 10 + 当前数字是否能整除m，然后再将除以m的余数赋值到前面mod m的余数上，看代码即可\n第三题 两种思路：\n二分查找 由于是查找能标记的最大值，由于标记数和不能成立成正比，具有单调性，所以可以使用二分查找，范围是[0, nums.lenght / 2]，每次选择中点，并判断中点能不能成立，具体判断方法就是判断最小的mid个数和最大的mid个数能否满足2*nums[i] \u0026lt;= nums[j]\n双指针 利用双指针的思想，i指向0， j指向中点，判断i 和 j是否满足条件，如果满足条件，i++，寻找下一个标记对，最后i的值就是可标记对的数目\n第四题 没做出来\n代码 第一题 class Solution { public int[] leftRigthDifference(int[] nums) { int n = nums.length; int[] res = new int[n], leftSum = new int[n], rightSum = new int[n]; for (int i = 1; i \u0026lt; n; i++) { leftSum[i] = leftSum[i - 1] + nums[i - 1]; } for (int i = n - 2; i \u0026gt;= 0; i--) { rightSum[i] = rightSum[i + 1] + nums[i + 1]; } for (int i = 0; i \u0026lt; n; i++) { res[i] = Math.abs(leftSum[i] - rightSum[i]); } return res; } } 第二题 class Solution { public int[] divisibilityArray(String word, int m) { int n = word.length(); int[] res = new int[n]; long r = 0; for (int i = 0; i \u0026lt; n; i++) { char c = word.charAt(i); r = r * 10 + c - \u0026#39;0\u0026#39;; if (r % m == 0) { res[i] = 1; } r %= m; } return res; } } 第三题 二分查找 class Solution { public int maxNumOfMarkedIndices(int[] nums) { int n = nums.length; int left = 0, right = n / 2; Arrays.sort(nums); while (left \u0026lt; right) { int mid = (right - left + 1) / 2 + left; if (canMark(nums, mid)) { left = mid; } else { right = mid - 1; } } return left * 2; } private boolean canMark(int[] nums, int n) { for (int i = 0; i \u0026lt; n; i++) { if (2 * nums[i] \u0026gt; nums[nums.length - n + i]) { return false; } } return true; } } 双指针 class Solution { public int maxNumOfMarkedIndices(int[] nums) { Arrays.sort(nums); int i = 0; for (int j = (nums.length + 1) / 2;j \u0026lt; nums.length;j++) { if (2 * nums[i] \u0026lt;= nums[j]) { i++; } } return 2 * i; } } References 1. 左右元素和的差值 2. 找出字符串的可整除数组 3. 求出最多标记下标 4. 在网格图中访问一个格子的最少时间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-334/","summary":"思路 第一题 模拟即可，直接看代码 第二题 从左往右遍历字符串，每碰到一个数字，就计算前面mod m的余数 * 10 + 当前数字是否能整除m，然后再将除以m的","title":"LeetCode 周赛 334"},{"content":"思路 三种思路：\n递归 经典二叉树中序遍历，闭着眼写，详见思想篇章\n迭代 暂时没看\nMorris 中序遍历 感觉没必要看\n代码 递归 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); inorderTraversal(root, res); return res; } private void inorderTraversal(TreeNode root, List\u0026lt;Integer\u0026gt; res) { if (root == null) { return; } inorderTraversal(root.left, res); res.add(root.val); inorderTraversal(root.right, res); } } References 1. 二叉树的中序遍历 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-94/","summary":"思路 三种思路： 递归 经典二叉树中序遍历，闭着眼写，详见思想篇章 迭代 暂时没看 Morris 中序遍历 感觉没必要看 代码 递归 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); inorderTraversal(root, res); return res; } private","title":"LeetCode 94"},{"content":"思路 利用双指针的思想即可，左指针指向0的最后一个的后一个，右指针指向2的第一个的前一个，然后遍历数组同时维护左右指针即可，注意点：\n除了刚开始的时候，左指针指向的不可能是0，因为如果是0，那么遍历的时候就肯定遍历到它了，那么就会放到左边，而不是出现在这里 交换右边的时候，i不能加一，因为交换的数字有可能是0或2，要重复判断 代码 class Solution { public void sortColors(int[] nums) { int left = 0, right = nums.length - 1; for (int i = 0; i \u0026lt;= right; i++) { if (nums[i] == 0) { nums[i] = nums[left]; nums[left] = 0; left++; } if (nums[i] == 2) { nums[i] = nums[right]; nums[right] = 2; right--; i--; } } } } References 1. 颜色分类 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-75/","summary":"思路 利用双指针的思想即可，左指针指向0的最后一个的后一个，右指针指向2的第一个的前一个，然后遍历数组同时维护左右指针即可，注意点： 除了刚开始","title":"LeetCode 75"},{"content":"思路 三种思路：\n动态规划 类似于斐波那契数列，定义一个dp数组，dp[i] = j的含义是，到达第i个台阶有j种方法，那么递推公式为：\ndp[i] = dp[i - 2] + dp[i - 1]; base case为dp[0] = dp[1] = 1，可以优化空间复杂度，但是懒得弄了\n矩阵快速幂 感觉没必要看\n通项公式 感觉没必要看\n代码 class Solution { public int climbStairs(int n) { int[] dp = new int[n + 1]; dp[0] = dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 2] + dp[i - 1]; } return dp[n]; } } References 1. 爬楼梯 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-70/","summary":"思路 三种思路： 动态规划 类似于斐波那契数列，定义一个dp数组，dp[i] = j的含义是，到达第i个台阶有j种方法，那么递推公式为： dp[i] = dp[i - 2] + dp[i","title":"LeetCode 70"},{"content":"思路 两种思路：\n动态规划 暂时没看\n数学组合 这里向下向右的步数是固定的，所以这里路径的个数等于C(向右的步数或向下的步数，总步数)，求组合详见思想篇章，注意这里必须从1和n开始乘，从1和m+n-2开始乘会溢出\n代码 class Solution { public int uniquePaths(int m, int n) { long res = 1; for (int i = n, j = 1; j \u0026lt; m; i++, j++) { res = res * i / j; } return (int) res; } } References 1. 不同路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-62/","summary":"思路 两种思路： 动态规划 暂时没看 数学组合 这里向下向右的步数是固定的，所以这里路径的个数等于C(向右的步数或向下的步数，总步数)，求组合详见思想","title":"LeetCode 62"},{"content":"思路 第一题 脑筋急转弯，直接看代码\n第二题 其实就是计算2^n - 2，用快速幂计算即可，只不过要注意：\n求的时候同时取余，模板在思想篇章 计算过程有可能超过int类型范围，所以需要用long存储 最后的结果最好写成(2^n - 2 + MOD) % MOD，因为有可能2^n - 2 \u0026lt; 0 第三题 先转换问题，可以把原问题转换为用挡板将数组分成k个子数组，那么共有k - 1个挡板，答案就是数组第一个元素加最后一个元素加挡板两边的元素，所以可以把原数组的元素两两合并，然后找出最大的k-1个数之和与最小的k-1个数之和，两数之差就是答案\n第四题 其实枚举所有四元组就可以了，但是枚举所有四元组，时间复杂度较高，所以可以使用有技巧的枚举，只枚举中间两个数，剩下两个数其实大小范围和位置范围是确定的，问题就转换为了怎么获取这些位置范围和大小范围确定的数，可以用一个数组greater[j][x]来记录位置j右边比x大的数的数量，具体看代码\n代码 第一题 class Solution { public int distinctIntegers(int n) { if (n == 1) { return 1; } return n - 1; } } 第二题 class Solution { int base = 1000000007; int mypow(int a, int k) { if (k == 0) return 1; a %= base; if (k % 2 == 1) { // k 是奇数 return (int) (((long)a * mypow(a, k - 1)) % base); } else { // k 是偶数 int sub = mypow(a, k / 2); return (int) (((long)sub * sub) % base); } } public int monkeyMove(int n) { int res = mypow(2, n); return res \u0026gt;= 2 ? res - 2 : res + base - 2; } } 第三题 class Solution { public long putMarbles(int[] weights, int k) { int n = weights.length; long[] temp = new long[n - 1]; for (int i = 0; i \u0026lt; n - 1; i++) { temp[i] = weights[i] + weights[i + 1]; } Arrays.sort(temp); long max = 0, min = 0; for (int i = 0; i \u0026lt; k - 1; i++) { max += temp[n - 2 - i]; min += temp[i]; } return max - min; } } 第四题 class Solution { public long countQuadruplets(int[] nums) { int n = nums.length; int[][] greater = new int[n][n + 1]; for (int i = n - 2; i \u0026gt; 0; i--) { greater[i] = greater[i + 1].clone(); for (int j = 1; j \u0026lt; nums[i + 1]; j++) { greater[i][j]++; } } long res = 0; for (int j = 1; j \u0026lt; n - 2; j++) { for (int k = j + 1; k \u0026lt; n - 1; k++) { int x = nums[k]; if (nums[j] \u0026gt; x) { res += (long) greater[k][nums[j]] * (x - (n - 1 - j - greater[j][x])); } } } return res; } } References 1. 统计桌面上的不同数字 2. 猴子碰撞的方法数 3. 将珠子放入背包中 4. 统计上升四元组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-330/","summary":"思路 第一题 脑筋急转弯，直接看代码 第二题 其实就是计算2^n - 2，用快速幂计算即可，只不过要注意： 求的时候同时取余，模板在思想篇章 计算过程有可能","title":"LeetCode 周赛 330"},{"content":"思路 第一题 遍历一遍即可，直接看代码\n第二题 二维数组一片区域同时增加一个数，可以使用差分数组的思想，跟一维的一样，一维的是把两头修改一下就可以了，二维的需要在以下位置修改：\n为什么要这么修改？因为差分数组的前缀和就是原数组，这么修改的话，差分数组求前缀和后刚好就是那一块被修改了，又因为差分数组的前缀和是原数组，所以把修改后的差分数组求前缀和后就得到了答案\n所以这道题的解答有三步：\n构建差分数组，注意二维差分数组的构建方式：差分值=当前位置的值-左边的-上边的+左上的，本题全是0所以可以省略 修改差分数组，具体做法如上所示 对差分数组求前缀和，获取原数组，这里因为将前缀和数组放在一个新数组里还得复制到结果数组里面，所以可以将前缀和数组放到之前的差分数组里面，然后再复制到结果数组，以此来节省时间 第三题 利用滑动窗口的思想，时刻保持当前窗口是以right为底，窗口内是好数组的最短数组，那么以当前right为底的好数组个数就是left+1个，我的代码和标准解法的区别是，我的left比标准解答往后挪了1\n第四题 没看\n代码 第一题 class Solution { public int differenceOfSum(int[] nums) { int sum1 = 0, sum2 = 0; for (int num : nums) { sum1 += num; sum2 += getVal(num); } return Math.abs(sum1 - sum2); } private int getVal(int num) { int sum = 0; while (num != 0) { sum += num % 10; num /= 10; } return sum; } } 第二题 class Solution { public int[][] rangeAddQueries(int n, int[][] queries) { int[][] diff = new int[n + 2][n + 2]; for (int[] query : queries) { diff[query[0] + 1][query[1] + 1]++; diff[query[0] + 1][query[3] + 2]--; diff[query[2] + 2][query[1] + 1]--; diff[query[2] + 2][query[3] + 2]++; } int[][] res = new int[n][n]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { diff[i][j] = diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1] + diff[i][j]; res[i - 1][j - 1] = diff[i][j]; } } return res; } } 第三题 class Solution { public long countGood(int[] nums, int k) { long res = 0; int n = nums.length; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, count = 0; while (right \u0026lt; n) { map.put(nums[right], map.getOrDefault(nums[right], 0) + 1); count += map.get(nums[right]) - 1; right++; while (count - map.get(nums[left]) + 1 \u0026gt;= k) { map.put(nums[left], map.get(nums[left]) - 1); count -= map.get(nums[left]); left++; } if (count \u0026gt;= k) { res += left + 1; } } return res; } } References 1. 数组元素和与数字和的绝对差 2. 子矩阵元素加 1 3. 统计好子数组的数目 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-328/","summary":"思路 第一题 遍历一遍即可，直接看代码 第二题 二维数组一片区域同时增加一个数，可以使用差分数组的思想，跟一维的一样，一维的是把两头修改一下就可以了","title":"LeetCode 周赛 328"},{"content":"思路 使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。\n由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。\n还可以对字符串的字符进行计数，然后将这些数字拼接成字符串作为key，比如abc可以计数为a1b1c1\n代码 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String str : strs) { char[] chars = str.toCharArray(); Arrays.sort(chars); String sortedStr = new String(chars); if (!map.containsKey(sortedStr)) { map.put(sortedStr, new LinkedList\u0026lt;\u0026gt;()); } map.get(sortedStr).add(str); } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } References 1. 字母异位词分组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-49/","summary":"思路 使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。遍历每个字符串，对于每个字符串，得到该","title":"LeetCode 49"},{"content":"思路 看到「最大化最小值」或者「最小化最大值」（其实就是那种要求一堆数字尽量平均的题）就要想到二分答案，这是一个固定的套路。\n这里求小孩最多能拿到多少糖果，其实就是尽量平均的问题，那么可以二分搜索答案，每次选定一个答案都要验证这个答案，根据验证结果去选择在左区间还是右区间继续二分查找，不过要注意每次二分要排除不可能的情况，也就是说可能的情况要全部保留，不要将可能的情况扔掉，相关代码如下所示：\nif (count \u0026gt;= k) { left = mid; } else { right = mid - 1; } 代码 class Solution { public int maximumCandies(int[] candies, long k) { int left = 0, right = 10000000; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; long count = 0; for (int i = 0; i \u0026lt; candies.length; i++) { count += candies[i] / mid; } if (count \u0026gt;= k) { left = mid; } else { right = mid - 1; } } return left; } } References 1. 每个小孩最多能分到多少糖果 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-2226/","summary":"思路 看到「最大化最小值」或者「最小化最大值」（其实就是那种要求一堆数字尽量平均的题）就要想到二分答案，这是一个固定的套路。 这里求小孩最多能拿","title":"LeetCode 2226"},{"content":"思路 第一题 两种思路：\n暴力解法 遍历一遍并统计\n二分查找 因为数组是有序的，分别查找0的左边界和右边界就可以得到正数负数的范围了，注意左边界是第一个大于等于target的数，右边界是从右往左第一个小于等于target的数，python里自带了二分查找左边界和右边界的函数，Java里有基本版的二分查找\n第二题 利用贪心算法的思想，每次取最大的，所以用最大堆即可，向上取整可以用(val + 2) / 3，即(val + n - 1) / n\n第三题 将两个字符串转为两个map，然后将两个map里的字母交换，同时判断交换后map的entry数目是否相等即可，因为总共就26个字母，所以不会超时，而且其实不用真的交换，直接通过数学计算就好了\n第四题 模拟题，没什么好说的，就是想办法用代码模拟这个过程，这个答案比较简洁，我写的就是一坨屎山\n代码 第一题 暴力解法 class Solution { public int maximumCount(int[] nums) { int a = 0, b = 0; for (int num : nums) { if (num \u0026lt; 0) { a++; } else if (num \u0026gt; 0) { b++; } } return Math.max(a, b); } } 二分查找 class Solution { public int maximumCount(int[] nums) { int a = searchLeft(nums, 0); int b = searchRight(nums, 0); return Math.max(a, nums.length - b - 1); } private int searchLeft(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026lt;= nums[mid]) { right = mid; } else { left = mid + 1; } } return nums[left] \u0026lt; target ? nums.length : left; } private int searchRight(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if (target \u0026gt;= nums[mid]) { left = mid; } else { right = mid - 1; } } return nums[left] \u0026gt; target ? -1 : left; } } 第二题 class Solution { public long maxKelements(int[] nums, int k) { Queue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b - a; }); for (int num : nums) { pq.offer(num); } long res = 0; while (k-- != 0) { res += pq.peek(); pq.offer((pq.poll() + 2) / 3); } return res; } } 第三题 class Solution { public boolean isItPossible(String word1, String word2) { Map\u0026lt;Character, Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); for (char c : word1.toCharArray()) { map1.put(c, map1.getOrDefault(c, 0) + 1); } for (char c : word2.toCharArray()) { map2.put(c, map2.getOrDefault(c, 0) + 1); } Set\u0026lt;Character\u0026gt; keySet1 = new HashSet\u0026lt;\u0026gt;(map1.keySet()); Set\u0026lt;Character\u0026gt; keySet2 = new HashSet\u0026lt;\u0026gt;(map2.keySet()); for (Character c1 : keySet1) { for (Character c2 : keySet2) { swap(map1, map2, c1, c2); if (map1.size() == map2.size()) { return true; } swap(map1, map2, c2, c1); } } return false; } private void swap(Map\u0026lt;Character, Integer\u0026gt; map1, Map\u0026lt;Character, Integer\u0026gt; map2, char c1, char c2) { Integer v1 = map1.get(c1); Integer v2 = map2.get(c2); if (v1 == 1) { map1.remove(c1); } else { map1.put(c1, map1.get(c1) - 1); } if (v2 == 1) { map2.remove(c2); } else { map2.put(c2, map2.get(c2) - 1); } map1.put(c2, map1.getOrDefault(c2, 0) + 1); map2.put(c1, map2.getOrDefault(c1, 0) + 1); } } 第四题 class Solution { public int findCrossingTime(int n, int k, int[][] time) { Queue\u0026lt;Worker\u0026gt; pq1 = new PriorityQueue\u0026lt;Worker\u0026gt;((a, b) -\u0026gt; { if (a.time[0] + a.time[2] \u0026gt; b.time[0] + b.time[2] || a.time[0] + a.time[2] == b.time[0] + b.time[2] \u0026amp;\u0026amp; a.index \u0026gt; b.index) { return -1; } else { return 1; } }); Queue\u0026lt;Worker\u0026gt; pq2 = new PriorityQueue\u0026lt;Worker\u0026gt;((a, b) -\u0026gt; { if (a.time[0] + a.time[2] \u0026gt; b.time[0] + b.time[2] || a.time[0] + a.time[2] == b.time[0] + b.time[2] \u0026amp;\u0026amp; a.index \u0026gt; b.index) { return -1; } else { return 1; } }); for (int i = 0; i \u0026lt; time.length; i++) { pq1.offer(new Worker(\u0026#34;waitBridge\u0026#34;, 0, i, time[i])); } boolean bridgeIsUsed = false; List\u0026lt;Worker\u0026gt; workerList = new ArrayList\u0026lt;\u0026gt;(); int t = -1, pickOldCount = 0, minTime = 1; while (true) { t += minTime; int newMinTime = Integer.MAX_VALUE; // 工作 for (int i = 0; i \u0026lt; workerList.size(); i++) { Worker worker = workerList.get(i); switch (worker.state) { case \u0026#34;leftToRight\u0026#34;: worker.leftTime -= minTime; if (worker.leftTime == 0) { worker.state = \u0026#34;pickOld\u0026#34;; worker.leftTime = worker.time[1]; bridgeIsUsed = false; pickOldCount++; } newMinTime = Math.min(newMinTime, worker.leftTime); break; case \u0026#34;rightToLeft\u0026#34;: worker.leftTime -= minTime; if (worker.leftTime == 0) { worker.state = \u0026#34;putNew\u0026#34;; worker.leftTime = worker.time[3]; bridgeIsUsed = false; if (n == 0 \u0026amp;\u0026amp; pickOldCount == 0) { return t; } } newMinTime = Math.min(newMinTime, worker.leftTime); break; case \u0026#34;pickOld\u0026#34;: worker.leftTime -= minTime; if (worker.leftTime == 0) { worker.state = \u0026#34;waitBridge\u0026#34;; pq2.offer(worker); workerList.remove(i); i--; } else { newMinTime = Math.min(newMinTime, worker.leftTime); } break; case \u0026#34;putNew\u0026#34;: worker.leftTime -= minTime; if (worker.leftTime == 0) { worker.state = \u0026#34;waitBridge\u0026#34;; pq1.offer(worker); workerList.remove(i); i--; } else { newMinTime = Math.min(newMinTime, worker.leftTime); } break; } } if (!bridgeIsUsed \u0026amp;\u0026amp; !pq2.isEmpty()) { Worker poll = pq2.poll(); poll.state = \u0026#34;rightToLeft\u0026#34;; poll.leftTime = poll.time[2]; workerList.add(poll); newMinTime = Math.min(newMinTime, poll.leftTime); bridgeIsUsed = true; pickOldCount--; } if (!bridgeIsUsed \u0026amp;\u0026amp; n != 0 \u0026amp;\u0026amp; !pq1.isEmpty()) { Worker poll = pq1.poll(); poll.state = \u0026#34;leftToRight\u0026#34;; poll.leftTime = poll.time[0]; workerList.add(poll); newMinTime = Math.min(newMinTime, poll.leftTime); bridgeIsUsed = true; n--; } minTime = newMinTime; } } class Worker { String state; int leftTime, index; int[] time; public Worker(String state, int leftTime, int index, int[] time) { this.state = state; this.leftTime = leftTime; this.index = index; this.time = time; } } } References 1. 正整数和负整数的最大计数 2. 执行 K 次操作后的最大分数 3. 使字符串总不同字符的数目相等 4. 过桥的时间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-327/","summary":"思路 第一题 两种思路： 暴力解法 遍历一遍并统计 二分查找 因为数组是有序的，分别查找0的左边界和右边界就可以得到正数负数的范围了，注意左边界是第一个","title":"LeetCode 周赛 327"},{"content":"思路 第一题 不解释\n第二题 用count记录一下末尾有几个value，直接看代码\n第三题 其实就是计算数组各元素的异或，证明详见：https://leetcode.cn/problems/find-xor-beauty-of-array/solutions/2050337/no6289-cha-xun-shu-zu-xor-mei-li-zhi-by-d5ylk/\n第四题 利用二分查找的思想，从答案可能的区间里取中间的数，然后验证答案需要额外建造多少个供电站，最后判断修建的供电站是否超过 k ，如果超过说明选择的答案偏大，否则说明偏小，然后根据偏大还是偏小再进行二分就可以了\n看到「最大化最小值」或者「最小化最大值」（其实就是那种要求一堆数字尽量平均的题）就要想到二分答案，这是一个固定的套路。\n为什么？一般来说，二分的值越大，越能/不能满足要求；二分的值越小，越不能/能满足要求，有单调性，可以二分。\n这道题使用前缀和来确定各个城市的电量，然后二分搜索答案，验证答案时用到了差分数组\n因为没做出来就不贴代码了，详见：https://leetcode.cn/problems/maximize-the-minimum-powered-city/solutions/2050272/er-fen-da-an-qian-zhui-he-chai-fen-shu-z-jnyv/\n代码 第一题 class Solution { public String categorizeBox(int length, int width, int height, int mass) { long v = (long) length * width * height; boolean Bulky = length \u0026gt;= 10000 || width \u0026gt;= 10000 || height \u0026gt;= 10000 || v \u0026gt;= 1000000000; boolean Heavy = mass \u0026gt;= 100; if (Bulky \u0026amp;\u0026amp; Heavy) { return \u0026#34;Both\u0026#34;; } if (Bulky) { return \u0026#34;Bulky\u0026#34;; } if (Heavy) { return \u0026#34;Heavy\u0026#34;; } return \u0026#34;Neither\u0026#34;; } } 第二题 class DataStream { private int value, k, count; public DataStream(int value, int k) { this.value = value; this.k = k; this.count = 0; } public boolean consec(int num) { if (num == value) { count++; } else { count = 0; } return count \u0026gt;= k; } } 第三题 class Solution { public int xorBeauty(int[] nums) { int res = 0; for (int num : nums) { res ^= num; } return res; } } References 1. 根据规则将箱子分类 2. 找到数据流中的连续整数 3. 查询数组 Xor 美丽值 4. 最大化城市的最小供电站数目 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%8F%8C%E5%91%A8%E8%B5%9B-95/","summary":"思路 第一题 不解释 第二题 用count记录一下末尾有几个value，直接看代码 第三题 其实就是计算数组各元素的异或，证明详见：https://le","title":"LeetCode 双周赛 95"},{"content":"思路 利用二分查找的思路，每次选出一个中间元素，对于这个中间元素来说，左边和右边必有一个有序序列，那么我们可以分情况讨论，如果左边是有序序列，那么target \u0026lt; nums[mid] \u0026amp;\u0026amp; target \u0026gt;= nums[0]的情况target一定在左边，否则在右边，以此类推直到找到target\n代码 官方解答 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (target == nums[mid]) { return mid; } if (nums[mid] \u0026gt;= nums[0]) { if (target \u0026lt; nums[mid] \u0026amp;\u0026amp; target \u0026gt;= nums[0]) { right = mid - 1; } else { left = mid + 1; } } else { if (target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt; nums[0]) { left = mid + 1; } else { right = mid - 1; } } } return -1; } } 我的解法 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (target == nums[mid]) { return mid; } else if (target \u0026gt; nums[mid]) { if (target \u0026gt;= nums[0]) { if (nums[mid] \u0026lt; nums[0]) { right = mid - 1; } else { left = mid + 1; } } else { left = mid + 1; } } else if (target \u0026lt; nums[mid]) { if (target \u0026gt;= nums[0]) { right = mid - 1; } else { if (nums[mid] \u0026lt; nums[0]) { right = mid - 1; } else { left = mid + 1; } } } } return -1; } } References 1. 搜索旋转排序数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-33/","summary":"思路 利用二分查找的思路，每次选出一个中间元素，对于这个中间元素来说，左边和右边必有一个有序序列，那么我们可以分情况讨论，如果左边是有序序列，","title":"LeetCode 33"},{"content":"思路 三种思路：\n栈 定义一个栈，保证栈底为最后一个不匹配的右括号的下标，然后碰到左括号就入栈，碰到右括号就出栈，如果出栈后栈为空，说明当前的右括号没有相对应的左括号，那么此右括号就是最后一个不匹配的右括号，将其下标入栈，如果出栈后栈不为空，说明有相应的左括号，那么更新res最大值即可，为什么这样是正确的呢？因为栈里存的是最后一个不匹配的右括号和尚未匹配的左括号，任何一个有效括号序列一定是以这些元素开头，所以可以通过这种方式获取有效括号序列的长度\n动态规划 构建dp数组，数组里存放以该元素结尾的最长有效括号，状态转移方程为：\nif (s.charAt(i) == \u0026#39;(\u0026#39;) { dp[i] = 0; } else { if (s.charAt(i - 1) == \u0026#39;(\u0026#39;) { dp[i] = i - 2 \u0026gt;= 0 ? dp[i - 2] + 2 : 2; } else { if (i - dp[i - 1] - 1 \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i - dp[i - 1] - 1) == \u0026#39;(\u0026#39;) { dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2 \u0026gt;= 0 ? dp[i - dp[i - 1] - 2] : 0); } else { dp[i] = 0; } } } 当该元素为右括号，前面元素也是右括号时，先根据前面元素的有效括号长度找到有可能与该元素匹配的左括号，如果i - dp[i - 1] - 1位置的元素是左括号，那么就匹配上了dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2 \u0026gt;= 0 ? dp[i - dp[i - 1] - 2] : 0);，如果i - dp[i - 1] - 1位置的元素是右括号，则该元素的最长有效括号为0，生成dp数组元素的同时维护大值即可\nbase case为dp[-1] = dp[0] = 0，不能优化空间复杂度\n两次遍历 从左往右遍历一次，统计碰到的左括号的数量（left）和右括号的数量（right），如果left == right就记录长度，如果right\u0026gt;left，就让left和right归零，因为此时前面的元素都可以扔掉不考虑，但是这种情况无法判断(()这种情况，此时从右往左遍历一遍就可以了，如果right\u0026lt;left，就让left和right归零，遍历的同时维护最大值即可\n代码 栈 class Solution { public int longestValidParentheses(String s) { int n = s.length(), res = 0; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(-1); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { stack.push(i); } else { stack.pop(); if (stack.isEmpty()) { stack.push(i); } else { res = Math.max(res, i - stack.peek()); } } } return res; } } 动态规划 class Solution { public int longestValidParentheses(String s) { int n = s.length(), res = 0; int[] dp = new int[n]; for (int i = 1; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { dp[i] = 0; } else { if (s.charAt(i - 1) == \u0026#39;(\u0026#39;) { dp[i] = i - 2 \u0026gt;= 0 ? dp[i - 2] + 2 : 2; } else { if (i - dp[i - 1] - 1 \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i - dp[i - 1] - 1) == \u0026#39;(\u0026#39;) { dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2 \u0026gt;= 0 ? dp[i - dp[i - 1] - 2] : 0); } else { dp[i] = 0; } } } res = Math.max(res, dp[i]); } return res; } } 两次遍历 class Solution { public int longestValidParentheses(String s) { int left = 0, right = 0, res = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { left++; } else { right++; } if (left == right) { res = Math.max(res, left + right); } else if (left \u0026lt; right) { left = right = 0; } } left = right = 0; for (int i = s.length() - 1; i \u0026gt;= 0; i--) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { left++; } else { right++; } if (left == right) { res = Math.max(res, left + right); } else if (left \u0026gt; right) { left = right = 0; } } return res; } } References 1. 最长有效括号 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-32/","summary":"思路 三种思路： 栈 定义一个栈，保证栈底为最后一个不匹配的右括号的下标，然后碰到左括号就入栈，碰到右括号就出栈，如果出栈后栈为空，说明当前的右括","title":"LeetCode 32"},{"content":"思路 因为是下一个排列，所以更改的元素尽量靠右，并且需要变大，那么我们可以从右往左遍历，找到右侧存在比自己大的元素的元素（找这种元素可以从左往右遍历，第一个比后面元素小的元素就是要找的元素），更改的时候需要将该元素右侧比该元素大的最小元素替换到该位置，然后后面的元素从大到小排列，以保证变大的幅度尽可能小\n代码 class Solution { public void nextPermutation(int[] nums) { int n = nums.length, i = n - 2; while (i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i + 1]) { i--; } if (i \u0026gt;= 0) { int j = n - 1; while (nums[j] \u0026lt;= nums[i]) { j--; } swap(nums, i, j); } reverse(nums, i + 1); } private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } private void reverse(int[] nums, int begin) { int left = begin, right = nums.length - 1; while (left \u0026lt; right) { swap(nums, left, right); left++; right--; } } } References 1. 下一个排列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-31/","summary":"思路 因为是下一个排列，所以更改的元素尽量靠右，并且需要变大，那么我们可以从右往左遍历，找到右侧存在比自己大的元素的元素（找这种元素可以从左往","title":"LeetCode 31"},{"content":"思路 经典回溯问题，对于每个数字都有几种选择，套模板即可\n代码 class Solution { private List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); private char[][] table = new char[][]{ {}, {}, {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}, {\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;}, {\u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;}, {\u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;}, {\u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;v\u0026#39;}, {\u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;} }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits.isEmpty()) { return res; } backtrack(\u0026#34;\u0026#34;, digits, 0); return res; } private void backtrack(String s, String digits, int start) { if (start == digits.length()) { res.add(s); return; } char[] choices = table[digits.charAt(start) - \u0026#39;0\u0026#39;]; for (char c : choices) { backtrack(s + c, digits, start + 1); } } } References 1. 电话号码的字母组合 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-17/","summary":"思路 经典回溯问题，对于每个数字都有几种选择，套模板即可 代码 class Solution { private List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); private char[][] table = new char[][]{ {}, {}, {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}, {\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;}, {\u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;}, {\u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;}, {\u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;v\u0026#39;}, {\u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;,","title":"LeetCode 17"},{"content":"思路 利用双指针的思想，这道题不是想象中的那样使用Map，而是使用双指针，这题的难点在于去重，可以先排序，然后遍历每一个元素，同时根据遍历的这个元素找相对应的两个元素，为了去重，从该元素后面找（否则会有重复解），寻找这两个元素的时候就可以使用双指针，如果加起来过大，就right\u0026ndash;，过小就left++，遍历完所有元素即可\n代码 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { int n = nums.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; n; i++) { if (nums[i] \u0026gt; 0) { break; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1, right = n - 1, target = -nums[i]; while (left \u0026lt; right) { if (nums[left] + nums[right] == target) { res.add(Arrays.asList(nums[i], nums[left], nums[right])); left++; right--; while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left - 1]) { left++; } while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right + 1]) { right--; } } else if (nums[left] + nums[right] \u0026gt; target) { right--; } else { left++; } } } return res; } } References 1. 三数之和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-15/","summary":"思路 利用双指针的思想，这道题不是想象中的那样使用Map，而是使用双指针，这题的难点在于去重，可以先排序，然后遍历每一个元素，同时根据遍历的这","title":"LeetCode 15"},{"content":"思路 简单粗暴版 将数字翻转过来，然后判断与翻转前的数字是否相等\n巧妙解法 只翻转一半即可，见代码\n代码 简单粗暴版 class Solution { public boolean isPalindrome(int x) { if (x \u0026lt; 0) { return false; } long res = 0, num = x; while (num != 0) { res = res * 10 + (num % 10); num /= 10; } return res == x; } } 巧妙解法 class Solution { public boolean isPalindrome(int x) { if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int num = 0; while (x \u0026gt; num) { num = num * 10 + (x % 10); x /= 10; } return num == x || num / 10 == x; } } References 1. 回文数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-9/","summary":"思路 简单粗暴版 将数字翻转过来，然后判断与翻转前的数字是否相等 巧妙解法 只翻转一半即可，见代码 代码 简单粗暴版 class Solution { public boolean isPalindrome(int x) { if (x \u0026lt; 0) { return false; } long res","title":"LeetCode 9"},{"content":"思路 两种思路：\n一次遍历 先去除前导空格，然后判断符号位，最后读取数字，注意溢出判断可以通过res除以10是否等于之前的res来判断，详见代码\n自动机 详见：https://leetcode.cn/problems/string-to-integer-atoi/solutions/183164/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/\n可以把这个当成模板\n代码 一次遍历 class Solution { public int myAtoi(String s) { int res = 0, sign = 1, i = 0, n = s.length(); for (; i \u0026lt; n; i++) { if (s.charAt(i) != \u0026#39; \u0026#39;) { break; } } if (i \u0026lt; n \u0026amp;\u0026amp; (s.charAt(i) == \u0026#39;+\u0026#39; || s.charAt(i) == \u0026#39;-\u0026#39;)) { if (s.charAt(i) == \u0026#39;-\u0026#39;) { sign = -1; } i++; } for (; i \u0026lt; n; i++) { if (s.charAt(i) \u0026lt; \u0026#39;0\u0026#39; || s.charAt(i) \u0026gt; \u0026#39;9\u0026#39;) { break; } int pre = res; res = res * 10 + s.charAt(i) - \u0026#39;0\u0026#39;; if (res / 10 != pre) { return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; } } return sign * res; } } 自动机 class Solution { public int myAtoi(String s) { Automaton automaton = new Automaton(); for (char c : s.toCharArray()) { automaton.get(c); } return (int) (automaton.sign * automaton.res); } class Automaton { int sign = 1; long res = 0; String state = \u0026#34;start\u0026#34;; Map\u0026lt;String, String[]\u0026gt; table = new HashMap\u0026lt;\u0026gt;() { { put(\u0026#34;start\u0026#34;, new String[]{\u0026#34;start\u0026#34;, \u0026#34;signed\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;signed\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;in_number\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;end\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;}); } }; public void get(char c) { state = table.get(state)[getCol(c)]; if (state == \u0026#34;in_number\u0026#34;) { res = res * 10 + c - \u0026#39;0\u0026#39;; res = sign == 1 ? Math.min(res, Integer.MAX_VALUE) : Math.min(res, -(long) Integer.MIN_VALUE); } else if (state == \u0026#34;signed\u0026#34;) { sign = c == \u0026#39;+\u0026#39; ? 1 : -1; } } private int getCol(char c) { if (c == \u0026#39; \u0026#39;) { return 0; } if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) { return 1; } if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return 2; } return 3; } } } References 1. 字符串转换整数 (atoi) ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-8/","summary":"思路 两种思路： 一次遍历 先去除前导空格，然后判断符号位，最后读取数字，注意溢出判断可以通过res除以10是否等于之前的res来判断，详见代码 自","title":"LeetCode 8"},{"content":"思路 每次取最后一位然后加到res上即可，需要注意这里的判断是否溢出：\nif (res \u0026gt; Integer.MAX_VALUE / 10 || res == Integer.MAX_VALUE / 10 \u0026amp;\u0026amp; num \u0026gt; 7) { return 0; } if (res \u0026lt; Integer.MIN_VALUE / 10 || res == Integer.MIN_VALUE / 10 \u0026amp;\u0026amp; num \u0026lt; -8) { return 0; } 但判断是否溢出还可以优化，res每次更新后除10，然后跟上一次的res比较一下，如果不相等，就是溢出：\nint pre = res; res = res * 10 + num; if (res / 10 != pre) { return 0; } 并且需要知道负数取余得到的结果还是负数\n代码 基本版 class Solution { public int reverse(int x) { int res = 0; while (x != 0) { int num = x % 10; if (res \u0026gt; Integer.MAX_VALUE / 10 || res == Integer.MAX_VALUE / 10 \u0026amp;\u0026amp; num \u0026gt; 7) { return 0; } if (res \u0026lt; Integer.MIN_VALUE / 10 || res == Integer.MIN_VALUE / 10 \u0026amp;\u0026amp; num \u0026lt; -8) { return 0; } res = res * 10 + num; x /= 10; } return res; } } 优化溢出判断 class Solution { public int reverse(int x) { int res = 0; while (x != 0) { int num = x % 10; int pre = res; res = res * 10 + num; if (res / 10 != pre) { return 0; } x /= 10; } return res; } } References 1. 整数反转 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-7/","summary":"思路 每次取最后一位然后加到res上即可，需要注意这里的判断是否溢出： if (res \u0026gt; Integer.MAX_VALUE / 10 || res == Integer.MAX_VALUE / 10 \u0026amp;\u0026amp; num \u0026gt; 7) { return 0; } if (res \u0026lt; Integer.MIN_VALUE / 10 || res == Integer.MIN_VALUE / 10 \u0026amp;\u0026amp; num \u0026lt; -8)","title":"LeetCode 7"},{"content":"思路 设置几个行，遍历字符串，每次将遍历到的字符加入行中，然后指针指向下一行，当指针到头之后，倒着改变指针就可以了\n代码 class Solution { public String convert(String s, int numRows) { if (numRows == 1) { return s; } StringBuilder[] rows = new StringBuilder[numRows]; for (int i = 0; i \u0026lt; numRows; i++) { rows[i] = new StringBuilder(); } int i = 0, flag = -1; for (char c : s.toCharArray()) { rows[i].append(c); if (i == 0 || i == numRows - 1) { flag = -flag; } i += flag; } StringBuilder res = new StringBuilder(); for (int j = 0; j \u0026lt; numRows; j++) { res.append(rows[j]); } return res.toString(); } } References 1. Z 字形变换 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-6/","summary":"思路 设置几个行，遍历字符串，每次将遍历到的字符加入行中，然后指针指向下一行，当指针到头之后，倒着改变指针就可以了 代码 class Solution { public String convert(String s, int numRows) { if (numRows","title":"LeetCode 6"},{"content":"思路 直接按位相加就可以了\n代码 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode res = new ListNode(), p = res; int c = 0; while (l1 != null || l2 != null) { int v1 = l1 == null ? 0 : l1.val; int v2 = l2 == null ? 0 : l2.val; p.next = new ListNode((v1 + v2 + c) % 10); p = p.next; c = (v1 + v2 + c) / 10; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; } if (c != 0) { p.next = new ListNode(c); } return res.next; } } References 1. 两数相加 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-2/","summary":"思路 直接按位相加就可以了 代码 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode res = new ListNode(), p = res; int c = 0; while (l1 != null || l2 != null) { int v1 = l1 == null ? 0 : l1.val; int v2 = l2 == null ? 0 : l2.val; p.next = new ListNode((v1 +","title":"LeetCode 2"},{"content":"思路 用map存一下，然后找有没有target - nums[i]即可，直接看代码。\n代码 class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int n = nums.length; for (int i = 0; i \u0026lt; n; i++) { if (map.containsKey(target - nums[i])) { return new int[]{map.get(target - nums[i]), i}; } map.put(nums[i], i); } return null; } } References 1. 两数之和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1/","summary":"思路 用map存一下，然后找有没有target - nums[i]即可，直接看代码。 代码 class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int n = nums.length; for (int i = 0; i \u0026lt; n; i++)","title":"LeetCode 1"},{"content":"思路 第一题 挨个除就完事了，直接看代码\n第二题 遍历每个元素，并求出他们的质因数加入到set集合，最后统计set里的元素即可\n第三题 贪心算法，从左往右求出刚好小于k的数，统计数量即可\n第四题 用素数筛法求出所有素数，然后根据素数之差求出最接近的两个素数\n总结 这次比较简单，半小时结束战斗\n代码 第一题 class Solution { public int countDigits(int num) { int n = num, res = 0; while (n != 0) { if (num % (n % 10) == 0) { res++; } n = n / 10; } return res; } } 第二题 class Solution { public int distinctPrimeFactors(int[] nums) { Set\u0026lt;Integer\u0026gt; res = new HashSet\u0026lt;\u0026gt;(); for (int num : nums) { for (int i = 2; i \u0026lt;= num;) { if (num % i == 0) { res.add(i); num /= i; } else { i++; } } } return res.size(); } } 第三题 class Solution { public int minimumPartition(String s, int k) { int i = 0, j = 1, res = 0; while (i \u0026lt; s.length()) { long num = Long.parseLong(s.substring(i, j)); if (num \u0026gt; k) { if (j == i + 1) { return -1; } else { res++; i = j - 1; } } else { if (j == s.length()) { res++; break; } j++; } } return res; } } 第四题 class Solution { public int[] closestPrimes(int left, int right) { boolean[] isPrime = new boolean[right + 1]; Arrays.fill(isPrime, true); for (int i = 2; i \u0026lt;= right; i++) { if (!isPrime[i]) { continue; } for (int j = i + i; j \u0026lt;= right; j += i) { isPrime[j] = false; } } isPrime[0] = isPrime[1] = false; int[] res = new int[]{0, 1000000}; int pre = -1; for (int i = left; i \u0026lt;= right; i++) { if (!isPrime[i]) { continue; } if (pre == -1) { pre = i; } else { if (i - pre \u0026lt; res[1] - res[0]) { res[0] = pre; res[1] = i; } pre = i; } } return res[0] == 0 \u0026amp;\u0026amp; res[1] == 1000000 ? new int[]{-1, -1} : res; } } References 1. 统计能整除数字的位数 2. 数组乘积中的不同质因数数目 3. 将字符串分割成值不超过 K 的子字符串 4. 范围内最接近的两个质数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-326/","summary":"思路 第一题 挨个除就完事了，直接看代码 第二题 遍历每个元素，并求出他们的质因数加入到set集合，最后统计set里的元素即可 第三题 贪心算法，从左往","title":"LeetCode 周赛 326"},{"content":"思路 利用并查集的思想，有倍数关系的变量通过并查集连接起来，并且将边的权值设为边两头的结点的倍数大小，当求两个变量的倍数关系时，判断这两个结点是否连通，并且求出两个结点到根节点的权值相除即可，要特别注意路径压缩时权值的更新，详见：https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/\n代码 class Solution { public double[] calcEquation(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; equations, double[] values, List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; queries) { int equationSize = values.length; UF uf = new UF(2 * equationSize); int id = 0; Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; equationSize; i++) { String v1 = equations.get(i).get(0); String v2 = equations.get(i).get(1); if (!map.containsKey(v1)) { map.put(v1, id); id++; } if (!map.containsKey(v2)) { map.put(v2, id); id++; } uf.union(map.get(v1), map.get(v2), values[i]); } int queriesSize = queries.size(); double[] res = new double[queriesSize]; for (int i = 0; i \u0026lt; queriesSize; i++) { Integer id1 = map.get(queries.get(i).get(0)); Integer id2 = map.get(queries.get(i).get(1)); if (id1 == null || id2 == null) { res[i] = -1; } else { res[i] = uf.isConnected(id1, id2); } } return res; } class UF { private int[] parent; private double[] weight; public UF(int n) { parent = new int[n]; weight = new double[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; weight[i] = 1; } } public void union(int p, int q, double value) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) { return; } parent[rootP] = rootQ; weight[rootP] = value * weight[q] / weight[p]; } public double isConnected(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP != rootQ) { return -1; } else { return weight[p] / weight[q]; } } public int find(int x) { if (x != parent[x]) { int origin = parent[x]; parent[x] = find(parent[x]); weight[x] *= weight[origin]; } return parent[x]; } } } References 1. 除法求值 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-399/","summary":"思路 利用并查集的思想，有倍数关系的变量通过并查集连接起来，并且将边的权值设为边两头的结点的倍数大小，当求两个变量的倍数关系时，判断这两个结点","title":"LeetCode 399"},{"content":"思路 三种思路：\n简单朴素版 跟两个有序的数组合并思路一样，谁小就取谁，这样找到中间的那个就行了\n二分查找 其实这道题就是查找第k小的元素，那么我们每次从两个数组各取k/2个元素，比较第k/2个元素的大小，小的那个数组可以排除前k/2个元素了，然后再在剩下的元素里找第k/2小元素，循环往复，直到找第1小元素即可\n划分数组 就是每次对较短的那个数组二分，同时根据元素总数计算另一个数组应该怎么划分，保证左边的元素数量等于右边的，为了找到中位数，所以必须保证左边的最大值小于右边的最小值，如果不满足就根据左边右边的大小关系对较短数组再次二分，直到满足左边与右边元素数量相等，并且左边元素都小于右边元素，此时就找到了中位数\n代码 简单朴素版 class Solution { public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length; int n = B.length; int len = m + n; int left = -1, right = -1; int aStart = 0, bStart = 0; for (int i = 0; i \u0026lt;= len / 2; i++) { left = right; if (aStart \u0026lt; m \u0026amp;\u0026amp; (bStart \u0026gt;= n || A[aStart] \u0026lt; B[bStart])) { right = A[aStart++]; } else { right = B[bStart++]; } } if ((len \u0026amp; 1) == 0) return (left + right) / 2.0; else return right; } } 二分查找 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length, n = nums2.length; if ((m + n) % 2 == 0) { return (getKth(nums1, 0, nums2, 0, (m + n) / 2) + getKth(nums1, 0, nums2, 0, (m + n) / 2 + 1)) / 2.0; } else { return getKth(nums1, 0, nums2, 0, (m + n) / 2 + 1); } } private int getKth(int[] nums1, int start1, int[] nums2, int start2, int k) { if (start1 == nums1.length) { return nums2[start2 + k - 1]; } if (start2 == nums2.length) { return nums1[start1 + k - 1]; } if (k == 1) { return Math.min(nums1[start1], nums2[start2]); } int i = Math.min(nums1.length - 1, start1 + k / 2 - 1); int j = Math.min(nums2.length - 1, start2 + k / 2 - 1); if (nums1[i] \u0026gt; nums2[j]) { return getKth(nums1, start1, nums2, j + 1, k - (j - start2 + 1)); } else { return getKth(nums1, i + 1, nums2, start2, k - (i - start1 + 1)); } } } 划分数组 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length, n = nums2.length; if (m \u0026gt; n) { return findMedianSortedArrays(nums2, nums1); } int iMin = 0, iMax = m; while (iMin \u0026lt;= iMax) { int i = (iMax + iMin) / 2; int j = (m + n + 1) / 2 - i; if (j != 0 \u0026amp;\u0026amp; i != m \u0026amp;\u0026amp; nums1[i] \u0026lt; nums2[j - 1]) { iMin = i + 1; } else if (i != 0 \u0026amp;\u0026amp; j != n \u0026amp;\u0026amp; nums1[i - 1] \u0026gt; nums2[j]) { iMax = i - 1; } else { int maxLeft = 0; if (i == 0) { maxLeft = nums2[j - 1]; } else if (j == 0) { maxLeft = nums1[i - 1]; } else { maxLeft = Math.max(nums1[i - 1], nums2[j - 1]); } if ((m + n) % 2 == 1) { return maxLeft; } int minRight = 0; if (i == m) { minRight = nums2[j]; } else if (j == n) { minRight = nums1[i]; } else { minRight = Math.min(nums1[i], nums2[j]); } return (maxLeft + minRight) / 2.0; } } return -1; } } References 1. 寻找两个正序数组的中位数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-4/","summary":"思路 三种思路： 简单朴素版 跟两个有序的数组合并思路一样，谁小就取谁，这样找到中间的那个就行了 二分查找 其实这道题就是查找第k小的元素，那么我们每","title":"LeetCode 4"},{"content":"思路 两种思路：\n暴力解法 遍历数组，将每个元素当成正方形的左上角，并检查此时正方形的面积，计算最大值即可，代码略\n动态规划 同LeetCode-85，只不过85是矩形，这里是正方形，计算面积的时候注意长宽一致即可，其实也可以不用85这种思路，也可以建立dp数组，dp[i][j] = x表示以[i][j]元素为正方形右下角的正方形边长最长为x，状态转移方程为：\ndp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; 为什么状态转移方程是这样的，想象一下就知道了，base case为第一行和第一列，可以优化空间复杂度，通过动态规划计算最长边长就行了\n代码 class Solution { public int maximalSquare(char[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] dp_left = new int[m + 1][n + 1], dp_up = new int[m + 1][n + 1]; int res = 0; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (matrix[i - 1][j - 1] == \u0026#39;0\u0026#39;) { continue; } dp_left[i][j] = dp_left[i][j - 1] + 1; dp_up[i][j] = dp_up[i - 1][j] + 1; int up = Integer.MAX_VALUE; for (int left = 1; left \u0026lt;= dp_left[i][j]; left++) { up = Math.min(up, dp_up[i][j + 1 - left]); if (up \u0026lt; left) { break; } res = Math.max(res, left * left); } } } return res; } } References 1. 最大正方形 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-221/","summary":"思路 两种思路： 暴力解法 遍历数组，将每个元素当成正方形的左上角，并检查此时正方形的面积，计算最大值即可，代码略 动态规划 同LeetCode-85","title":"LeetCode 221"},{"content":"思路 两种思路：\n动态规划 构造两个dp数组，分别存放当前元素上面有几个连续的1和左边有几个连续的1，状态转移方程为：\ndp_left[i][j] = dp_left[i][j - 1] + 1; dp_up[i][j] = dp_up[i - 1][j] + 1; base case为第一行和第一列，怎么根据这两个dp数组计算面积才是重点，可以将竖着连续的1看成一个个柱体，然后把当前遍历的元素当成矩阵的右下角，从当前元素往左遍历，同时根据柱体的高度，计算面积，取面积最大值即可\n单调栈 感觉没什么看的必要，没看\n代码 动态规划 class Solution { public int maximalRectangle(char[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] dp_left = new int[m + 1][n + 1], dp_up = new int[m + 1][n + 1]; int res = 0; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (matrix[i - 1][j - 1] == \u0026#39;0\u0026#39;) { continue; } dp_left[i][j] = dp_left[i][j - 1] + 1; dp_up[i][j] = dp_up[i - 1][j] + 1; int up = Integer.MAX_VALUE; for (int left = 1; left \u0026lt;= dp_left[i][j]; left++) { up = Math.min(up, dp_up[i][j + 1 - left]); res = Math.max(res, left * up); } } } return res; } } References 1. 最大矩形 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-85/","summary":"思路 两种思路： 动态规划 构造两个dp数组，分别存放当前元素上面有几个连续的1和左边有几个连续的1，状态转移方程为： dp_left[i][j] = dp_left[i][j - 1] + 1; dp_up[i][j] = dp_up[i - 1][j] + 1;","title":"LeetCode 85"},{"content":"思路 根本思想就是将字符串删去字符的所有情况都找出来，所以可以用DFS爆搜，就是对于每个括号字符，要么删，要么不删，并且在搜索过程中将不合理的情况剪枝（直接return即可），比如右括号比左括号多的情况，左括号或者右括号删多了的情况，如此一来只对合理情况进行判断，如果字符串是合理的，并且删除的左右括号数量也正确，那这个字符串就是结果之一，将这些字符串加入Set去重即可\n详见：https://leetcode.cn/problems/remove-invalid-parentheses/solutions/1068652/gong-shui-san-xie-jiang-gua-hao-de-shi-f-asu8/\n代码 class Solution { private Set\u0026lt;String\u0026gt; res = new HashSet\u0026lt;\u0026gt;(); private int max, n, len = -1; private String str; public List\u0026lt;String\u0026gt; removeInvalidParentheses(String s) { str = s; n = s.length(); int left = 0, right = 0; int deleteLeft = 0, deleteRight = 0; for (char c : s.toCharArray()) { if (c == \u0026#39;(\u0026#39;) { left++; deleteLeft++; } else if (c == \u0026#39;)\u0026#39;) { right++; if (deleteLeft == 0) { deleteRight++; } else { deleteLeft--; } } } len = n - deleteLeft - deleteRight; max = Math.min(left, right); dfs(0, \u0026#34;\u0026#34;, deleteLeft, deleteRight, 0); return new ArrayList\u0026lt;\u0026gt;(res); } private void dfs(int start, String curr, int deleteLeft, int deleteRight, int score) { if (score \u0026lt; 0 || score \u0026gt; max || deleteLeft \u0026lt; 0 || deleteRight \u0026lt; 0) { return; } if (deleteLeft == 0 \u0026amp;\u0026amp; deleteRight == 0 \u0026amp;\u0026amp; curr.length() == len) { res.add(curr); } if (start == n) { return; } char c = str.charAt(start); if (c == \u0026#39;(\u0026#39;) { dfs(start + 1, curr + c, deleteLeft, deleteRight, score + 1); dfs(start + 1, curr,deleteLeft - 1, deleteRight, score); } else if (c == \u0026#39;)\u0026#39;) { dfs(start + 1, curr + c, deleteLeft, deleteRight, score - 1); dfs(start + 1, curr, deleteLeft, deleteRight - 1, score); } else { dfs(start + 1, curr + c, deleteLeft, deleteRight, score); } } } References 1. 删除无效的括号 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-301/","summary":"思路 根本思想就是将字符串删去字符的所有情况都找出来，所以可以用DFS爆搜，就是对于每个括号字符，要么删，要么不删，并且在搜索过程中将不合理的","title":"LeetCode 301"},{"content":"思路 两种思路：\n排序+检测位置不对的元素 先复制数组，然后排序，再比较排序后的数组和原数组，看看哪些位置不对即可\nO(N)时间复杂度 由于无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界，所以遍历两次确定这两个边界就可以了，详见代码\n代码 排序+检测位置不对的元素 public int findUnsortedSubarray(int[] nums) { int[] sortNums = Arrays.copyOf(nums, nums.length); Arrays.sort(sortNums); int left = -1, right = -2; for (int i = 0; i \u0026lt; nums.length; i++) { if (sortNums[i] != nums[i]) { if (left == -1) { left = i; right = i; } else { right = i; } } } return right - left + 1; } O(N)时间复杂度 class Solution { public int findUnsortedSubarray(int[] nums) { int n = nums.length, max = Integer.MIN_VALUE, right = -2; for (int i = 0; i \u0026lt; n; i++) { if (nums[i] \u0026lt; max) { right = i; } else { max = nums[i]; } } int min = Integer.MAX_VALUE, left = -1; for (int i = n - 1; i \u0026gt;= 0; i--) { if (nums[i] \u0026gt; min) { left = i; } else { min = nums[i]; } } return right - left + 1; } } References 1. 最短无序连续子数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-581/","summary":"思路 两种思路： 排序+检测位置不对的元素 先复制数组，然后排序，再比较排序后的数组和原数组，看看哪些位置不对即可 O(N)时间复杂度 由于无序子数组","title":"LeetCode 581"},{"content":"思路 两种思路：\n暴力枚举 把所有情况都列举出来，直接看代码\n动态规划 这里需要构建两个dp数组，因为以当前元素结尾的乘积最大子数组不一定是由前面元素结尾的乘积最大子数组推出来的，也有可能是由乘积最小子数组推出来的，所以需要dp_min和dp_max连个数组，里面存放以当前元素结尾的乘积最小子数组和乘积最大子数组，状态转移方程为：\ndp_max[i] = Math.max(nums[i], Math.max(nums[i] * dp_max[i - 1], nums[i] * dp_min[i - 1])); dp_min[i] = Math.min(nums[i], Math.min(nums[i] * dp_max[i - 1], nums[i] * dp_min[i - 1])); base case为dp_min[0] = dp_max[0] = nums[0];，可以优化空间复杂度\n代码 暴力枚举 class Solution { public int maxProduct(int[] nums) { int res = Integer.MIN_VALUE, n = nums.length; for (int i = 0; i \u0026lt; n; i++) { int mul = 1; for (int j = i; j \u0026lt; n; j++) { mul *= nums[j]; res = Math.max(res, mul); } } return res; } } 动态规划 class Solution { public int maxProduct(int[] nums) { int n = nums.length; int[] dp_min = new int[n], dp_max = new int[n]; dp_min[0] = dp_max[0] = nums[0]; int res = dp_max[0]; for (int i = 1; i \u0026lt; n; i++) { dp_max[i] = Math.max(nums[i], Math.max(nums[i] * dp_max[i - 1], nums[i] * dp_min[i - 1])); dp_min[i] = Math.min(nums[i], Math.min(nums[i] * dp_max[i - 1], nums[i] * dp_min[i - 1])); res = Math.max(res, dp_max[i]); } return res; } } References 1. 乘积最大子数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-152/","summary":"思路 两种思路： 暴力枚举 把所有情况都列举出来，直接看代码 动态规划 这里需要构建两个dp数组，因为以当前元素结尾的乘积最大子数组不一定是由前面元素","title":"LeetCode 152"},{"content":"思路 两种思路：\nDFS 遍历二叉树的所有结点，遍历到每个结点同时计算以此结点为头部，往下拓展有几个路径之和为target的情况，求和即可\n前缀和 基本思想同LeetCode-560，我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 curr 减去 targetSum，其实跟LeetCode-560一样，就是变成了二叉树的前缀和，而且要注意需要提前记录前缀和0，遍历完当前结点记得从map中去除当前的前缀和\n代码 DFS class Solution { public int pathSum(TreeNode root, int targetSum) { if (root == null) { return 0; } int res = 0; res += rootSum(root, targetSum); res += pathSum(root.left, targetSum); res += pathSum(root.right, targetSum); return res; } private int rootSum(TreeNode root, long targetSum) { if (root == null) { return 0; } int res = 0; if (targetSum == root.val) { res++; } return rootSum(root.left, targetSum - root.val) + rootSum(root.right, targetSum - root.val) + res; } } 前缀和 class Solution { private Map\u0026lt;Long, Integer\u0026gt; preSumMap = new HashMap\u0026lt;\u0026gt;(); public int pathSum(TreeNode root, int targetSum) { preSumMap.put(0L, 1); return dfs(root, 0, targetSum); } private int dfs(TreeNode root, long preSum, int targetSum) { if (root == null) { return 0; } preSum += root.val; int res = 0; res += preSumMap.getOrDefault(preSum - targetSum, 0); preSumMap.put(preSum, preSumMap.getOrDefault(preSum, 0) + 1); res += dfs(root.left, preSum, targetSum); res += dfs(root.right, preSum, targetSum); preSumMap.put(preSum, preSumMap.get(preSum) - 1); return res; } } References 1. 路径总和 III ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-437/","summary":"思路 两种思路： DFS 遍历二叉树的所有结点，遍历到每个结点同时计算以此结点为头部，往下拓展有几个路径之和为target的情况，求和即可 前缀和 基本思","title":"LeetCode 437"},{"content":"思路 从右上角看成一颗二叉搜索树即可，如果当前元素大于target说明整列都大于target，所以这一列可以忽略，去掉这一列的矩阵还是一个矩阵，如果当前元素小于target说明整行都小于target，所以这一行可以忽略，去掉这一行的矩阵还是一个矩阵，循环往复，其实就是一个Z字形查找，如果能找到，那就返回，如果查找时超过了边界，那就是查找失败\n代码 class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int i = 0, j = n - 1; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0) { if (matrix[i][j] == target) { return true; } else if (matrix[i][j] \u0026gt; target) { j--; } else if (matrix[i][j] \u0026lt; target) { i++; } } return false; } } References 1. 搜索二维矩阵 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-240/","summary":"思路 从右上角看成一颗二叉搜索树即可，如果当前元素大于target说明整列都大于target，所以这一列可以忽略，去掉这一列的矩阵还是一个矩阵","title":"LeetCode 240"},{"content":"思路 三种思路：\n中心扩展法 遍历字符串，然后从中心扩展，同时统计回文串的数量\n动态规划 设置dp数组，dp[i][j] = x代表[i\u0026hellip;j]字符串是否是回文串，状态转移方程为：dp[i][j] = s.charAt(i) == s.charAt(j) \u0026amp;\u0026amp; (j - i \u0026lt; 2 || dp[i + 1][j - 1])，base case为下半个三角都是true，可以优化空间复杂度\n马拉车算法 没看太懂，感觉不太重要，大致来说就是中心扩展法的优化，可以在O(N)时间内完成中心扩展法这个流程，基本思想就是假如已知一个回文串，那么在这个回文串中左右对称的那两个字符，中心扩展的回文串是一样的（如果扩展的范围没有超过原回文串的范围）\n代码 中心扩展法 class Solution { public int countSubstrings(String s) { int n = s.length(), res = 0; res += countSubstrings(s, 0, 0); for (int i = 1; i \u0026lt; n; i++) { res += countSubstrings(s, i, i); res += countSubstrings(s, i - 1, i); } return res; } private int countSubstrings(String s, int i, int j) { int res = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(i) == s.charAt(j)) { res++; i--; j++; } return res; } } 动态规划 class Solution { public int countSubstrings(String s) { int n = s.length(), res = 0; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = i; j \u0026lt; n; j++) { if (s.charAt(i) == s.charAt(j) \u0026amp;\u0026amp; (j - i \u0026lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; res++; } } } return res; } } References 1. 回文子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-647/","summary":"思路 三种思路： 中心扩展法 遍历字符串，然后从中心扩展，同时统计回文串的数量 动态规划 设置dp数组，dp[i][j] = x代表[i\u0026hellip;j","title":"LeetCode 647"},{"content":"思路 利用前缀和的思想，从左往右遍历一遍，从右往左遍历一遍同时记录该数组的左右乘积，每个元素的左乘积乘以右乘积就是答案，还可以优化空间复杂度，把返回数组res当成左乘积数组，同时用一个变量充当右乘积，详见代码\n代码 前缀和 class Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] L = new int[n], R = new int[n]; L[0] = 1; for (int i = 1; i \u0026lt; n; i++) { L[i] = L[i - 1] * nums[i - 1]; } R[n - 1] = 1; for (int i = n - 2; i \u0026gt;= 0; i--) { R[i] = R[i + 1] * nums[i + 1]; } int[] res = new int[n]; for (int i = 0; i \u0026lt; n; i++) { res[i] = L[i] * R[i]; } return res; } } 前缀和+空间复杂度优化 class Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] res = new int[n]; res[0] = 1; for (int i = 1; i \u0026lt; n; i++) { res[i] = res[i - 1] * nums[i - 1]; } int R = 1; for (int i = n - 1; i \u0026gt;= 0; i--) { res[i] = res[i] * R; R *= nums[i]; } return res; } } References 1. 除自身以外数组的乘积 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-238/","summary":"思路 利用前缀和的思想，从左往右遍历一遍，从右往左遍历一遍同时记录该数组的左右乘积，每个元素的左乘积乘以右乘积就是答案，还可以优化空间复杂度，","title":"LeetCode 238"},{"content":"思路 这道题明显符合贪心性质，即每次选择需要执行次数最多的且可以执行的任务，这样执行完任务所需的时间就是最优解，以此为根据有两种思路：\n模拟 建立一个大根堆，里面放各种任务所需的执行次数，每次弹出min(queue.size(),n)这么多个元素，每个元素都让他都减一，然后再把元素放回去，res += n，最终得到的res就是答案\n脑筋急转弯-构造（桶思想） 如下图，把一轮任务的执行想象成一个桶即可，如果能把桶填满，那所需时间就是tasks.length，如果不能那就是桶所占的空间，会不会出现C这个任务在第四行开始，然后排到下一列的第三行呢？这样的话C的执行就冲突了，答：不会，因为我们是按照降序的顺序将任务排列的，如果这样的话C就有5个了，一定会单独占一列，从中间开始排，说明C肯定是小于5的\n详见：https://leetcode.cn/problems/task-scheduler/solutions/196302/tong-zi-by-popopop/\n代码 模拟 class Solution { public int leastInterval(char[] tasks, int n) { Map\u0026lt;Character, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (char task : tasks) { counter.put(task, counter.getOrDefault(task, 0) + 1); } Queue\u0026lt;Integer\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b - a; }); for (Integer value : counter.values()) { queue.offer(value); } int res = 0; while (!queue.isEmpty()) { int count = n + 1; List\u0026lt;Integer\u0026gt; temp = new LinkedList\u0026lt;\u0026gt;(); while (!queue.isEmpty() \u0026amp;\u0026amp; count != 0) { int i = queue.poll() - 1; res++; count--; if (i != 0) { temp.add(i); } } if (!temp.isEmpty()) { res += count; } queue.addAll(temp); } return res; } } 脑筋急转弯-构造（桶思想） class Solution { public int leastInterval(char[] tasks, int n) { int max = Integer.MIN_VALUE; Map\u0026lt;Character, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (char task : tasks) { counter.put(task, counter.getOrDefault(task, 0) + 1); max = Math.max(max, counter.get(task)); } int count = 0; for (Integer value : counter.values()) { if (value == max) { count++; } } return Math.max(tasks.length, (max - 1) * (n + 1) + count); } } References 1. 任务调度器 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-621/","summary":"思路 这道题明显符合贪心性质，即每次选择需要执行次数最多的且可以执行的任务，这样执行完任务所需的时间就是最优解，以此为根据有两种思路： 模拟 建立","title":"LeetCode 621"},{"content":"思路 两种思路：\n递归（DFS） 直接看代码\n迭代（BFS） 构建三个队列，分别存放需要合并子结点的合并后的结点、相应的第一颗树的结点、相应的第二颗树的结点，然后每次从三个队列里各取一个，然后看看应该怎么合并他们的子结点，详见：https://leetcode.cn/problems/merge-two-binary-trees/solutions/424201/he-bing-er-cha-shu-by-leetcode-solution/\n代码 递归（DFS） class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null \u0026amp;\u0026amp; root2 == null) { return null; } if (root1 != null \u0026amp;\u0026amp; root2 != null) { root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left, root2.left); root1.right = mergeTrees(root1.right, root2.right); return root1; } return root1 != null ? root1 : root2; } } 迭代（BFS） class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) { return root2; } if (root2 == null) { return root1; } TreeNode root = new TreeNode(root1.val + root2.val); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue1 = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue2 = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root);queue1.offer(root1);queue2.offer(root2); while (!queue.isEmpty()) { TreeNode node = queue.poll(), node1 = queue1.poll(), node2 = queue2.poll(); TreeNode left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right; if (left1 != null || left2 != null) { if (left1 != null \u0026amp;\u0026amp; left2 != null) { TreeNode left = new TreeNode(left1.val + left2.val); node.left = left; queue.offer(left); queue1.offer(left1); queue2.offer(left2); } else { node.left = left1 != null ? left1 : left2; } } if (right1 != null || right2 != null) { if (right1 != null \u0026amp;\u0026amp; right2 != null) { TreeNode right = new TreeNode(right1.val + right2.val); node.right = right; queue.offer(right); queue1.offer(right1); queue2.offer(right2); } else { node.right = right1 != null ? right1 : right2; } } } return root; } } References 1. 合并二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-617/","summary":"思路 两种思路： 递归（DFS） 直接看代码 迭代（BFS） 构建三个队列，分别存放需要合并子结点的合并后的结点、相应的第一颗树的结点、相应的第二颗树","title":"LeetCode 617"},{"content":"思路 两种思路：\n枚举 把所有情况都求出来，简单粗暴\n前缀和+哈希表优化 利用前缀和的思想，假如[i\u0026hellip;j]的和为k，那么就是preSum[j] - preSum[i - 1] == k -\u0026gt; preSum[j] - k == preSum[i - 1]，那么遍历到preSum[j]时，只要判断一下preSum[j]前有没有元素等于preSum[j] - k就可以了，为了加快查找速度，可以设置map，key为preSum里的元素，value为该元素值的个数，详见：https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/\n代码 枚举 class Solution { public int subarraySum(int[] nums, int k) { int n = nums.length, res = 0; for (int i = 0; i \u0026lt; n; i++) { int sum = 0; for (int j = i; j \u0026lt; n; j++) { sum += nums[j]; if (sum == k) { res++; } } } return res; } } 前缀和+哈希表优化 class Solution { public int subarraySum(int[] nums, int k) { int n = nums.length, pre = 0, res = 0; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, 1); for (int i = 0; i \u0026lt; n; i++) { pre += nums[i]; if (map.containsKey(pre - k)) { res += map.get(pre - k); } map.put(pre, map.getOrDefault(pre, 0) + 1); } return res; } } References 1. 和为 K 的子数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-560/","summary":"思路 两种思路： 枚举 把所有情况都求出来，简单粗暴 前缀和+哈希表优化 利用前缀和的思想，假如[i\u0026hellip;j]的和为k，那么就是preSum","title":"LeetCode 560"},{"content":"思路 先将x和y异或，再运用x \u0026amp; (x - 1)去除x最右侧的1（即Brian Kernighan算法），即可统计1的数目\n代码 class Solution { public int hammingDistance(int x, int y) { int z = x ^ y, res = 0; while (z != 0) { z = z \u0026amp; (z - 1); res++; } return res; } } References ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-461/","summary":"思路 先将x和y异或，再运用x \u0026amp; (x - 1)去除x最右侧的1（即Brian Kernighan算法），即可统计1的数目 代码 class Solution { public int hammingDistance(int x, int y) { int z =","title":"LeetCode 461"},{"content":"思路 原地哈希即可，同LeetCode-41\n代码 class Solution { public List\u0026lt;Integer\u0026gt; findDisappearedNumbers(int[] nums) { int n = nums.length, i = 0; while (i \u0026lt; n) { if (nums[i] == nums[nums[i] - 1]) { i++; continue; } swap(nums, i, nums[i] - 1); } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); for (int j = 0; j \u0026lt; n; j++) { if (nums[j] != j + 1) { res.add(j + 1); } } return res; } private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } References 1. 找到所有数组中消失的数字 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-448/","summary":"思路 原地哈希即可，同LeetCode-41 代码 class Solution { public List\u0026lt;Integer\u0026gt; findDisappearedNumbers(int[] nums) { int n = nums.length, i = 0; while (i \u0026lt; n) { if (nums[i] == nums[nums[i] - 1]) { i++; continue; } swap(nums, i, nums[i] - 1); } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); for (int j = 0; j","title":"LeetCode 448"},{"content":"思路 我们可以将每个人按照身高从大到小进行排序，然后依次将每个人放入队列中，那么当我们放入第 i 个人时，由于之后的人都比 i 矮，所以不会对 i 当前的插入位置产生影响，所以此时 i 插入的位置其实已经确定了，就是people[i][1]个人后面\n代码 class Solution { public int[][] reconstructQueue(int[][] people) { List\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); Arrays.sort(people, (a, b) -\u0026gt; { if (a[0] == b[0]) { return a[1] - b[1]; } return b[0] - a[0]; }); for (int i = 0; i \u0026lt; people.length; i++) { queue.add(people[i][1], people[i]); } queue.toArray(people); return people; } } References 1. 根据身高重建队列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-406/","summary":"思路 我们可以将每个人按照身高从大到小进行排序，然后依次将每个人放入队列中，那么当我们放入第 i 个人时，由于之后的人都比 i 矮，所以不会对 i 当前的","title":"LeetCode 406"},{"content":"思路 两种思路：\n递归 一种是模拟递归（就是我写的），一种是利用文法（见：https://leetcode.cn/problems/decode-string/solutions/264391/zi-fu-chuan-jie-ma-by-leetcode-solution/）\n模拟递归就是从左往右遍历字符串，碰到字母就加入结果中，碰到数字就读取数字，碰到\u0026rsquo;[\u0026lsquo;就递归获取中括号里面的字符串用于拼接，碰到\u0026rsquo;]\u0026lsquo;就直接返回，因为这里碰到\u0026rsquo;]\u0026lsquo;就说明本次调用是求[]里面的字符串，正常情况下是不会碰到\u0026rsquo;]\u0026lsquo;的，遍历完字符串就得到了结果\n栈 遍历这个字符串：\n如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈 如果当前的字符为字母或者左括号，直接进栈 如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈 重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。\n代码 递归 class Solution { public String decodeString(String s) { StringBuilder sb = new StringBuilder(); int num = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) { sb.append(c); } else if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { num = num * 10 + c - \u0026#39;0\u0026#39;; } else if (c == \u0026#39;[\u0026#39;) { String str = decodeString(s.substring(i + 1)); while (num != 0) { sb.append(str); num--; } int needRight = 0; while (needRight != -1) { i++; c = s.charAt(i); if (c == \u0026#39;[\u0026#39;) { needRight++; } if (c == \u0026#39;]\u0026#39;) { needRight--; } } } else if (c == \u0026#39;]\u0026#39;) { return sb.toString(); } } return sb.toString(); } } 栈 class Solution { public String decodeString(String s) { int n = s.length(), i = 0; Deque\u0026lt;String\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); while (i \u0026lt; n) { char c = s.charAt(i); if (Character.isLetter(c) || c == \u0026#39;[\u0026#39;) { stack.push(String.valueOf(c)); i++; } else if (Character.isDigit(c)) { int num = 0; while (Character.isDigit(s.charAt(i))) { num = num * 10 + s.charAt(i) - \u0026#39;0\u0026#39;; i++; } stack.push(String.valueOf(num)); } else if (c == \u0026#39;]\u0026#39;) { i++; String sub = \u0026#34;\u0026#34;; while (!stack.peek().equals(\u0026#34;[\u0026#34;)) { sub = stack.pop() + sub; } stack.pop(); int num = Integer.parseInt(stack.pop()); String t = \u0026#34;\u0026#34;; while (num != 0) { t = t + sub; num--; } stack.push(t); } } String res = \u0026#34;\u0026#34;; while (!stack.isEmpty()) { res = stack.pop() + res; } return res; } } References 1. 字符串解码 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-394/","summary":"思路 两种思路： 递归 一种是模拟递归（就是我写的），一种是利用文法（见：https://leetcode.cn/problems/decode-","title":"LeetCode 394"},{"content":"思路 简单粗暴版 用map统计次数，用优先队列根据次数选择前k个，具体看代码\n最小堆 用map统计次数，然后将map转为entry数组，原问题就转换为了求数组里的前 k 大的值，这个问题用最小堆即可解决，同LeetCode-215\n快速选择 用map统计次数，然后将map转为entry数组，原问题就转换为了求数组里的前 k 大的值，利用快速选择的思想，每次随机确定一个中枢的位置，如果比中枢大的元素等于k个，那就找到了这k个元素，如果小于k个，那么就确定了比中枢大的几个元素，其他元素在中枢左边，对左边继续这个过程，如果大于k个，对右边继续这个过程\n代码 简单粗暴版 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { counter.put(num, counter.getOrDefault(num, 0) + 1); } Queue\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b.getValue() - a.getValue(); }); pq.addAll(counter.entrySet()); int[] res = new int[k]; for (int i = 0; i \u0026lt; k; i++) { res[i] = pq.poll().getKey(); } return res; } } 最小堆 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { counter.put(num, counter.getOrDefault(num, 0) + 1); } Queue\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(k, (a, b) -\u0026gt; { return a.getValue() - b.getValue(); }); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : counter.entrySet()) { if (pq.size() \u0026lt; k) { pq.offer(entry); } else { if (entry.getValue() \u0026gt; pq.peek().getValue()) { pq.poll(); pq.offer(entry); } } } int[] res = new int[k]; for (int i = 0; i \u0026lt; k; i++) { res[i] = pq.poll().getKey(); } return res; } } 快速选择 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; counter = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { counter.put(num, counter.getOrDefault(num, 0) + 1); } Map.Entry\u0026lt;Integer, Integer\u0026gt;[] entries = new Map.Entry[counter.size()]; counter.entrySet().toArray(entries); int[] res = new int[k]; quickSort(entries, 0, entries.length - 1, res, 0, k); return res; } private void quickSort(Map.Entry\u0026lt;Integer, Integer\u0026gt;[] entries, int left, int right, int[] res, int resIndex, int k) { int picked = new Random().nextInt(right - left + 1) + left; swap(entries, left, picked); int pivot = entries[left].getValue(); int index = left; for (int i = left + 1; i \u0026lt;= right; i++) { if (entries[i].getValue() \u0026gt; pivot) { swap(entries, index + 1, i); index++; } } swap(entries, left, index); if (index - left \u0026gt; k) { quickSort(entries, left, index - 1, res, resIndex, k); } else { for (int i = left; i \u0026lt; index; i++) { res[resIndex++] = entries[i].getKey(); } if (index - left \u0026lt;= k -1) { res[resIndex++] = entries[index].getKey(); if (index - left \u0026lt; k -1) { quickSort(entries, index + 1, right, res, resIndex, k - index + left - 1); } } } } private void swap(Map.Entry\u0026lt;Integer, Integer\u0026gt;[] entries, int a, int b) { Map.Entry\u0026lt;Integer, Integer\u0026gt; temp = entries[a]; entries[a] = entries[b]; entries[b] = temp; } } References 1. 前 K 个高频元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-347/","summary":"思路 简单粗暴版 用map统计次数，用优先队列根据次数选择前k个，具体看代码 最小堆 用map统计次数，然后将map转为entry数组，原问题就转换","title":"LeetCode 347"},{"content":"思路 两种思路：\n常规思路 可以使用i \u0026amp; (i - 1)可以去掉i最右边的一个1这个技巧，提升计算一个数比特1数目的速度\n动态规划 对于所有的数字，只有两类：\n奇数，二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1 偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的 另外，0 的 1 个数为 0，这就是base case，动态规划即可，dp定义与状态转移方程详见代码\n还有其他动态规划的方式，详见：https://leetcode.cn/problems/counting-bits/solutions/627418/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/\n代码 常规思路 class Solution { public int[] countBits(int n) { int[] res = new int[n + 1]; for (int i = 0; i \u0026lt;= n; i++) { res[i] = getCount(i); } return res; } private int getCount(int n) { int count = 0; while (n != 0) { n = n \u0026amp; (n - 1); count++; } return count; } } 动态规划 class Solution { public int[] countBits(int n) { int[] dp = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { if (i % 2 == 1) { dp[i] = dp[i - 1] + 1; } else { dp[i] = dp[i / 2]; } } return dp; } } References 1. 比特位计数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-338/","summary":"思路 两种思路： 常规思路 可以使用i \u0026amp; (i - 1)可以去掉i最右边的一个1这个技巧，提升计算一个数比特1数目的速度 动态规划 对于所有的数字，只有两类：","title":"LeetCode 338"},{"content":"思路 原地哈希即可，将1-n的数字放在索引0-n-1里面，这样最后再遍历一遍，不满足这个规则的就是缺失的第一个正数\n代码 class Solution { public int firstMissingPositive(int[] nums) { int n = nums.length, i = 0; while (i \u0026lt; n) { if (nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= n \u0026amp;\u0026amp; nums[nums[i] - 1] != nums[i]) { swap(nums, i, nums[i] - 1); } else { i++; } } for (int j = 0; j \u0026lt; n; j++) { if (nums[j] != j + 1) { return j + 1; } } return n + 1; } private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } References 1. 缺失的第一个正数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-41/","summary":"思路 原地哈希即可，将1-n的数字放在索引0-n-1里面，这样最后再遍历一遍，不满足这个规则的就是缺失的第一个正数 代码 class Solution { public int firstMissingPositive(int[] nums) { int n = nums.length,","title":"LeetCode 41"},{"content":"思路 原地哈希 将元素和索引一一对应，不对应的交换元素使其对应，当碰到对应索引已经有相应的元素时，就找到了重复的元素\n快慢指针 将索引对应的元素当成下一个索引，按照这个逻辑把数组转换为链表，由于肯定存在重复元素，所以肯定会有多对一的映射，所以该链表一定会有环，那么这个问题就转换为了存在环的链表中寻找环起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置，直接返回即可，详见：https://leetcode.cn/problems/find-the-duplicate-number/solutions/58841/287xun-zhao-zhong-fu-shu-by-kirsche/\n二分查找 可以在1-n中取中点mid，遍历一边nums，如果小于等于mid的元素\u0026gt;mid说明重复元素一定在mid的左边，然后二分查找即可，这样比1-n一个一个查找要快，因为一次可以排除一半\n二进制 没看，感觉没什么卵用\n代码 原地哈希 class Solution { public int findDuplicate(int[] nums) { int n = nums.length, i = 0; while (i \u0026lt; n) { if (nums[i] == i + 1) { i++; continue; } if (nums[nums[i] - 1] == nums[i]) { return nums[i]; } swap(nums, i, nums[i] - 1); } return -1; } private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } 快慢指针 class Solution { public int findDuplicate(int[] nums) { int slow = 0, fast = 0; slow = nums[slow]; fast = nums[nums[fast]]; while (slow != fast) { slow = nums[slow]; fast = nums[nums[fast]]; } fast = 0; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } } 二分查找 class Solution { public int findDuplicate(int[] nums) { int left = 1, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; int count = 0; for (int num : nums) { if (num \u0026lt;= mid) { count++; } } if (count \u0026gt; mid) { right = mid; } else { left = mid + 1; } } return left; } } References 1. 寻找重复数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-287/","summary":"思路 原地哈希 将元素和索引一一对应，不对应的交换元素使其对应，当碰到对应索引已经有相应的元素时，就找到了重复的元素 快慢指针 将索引对应的元素当成","title":"LeetCode 287"},{"content":"思路 记忆化回溯 就是带备忘录的暴力算法，numSquares函数的定义为给定一个数n，返回n的完全平方数，具体做法就是将一个数有可能的平方数一个一个试，看看用哪个数最终答案会比较小，然后存进备忘录并返回，由于记忆化回溯等价于动态规划，所以还有动态规划的做法\n动态规划 设置dp数组，dp数组李存放当前索引的完全平方数，状态转移方程为：\nfor (int j = 1; j \u0026lt;= sqrt; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } base case为dp[0] = 0，不能优化空间复杂度\n数学 四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。详见：https://leetcode.cn/problems/perfect-squares/solutions/822940/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/\n代码 记忆化回溯 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int numSquares(int n) { if (n == 0) { return 0; } if (memo.containsKey(n)) { return memo.get(n); } int sqrt = (int) Math.sqrt(n); int min = Integer.MAX_VALUE; for (int i = sqrt; i \u0026gt;= 1; i--) { min = Math.min(min, numSquares( n - i * i)); } memo.put(n, min + 1); return min + 1; } } 动态规划 class Solution { public int numSquares(int n) { int[] dp = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { int sqrt = (int) Math.sqrt(i); dp[i] = Integer.MAX_VALUE; for (int j = 1; j \u0026lt;= sqrt; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } } return dp[n]; } } 数学 class Solution { public int numSquares(int n) { if (isPerfectSquare(n)) { return 1; } if (isAnswer4(n)) { return 4; } int sqrt = (int) Math.sqrt(n); for (int i = 1; i \u0026lt;= sqrt; i++) { if (isPerfectSquare(n - i * i)) { return 2; } } return 3; } private boolean isPerfectSquare(int n) { int sqrt = (int) Math.sqrt(n); return n == sqrt * sqrt; } private boolean isAnswer4(int n) { while (n % 4 == 0) { n /= 4; } return n % 8 == 7; } } References 1. 完全平方数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-279/","summary":"思路 记忆化回溯 就是带备忘录的暴力算法，numSquares函数的定义为给定一个数n，返回n的完全平方数，具体做法就是将一个数有可能的平方数一","title":"LeetCode 279"},{"content":"思路 两种思路：\n记忆化回溯 回溯算法暴力求解，一个一个单词试，不行就回溯，由于存在大量重叠子问题，所以可以用备忘录消除重叠子问题，又因为带备忘录的回溯就相当于动态规划，所以有了第二种思路\n动态规划 构建dp数组，数组元素为从当前索引元素开始的字符串，是否能被表示，状态转移方程为：\nfor (String word : wordList) { if (match(s, i, word) \u0026amp;\u0026amp; dp[i + word.length()]) { dp[i] = true; break; } } base case为dp数组最后一个元素设为true，不能优化空间复杂度\n代码 记忆化回溯 class Solution { private Map\u0026lt;Character, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private Map\u0026lt;Integer, Boolean\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { if (!map.containsKey(word.charAt(0))) { map.put(word.charAt(0), new LinkedList\u0026lt;\u0026gt;()); } map.get(word.charAt(0)).add(word); } return backtrack(s, 0); } private boolean backtrack(String s, int start) { if (start == s.length()) { return true; } if (memo.containsKey(start)) { return memo.get(start); } List\u0026lt;String\u0026gt; wordList = map.get(s.charAt(start)); if (wordList == null) { memo.put(start, false); return false; } for (String word : wordList) { if (!match(s, start, word)) { continue; } if (backtrack(s, start + word.length())) { return true; } } memo.put(start, false); return false; } private boolean match(String s, int start, String p) { if (p.length() \u0026gt; s.length() - start) { return false; } for (int i = 0; i \u0026lt; p.length(); i++) { if (s.charAt(start + i) != p.charAt(i)) { return false; } } return true; } } 动态规划 class Solution { private Map\u0026lt;Character, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { if (!map.containsKey(word.charAt(0))) { map.put(word.charAt(0), new LinkedList\u0026lt;\u0026gt;()); } map.get(word.charAt(0)).add(word); } boolean[] dp = new boolean[s.length() + 1]; dp[s.length()] = true; for (int i = s.length() - 1; i \u0026gt;= 0; i--) { List\u0026lt;String\u0026gt; wordList = map.get(s.charAt(i)); if (wordList == null) { continue; } for (String word : wordList) { if (match(s, i, word) \u0026amp;\u0026amp; dp[i + word.length()]) { dp[i] = true; break; } } } return dp[0]; } private boolean match(String s, int start, String p) { if (p.length() \u0026gt; s.length() - start) { return false; } for (int i = 0; i \u0026lt; p.length(); i++) { if (s.charAt(start + i) != p.charAt(i)) { return false; } } return true; } } References 1. 单词拆分 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-139/","summary":"思路 两种思路： 记忆化回溯 回溯算法暴力求解，一个一个单词试，不行就回溯，由于存在大量重叠子问题，所以可以用备忘录消除重叠子问题，又因为带备忘录","title":"LeetCode 139"},{"content":"思路 两种思路：\n最小堆 维护一个有 K 个元素的最小堆：\n如果当前堆不满，直接添加；\n堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新遍历到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。\n数组遍历完之后堆顶就是要找的元素\n快速选择 像快排一样随机确定一个中枢所在的位置，如果这个位置刚好就是要求的第k大的元素，就直接返回，否则根据中枢与target的大小关系选择是中枢左边还是右边继续随机确定一个中枢所在的位置，直到找到target，详见思想篇章\n手写堆 由于面试不让用Java的优先队列，所以需要手写堆，核心思想就三个：\n建堆：从从右往左的第一个非叶子结点开始下沉，遍历到根节点，堆就建好了 下沉：从子结点里选择一个较小（大）的，跟父节点比较，如果父节点需要下沉就交换两者的位置，然后继续这个过程 上浮：当前结点跟父节点比较，如果当前节点需要上浮就交换两者的位置，然后继续这个过程 注意点：\n设根节点的编号从1开始（不是从0开始，这样方便一些），这样的话父节点就是root/2，左孩子就是root*2，右孩子就是root*2+1，第一个非叶子结点就是size/2，size为堆的结点个数，也是结点最大的编号 分为有类版和无类版\n代码 最小堆 class Solution { public int findKthLargest(int[] nums, int k) { Queue\u0026lt;Integer\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; k; i++) { queue.offer(nums[i]); } for (int i = k; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; queue.peek()) { queue.poll(); queue.offer(nums[i]); } } return queue.peek(); } } 快速选择 class Solution { public int findKthLargest(int[] nums, int k) { int target = nums.length - k, left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int pivotIndex = partition(nums, left, right); if (pivotIndex \u0026gt; target) { right = pivotIndex - 1; } else if (pivotIndex \u0026lt; target) { left = pivotIndex + 1; } else { return nums[target]; } } return -1; } private int partition(int[] nums, int left, int right) { int randomIndex = new Random().nextInt(right - left + 1) + left; swap(nums, left, randomIndex); int pivot = nums[left]; while (left \u0026lt; right) { while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) { right--; } nums[left] = nums[right]; while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt;= pivot) { left++; } nums[right] = nums[left]; } nums[left] = pivot; return left; } private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } 手写堆 有类版 class Solution { // 手写堆 public int findKthLargest(int[] nums, int k) { MinPQ pq = new MinPQ(k); for (int i = 0; i \u0026lt; k; i++) { pq.insert(nums[i]); } for (int i = k; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; pq.min()) { pq.delMin(); pq.insert(nums[i]); } } return pq.delMin(); } class MinPQ { private int[] nums; private int size = 0; private int capacity; public MinPQ(int capacity) { this.capacity = capacity; nums = new int[capacity + 1]; } public boolean isEmpty() { return size == 0; } public boolean isFull() { return size == capacity; } public int min() { return nums[1]; } private int parent(int root) { return root / 2; } private int left(int root) { return root * 2; } private int right(int root) { return root * 2 + 1; } private void swap(int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } public void insert(int num) { size++; nums[size] = num; swim(size); } public int delMin() { int max = nums[1]; nums[1] = nums[size]; size--; sink(1); return max; } private void swim(int x) { while (x \u0026gt; 1 \u0026amp;\u0026amp; nums[x] \u0026lt; nums[parent(x)]) { swap(x, parent(x)); x = parent(x); } } private void sink(int x) { while (left(x) \u0026lt;= size) { int min = left(x); if (right(x) \u0026lt;= size \u0026amp;\u0026amp; nums[right(x)] \u0026lt; nums[min]) { min = right(x); } if (nums[x] \u0026lt; nums[min]) { break; } swap(x, min); x = min; } } } } 无类版 class Solution { public int findKthLargest(int[] nums, int k) { int[] heap = new int[k + 1]; for (int i = 0; i \u0026lt; k; i++) { heap[i + 1] = nums[i]; } buildHeap(heap); for (int i = k; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; heap[1]) { heap[1] = nums[i]; sink(heap, 1); } } return heap[1]; } private void buildHeap(int[] heap) { int size = heap.length - 1; for (int i = size / 2; i \u0026gt;= 1; i--) { sink(heap, i); } } private void sink(int[] heap, int x) { int size = heap.length - 1; while (x * 2 \u0026lt;= size) { int min = x * 2; if (x * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; heap[x * 2 + 1] \u0026lt; heap[min]) { min = x * 2 + 1; } if (heap[x] \u0026lt; heap[min]) { break; } swap(heap, x, min); x = min; } } private void swap(int[] heap, int i, int j) { int temp = heap[i]; heap[i] = heap[j]; heap[j] = temp; } } References 1. 数组中的第K个最大元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-215/","summary":"思路 两种思路： 最小堆 维护一个有 K 个元素的最小堆： 如果当前堆不满，直接添加； 堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只","title":"LeetCode 215"},{"content":"思路 值得学习的就两种思路：\n哈希 遍历一遍统计出现次数，并同时判断有没有超过n/2\nBoyer-Moore 投票算法 设置一个count变量和候选数字，遍历数组，如果当前遍历的元素是候选数字count++，否则count\u0026ndash;，如果count变量为0就将候选数字设置为当前遍历的元素，这样遍历到最后，候选数字就是众数，可以这样理解，因为众数一定比其他数字加一块还多，所以最后众数一定会超过其他数字，那么一定会在某一个时刻候选数字变成众数，详见题解：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/\n代码 哈希 class Solution { public int majorityElement(int[] nums) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int n = nums.length; for (int i = 0; i \u0026lt; n; i++) { map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); if (map.get(nums[i]) \u0026gt; n / 2) { return nums[i]; } } return -1; } } Boyer-Moore 投票算法 class Solution { public int majorityElement(int[] nums) { int candidate = 0, count = 0; for (int num : nums) { if (count == 0) { candidate = num; } count += candidate == num ? 1 : -1; } return candidate; } } References 1. 多数元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-169/","summary":"思路 值得学习的就两种思路： 哈希 遍历一遍统计出现次数，并同时判断有没有超过n/2 Boyer-Moore 投票算法 设置一个count变量和候选数字，遍历数组，如果当前","title":"LeetCode 169"},{"content":"思路 这道题的关键是getMin的实现，可以用一个辅助栈来存储每个元素入栈时的最小值，这样的话当元素出栈时也可以很容易的获取最小值\n代码 class MinStack { private Deque\u0026lt;Integer\u0026gt; stack, minStack; public MinStack() { this.stack = new ArrayDeque\u0026lt;\u0026gt;(); this.minStack = new ArrayDeque\u0026lt;\u0026gt;(); minStack.push(Integer.MAX_VALUE); } public void push(int val) { stack.push(val); minStack.push(val \u0026lt; minStack.peek() ? val : minStack.peek()); } public void pop() { stack.pop(); minStack.pop(); } public int top() { return stack.peek(); } public int getMin() { return minStack.peek(); } } References 1. 最小栈 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-155/","summary":"思路 这道题的关键是getMin的实现，可以用一个辅助栈来存储每个元素入栈时的最小值，这样的话当元素出栈时也可以很容易的获取最小值 代码 class MinStack { private","title":"LeetCode 155"},{"content":"思路 逆向思维，利用滑动窗口的思想，从两头删去k+个abc，相当于中间的区间中abc的数目小于其总数减去k，这样就可以使用滑动窗口解决了，模板见思想篇章\n代码 class Solution { public int takeCharacters(String s, int k) { int ka = 0, kb = 0, kc = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;a\u0026#39;) { ka++; } if (c == \u0026#39;b\u0026#39;) { kb++; } if (c == \u0026#39;c\u0026#39;) { kc++; } } ka -= k; kb -= k; kc -= k; if (ka \u0026lt; 0 || kb \u0026lt; 0 || kc \u0026lt; 0) { return -1; } int left = 0, right = 0, res = Integer.MIN_VALUE; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (c == \u0026#39;a\u0026#39;) { ka--; } if (c == \u0026#39;b\u0026#39;) { kb--; } if (c == \u0026#39;c\u0026#39;) { kc--; } while (ka \u0026lt; 0 || kb \u0026lt; 0 || kc \u0026lt; 0) { char d = s.charAt(left); left++; if (d == \u0026#39;a\u0026#39;) { ka++; } if (d == \u0026#39;b\u0026#39;) { kb++; } if (d == \u0026#39;c\u0026#39;) { kc++; } } res = Math.max(res, right - left); } return s.length() - res; } } References 1. 每种字符至少取 K 个 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-6270/","summary":"思路 逆向思维，利用滑动窗口的思想，从两头删去k+个abc，相当于中间的区间中abc的数目小于其总数减去k，这样就可以使用滑动窗口解决了，模板","title":"LeetCode 6270"},{"content":"思路 贪心算法，每次选择字典序较大的字符串的第一个字符拼接到merge后即可，唯一要记住的点是字符串比较大小的方式，见零碎部分\n代码 class Solution { public String largestMerge(String word1, String word2) { StringBuilder sb1 = new StringBuilder(word1); StringBuilder sb2 = new StringBuilder(word2); StringBuilder merge = new StringBuilder(); while (sb1.length() != 0 || sb2.length() != 0) { if (sb1.toString().compareTo(sb2.toString()) \u0026gt; 0) { merge.append(sb1.charAt(0)); sb1.deleteCharAt(0); } else { merge.append(sb2.charAt(0)); sb2.deleteCharAt(0); } } return merge.toString(); } } References 1. 构造字典序最大的合并字符串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1754/","summary":"思路 贪心算法，每次选择字典序较大的字符串的第一个字符拼接到merge后即可，唯一要记住的点是字符串比较大小的方式，见零碎部分 代码 class Solution { public String largestMerge(String","title":"LeetCode 1754"},{"content":"思路 同LeetCode-392，就是比较多个字符串\n代码 class Solution { public int numMatchingSubseq(String s, String[] words) { int n = s.length(); Map\u0026lt;Character, List\u0026lt;Integer\u0026gt;\u0026gt; index = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { char c = s.charAt(i); if (!index.containsKey(c)) { index.put(c, new ArrayList\u0026lt;\u0026gt;()); } index.get(c).add(i); } int res = 0; for (String word : words) { int j = 0, i = 0; for (; i \u0026lt; word.length(); i++) { char c = word.charAt(i); List\u0026lt;Integer\u0026gt; arr = index.get(c); if (arr == null) { break; } int pos = left_bound(arr, j); if (pos == -1) { break; } j = arr.get(pos) + 1; } if (i == word.length()) { res++; } } return res; } private int left_bound(List\u0026lt;Integer\u0026gt; nums, int target) { int left = 0, right = nums.size() - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026lt;= nums.get(mid)) { right = mid; } else { left = mid + 1; } } if (nums.get(left) \u0026lt; target) { return -1; } return left; } } References 1. 匹配子序列的单词数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-792/","summary":"思路 同LeetCode-392，就是比较多个字符串 代码 class Solution { public int numMatchingSubseq(String s, String[] words) { int n = s.length(); Map\u0026lt;Character, List\u0026lt;Integer\u0026gt;\u0026gt; index = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { char c = s.charAt(i); if (!index.containsKey(c)) { index.put(c, new ArrayList\u0026lt;\u0026gt;()); } index.get(c).add(i); }","title":"LeetCode 792"},{"content":"思路 将t中的字符及其位置都存到一个map中去，然后判断s中的字符是否都存在于该map中，并且该字符在t中的位置在前一个字符在t中的位置的后面，为了快速找到该位置的字符，可以用二分查找，因为位置在数组中是递增有序的，详见代码\n代码 class Solution { public boolean isSubsequence(String s, String t) { int m = s.length(), n = t.length(); Map\u0026lt;Character, List\u0026lt;Integer\u0026gt;\u0026gt; index = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { char c = t.charAt(i); if (!index.containsKey(c)) { index.put(c, new ArrayList\u0026lt;\u0026gt;()); } index.get(c).add(i); } int j = 0; for (int i = 0; i \u0026lt; m; i++) { char c = s.charAt(i); List\u0026lt;Integer\u0026gt; arr = index.get(c); if (arr == null) { return false; } int pos = left_bound(arr, j); if (pos == -1) { return false; } j = arr.get(pos) + 1; } return true; } private int left_bound(List\u0026lt;Integer\u0026gt; nums, int target) { int left = 0, right = nums.size() - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026lt;= nums.get(mid)) { right = mid; } else { left = mid + 1; } } if (nums.get(left) \u0026lt; target) { return -1; } return left; } } References 1. 判断子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-392/","summary":"思路 将t中的字符及其位置都存到一个map中去，然后判断s中的字符是否都存在于该map中，并且该字符在t中的位置在前一个字符在t中的位置的后面","title":"LeetCode 392"},{"content":"思路 从「面积」和「顶点」两个维度来判断：\n1、判断面积，通过完美矩形的理论坐标计算出一个理论面积，然后和 rectangles 中小矩形的实际面积和做对比。\n2、判断顶点，points 集合中应该只剩下 4 个顶点且剩下的顶点必须都是完美矩形的理论顶点。\n详见代码\n代码 class Solution { public boolean isRectangleCover(int[][] rectangles) { int n = rectangles.length; Set\u0026lt;String\u0026gt; points = new HashSet\u0026lt;\u0026gt;(); int X1 = Integer.MAX_VALUE, X2 = Integer.MIN_VALUE, Y1 = Integer.MAX_VALUE, Y2 = Integer.MIN_VALUE, area = 0; for (int i = 0; i \u0026lt; n; i++) { X1 = Math.min(X1, rectangles[i][0]); X2 = Math.max(X2, rectangles[i][2]); Y1 = Math.min(Y1, rectangles[i][1]); Y2 = Math.max(Y2, rectangles[i][3]); area += (rectangles[i][2] - rectangles[i][0]) * (rectangles[i][3] - rectangles[i][1]); String p1 = rectangles[i][0] + \u0026#34;,\u0026#34; + rectangles[i][1]; String p2 = rectangles[i][2] + \u0026#34;,\u0026#34; + rectangles[i][3]; String p3 = rectangles[i][0] + \u0026#34;,\u0026#34; + rectangles[i][3]; String p4 = rectangles[i][2] + \u0026#34;,\u0026#34; + rectangles[i][1]; for (String p : new String[]{p1, p2, p3, p4}) { if (points.contains(p)) { points.remove(p); } else { points.add(p); } } } if (area != (X2 - X1) * (Y2 - Y1)) { return false; } if (points.size() != 4) { return false; } if (!points.contains(X1 + \u0026#34;,\u0026#34; + Y1)) { return false; } if (!points.contains(X1 + \u0026#34;,\u0026#34; + Y2)) { return false; } if (!points.contains(X2 + \u0026#34;,\u0026#34; + Y1)) { return false; } if (!points.contains(X2 + \u0026#34;,\u0026#34; + Y2)) { return false; } return true; } } References 1. 完美矩形 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-391/","summary":"思路 从「面积」和「顶点」两个维度来判断： 1、判断面积，通过完美矩形的理论坐标计算出一个理论面积，然后和 rectangles 中小矩形的实际面积和做对比。 2、判断","title":"LeetCode 391"},{"content":"思路 利用双指针的思想，每次移动比较小的那个，同时维护左右指针之间的盛水最大值即可\n代码 class Solution { public int maxArea(int[] height) { int left = 0, right = height.length - 1; int res = 0; while (left \u0026lt; right) { int area = Math.min(height[left], height[right]) * (right - left); res = Math.max(res, area); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return res; } } References 1. 盛最多水的容器 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-11/","summary":"思路 利用双指针的思想，每次移动比较小的那个，同时维护左右指针之间的盛水最大值即可 代码 class Solution { public int maxArea(int[] height) { int left = 0, right = height.length - 1; int res = 0; while (left \u0026lt; right) { int area","title":"LeetCode 11"},{"content":"思路 四种思路：\n按列求 只需要找到每一列左边最大值和右边最大值的较小值，就可以求出这一列可以接多少雨水\n动态规划 按列求中，求左边右边的最大值是一个一个遍历的，这个过程可以优化一下，构建dp_left和dp_right数组，里面存放当前元素左边的最大值（右边的最大值），状态转移方程为：dp_left[i] = Math.max(height[i - 1], dp_left[i - 1])，base case为dp[0] = 0，可以优化空间复杂度\n双指针 其实就是动态规划的优化空间复杂度版本，每个格子能装多少水取决于这个格子左边最高的格子和右边最高的格子，所以可以使用双指针，分别指向左边和右边的格子，遍历这个数组，当左边最大值小于右边最大值时就可以确定左指针的元素能装多少水，因为能装多少水取决于这个格子左边最高的格子和右边最高的格子，而左边最大值小于右边最大值，即使右边有更大的也对结果没影响，然后移动左指针，并且更新左边的最大值即可\n单调栈 维护一个单调不增栈，当碰到元素大于栈顶时，出栈，然后取新栈顶和当前元素的较小值，将较小值减去出栈元素就是接的雨水的高度，再乘以新栈顶和当前元素的距离就是接的雨水，直到碰到比当前元素大的栈顶，将当前元素入栈，维护栈为单调不减栈的作用是保证每次计算的雨水都是一层或多层的雨水，详见：https://leetcode.cn/problems/trapping-rain-water/solutions/9112/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/\n代码 按列求 略\n动态规划 class Solution { public int trap(int[] height) { int n = height.length, max = 0; int[] left = new int[n], right = new int[n]; for (int i = 0; i \u0026lt; n; i++) { left[i] = max; max = Math.max(max, height[i]); } max = 0; for (int i = n - 1; i \u0026gt;= 0; i--) { right[i] = max; max = Math.max(max, height[i]); } int res = 0; for (int i = 0; i \u0026lt; n; i++) { if (Math.min(left[i], right[i]) \u0026gt; height[i]) { res += Math.min(left[i], right[i]) - height[i]; } } return res; } } 双指针 class Solution { public int trap(int[] height) { int left = 0, right = height.length - 1; int l_max = height[left], r_max = height[right]; int res = 0; while (left \u0026lt;= right) { l_max = Math.max(l_max, height[left]); r_max = Math.max(r_max, height[right]); if (l_max \u0026lt; r_max) { res += l_max - height[left]; left++; } else { res += r_max - height[right]; right--; } } return res; } } 单调栈 class Solution { public int trap(int[] height) { Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int i = 0, n = height.length, res = 0; while (i \u0026lt; n) { while (!stack.isEmpty() \u0026amp;\u0026amp; height[i] \u0026gt; height[stack.peek()]) { int h = height[stack.pop()]; if (stack.isEmpty()) { break; } int distance = i - stack.peek() - 1; res += (Math.min(height[i], height[stack.peek()]) - h) * distance; } stack.push(i); i++; } return res; } } References 1. 接雨水 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-42/","summary":"思路 四种思路： 按列求 只需要找到每一列左边最大值和右边最大值的较小值，就可以求出这一列可以接多少雨水 动态规划 按列求中，求左边右边的最大值是一个","title":"LeetCode 42"},{"content":"思路 利用双指针遍历两个区间集合，谁的终点小，谁往前走，同时判断两个指针指向的区间是否有交集，详见代码\n代码 class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { int m = firstList.length, n = secondList.length; int i = 0, j = 0; List\u0026lt;int[]\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026lt; n) { if (firstList[i][1] \u0026gt;= secondList[j][0] \u0026amp;\u0026amp; firstList[i][0] \u0026lt;= secondList[j][1]) { res.add(new int[]{Math.max(firstList[i][0], secondList[j][0]), Math.min(firstList[i][1], secondList[j][1])}); } if (firstList[i][1] \u0026gt; secondList[j][1]) { j++; } else { i++; } } int[][] ans = new int[res.size()][]; return res.toArray(ans); } } References 1. 区间列表的交集 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-986/","summary":"思路 利用双指针遍历两个区间集合，谁的终点小，谁往前走，同时判断两个指针指向的区间是否有交集，详见代码 代码 class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { int m = firstList.length, n = secondList.length; int","title":"LeetCode 986"},{"content":"思路 先按起点排序，然后寻找可以合并的最大终点即可\n代码 class Solution { public int[][] merge(int[][] intervals) { int n = intervals.length; Arrays.sort(intervals, (a, b) -\u0026gt; { return a[0] - b[0]; }); List\u0026lt;int[]\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); res.add(intervals[0]); for (int i = 1; i \u0026lt; n; i++) { int[] last = res.get(res.size() - 1); if (intervals[i][0] \u0026lt;= last[1]) { last[1] = Math.max(intervals[i][1], last[1]); } else { res.add(intervals[i]); } } int[][] ans = new int[res.size()][]; return res.toArray(ans); } } References 1. 合并区间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-56/","summary":"思路 先按起点排序，然后寻找可以合并的最大终点即可 代码 class Solution { public int[][] merge(int[][] intervals) { int n = intervals.length; Arrays.sort(intervals, (a, b) -\u0026gt; { return a[0] - b[0]; }); List\u0026lt;int[]\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); res.add(intervals[0]); for (int i = 1; i \u0026lt; n; i++) { int[] last = res.get(res.size() - 1);","title":"LeetCode 56"},{"content":"思路 先按起点排序，然后遍历，如果终点小于之前最大的终点，那这个区间就可以被覆盖\n代码 class Solution { public int removeCoveredIntervals(int[][] intervals) { int n = intervals.length; Arrays.sort(intervals, (a, b) -\u0026gt; { if (a[0] == b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); int res = n, right = intervals[0][1]; for (int i = 1; i \u0026lt; n; i++) { if (intervals[i][1] \u0026lt;= right) { res--; } else { right = intervals[i][1]; } } return res; } } References 1. 删除被覆盖区间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1288/","summary":"思路 先按起点排序，然后遍历，如果终点小于之前最大的终点，那这个区间就可以被覆盖 代码 class Solution { public int removeCoveredIntervals(int[][] intervals) { int n = intervals.length; Arrays.sort(intervals, (a, b) -\u0026gt; { if (a[0] == b[0]) { return b[1] - a[1]; } return a[0]","title":"LeetCode 1288"},{"content":"思路 同LeetCode-921，只不过需要注意当右括号差一个的时候需要补齐右括号\n代码 class Solution { public int minInsertions(String s) { int res = 0, need = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39;) { need += 2; if (need % 2 == 1) { res++; need--; } } else { need--; if (need == -1) { need = 1; res++; } } } return res + need; } } References 1. 平衡括号字符串的最少插入次数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1541/","summary":"思路 同LeetCode-921，只不过需要注意当右括号差一个的时候需要补齐右括号 代码 class Solution { public int minInsertions(String s) { int res = 0, need = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c =","title":"LeetCode 1541"},{"content":"思路 设置left和right变量，代表需要的左括号数量和右括号数量，从左往右遍历一遍，碰到左括号right++，碰到右括号right\u0026ndash;，当right\u0026lt;0时，说明左括号不够了，那就left++，最后left+right就是需要的左右括号数量\n代码 class Solution { public int minAddToMakeValid(String s) { int left = 0, right = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39;) { right++; } else { right--; if (right == -1) { right = 0; left++; } } } return left + right; } } References 1. 使括号有效的最少添加 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-921/","summary":"思路 设置left和right变量，代表需要的左括号数量和右括号数量，从左往右遍历一遍，碰到左括号right++，碰到右括号right\u0026nda","title":"LeetCode 921"},{"content":"思路 用栈即可，直接看代码\n代码 class Solution { public boolean isValid(String s) { Deque\u0026lt;Character\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } else { if (stack.isEmpty() || stack.pop() != leftOf(c)) { return false; } } } return stack.isEmpty(); } private char leftOf(char c) { if (c == \u0026#39;)\u0026#39;) { return \u0026#39;(\u0026#39;; } if (c == \u0026#39;]\u0026#39;) { return \u0026#39;[\u0026#39;; } if (c == \u0026#39;}\u0026#39;) { return \u0026#39;{\u0026#39;; } return \u0026#39; \u0026#39;; } } References 1. 有效的括号 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-20/","summary":"思路 用栈即可，直接看代码 代码 class Solution { public boolean isValid(String s) { Deque\u0026lt;Character\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } else { if (stack.isEmpty() || stack.pop() != leftOf(c)) { return false; } } }","title":"LeetCode 20"},{"content":"思路 根本思想是建立一个栈，栈里存放目前遍历到的数字，比如1-2+3，栈里存放1、-2、3，最后将栈里的数字相加即可，详见：https://labuladong.gitee.io/algo/4/33/127/\n代码 class Solution { private int calculate(StringBuilder sb) { Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int num = 0; char sign = \u0026#39;+\u0026#39;; while (sb.length() \u0026gt; 0) { char c = sb.charAt(0); sb.deleteCharAt(0); if (isDigit(c)) { num = num * 10 + c - \u0026#39;0\u0026#39;; } if (c == \u0026#39;(\u0026#39;) { num = calculate(sb); } if (!isDigit(c) \u0026amp;\u0026amp; c != \u0026#39; \u0026#39; || sb.length() == 0) { switch (sign) { case \u0026#39;+\u0026#39;: stack.push(num); break; case \u0026#39;-\u0026#39;: stack.push(-num); break; case \u0026#39;*\u0026#39;: stack.push(stack.pop() * num); break; case \u0026#39;/\u0026#39;: stack.push(stack.pop() / num); break; } sign = c; num = 0; } if (c == \u0026#39;)\u0026#39;) { break; } } int res = 0; while (!stack.isEmpty()) { res += stack.pop(); } return res; } public int calculate(String s) { return calculate(new StringBuilder(s)); } private boolean isDigit(char c) { if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return true; } return false; } } References 1. 基本计算器 2. 基本计算器 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-224+227/","summary":"思路 根本思想是建立一个栈，栈里存放目前遍历到的数字，比如1-2+3，栈里存放1、-2、3，最后将栈里的数字相加即可，详见：https://l","title":"LeetCode 224+227"},{"content":"思路 就是大整数乘法，用列式计算的方式计算两个字符串的乘积，如下图所示：\n详见：https://labuladong.gitee.io/algo/4/33/126/\n代码 class Solution { public String multiply(String num1, String num2) { char[] n1 = num1.toCharArray(); char[] n2 = num2.toCharArray(); int l1 = n1.length, l2 = n2.length; int[] res = new int[l1 + l2]; for (int i = l1 - 1; i \u0026gt;= 0; i--) { for (int j = l2 - 1; j \u0026gt;= 0; j--) { int mul = (n1[i] - \u0026#39;0\u0026#39;) * (n2[j] - \u0026#39;0\u0026#39;); int sum = mul + res[i + j + 1]; res[i + j + 1] = sum % 10; res[i + j] += sum / 10; } } int offset = 0; while (offset \u0026lt; res.length \u0026amp;\u0026amp; res[offset] == 0) { offset++; } StringBuilder sb = new StringBuilder(); for (int i = offset; i \u0026lt; res.length; i++) { sb.append(res[i]); } return sb.length() == 0 ? \u0026#34;0\u0026#34; : sb.toString(); } } References 1. 字符串相乘 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-43/","summary":"思路 就是大整数乘法，用列式计算的方式计算两个字符串的乘积，如下图所示： 详见：https://labuladong.gitee.io/algo","title":"LeetCode 43"},{"content":"思路 从前往后遍历，遍历到一个元素v，只要能将所有元素分配到一个序列中即可，关键在于，我们怎么知道当前元素 v 如何进行分配呢？\n肯定得分情况讨论，把情况讨论清楚了，题目也就做出来了。\n总共有两种情况：\n1、当前元素 v 自成一派，「以自己开头」构成一个长度至少为 3 的序列。\n2、当前元素 v 接到已经存在的子序列后面。\n如果这两种情况都可以，应该优先判断自己是否能够接到其他序列后面，因为只要能自成一派，那接在其他序列后面肯定没问题，接在其他序列后面没问题，不一定能自成一派，用两个hash表即可实现这个过程，详见代码\n代码 class Solution { public boolean isPossible(int[] nums) { Map\u0026lt;Integer, Integer\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { freq.put(num, freq.getOrDefault(num, 0) + 1); } for (int num : nums) { if (freq.get(num) == 0) { continue; } if (need.getOrDefault(num, 0) \u0026gt; 0) { freq.put(num, freq.get(num) - 1); need.put(num, need.get(num) - 1); need.put(num + 1, need.getOrDefault(num + 1, 0) + 1); } else if (freq.getOrDefault(num, 0) \u0026gt; 0 \u0026amp;\u0026amp; freq.getOrDefault(num + 1, 0) \u0026gt; 0 \u0026amp;\u0026amp; freq.getOrDefault(num + 2, 0) \u0026gt; 0) { freq.put(num, freq.get(num) - 1); freq.put(num + 1, freq.get(num + 1) - 1); freq.put(num + 2, freq.get(num + 2) - 1); need.put(num + 3, need.getOrDefault(num + 3, 0) + 1); } else { return false; } } return true; } } References 1. 分割数组为连续子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-659/","summary":"思路 从前往后遍历，遍历到一个元素v，只要能将所有元素分配到一个序列中即可，关键在于，我们怎么知道当前元素 v 如何进行分配呢？ 肯定得分情况讨论，","title":"LeetCode 659"},{"content":"思路 经典分治思想，根据式子的运算符分成左右两个子问题，然后将两个子问题合并，就得到了原问题的答案，详见思想篇章\n代码 class Solution { private Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; diffWaysToCompute(String expression) { if (memo.containsKey(expression)) { return memo.get(expression); } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; expression.length(); i++) { char c = expression.charAt(i); if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39;) { List\u0026lt;Integer\u0026gt; left = diffWaysToCompute(expression.substring(0, i)); List\u0026lt;Integer\u0026gt; right = diffWaysToCompute(expression.substring(i + 1)); for (Integer l : left) { for (Integer r : right) { if (c == \u0026#39;+\u0026#39;) { res.add(l + r); } else if (c == \u0026#39;*\u0026#39;) { res.add(l * r); } else if (c == \u0026#39;-\u0026#39;) { res.add(l - r); } } } } } if (res.isEmpty()) { res.add(Integer.parseInt(expression)); } memo.put(expression, res); return res; } } References 1. 为运算表达式设计优先级 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-241/","summary":"思路 经典分治思想，根据式子的运算符分成左右两个子问题，然后将两个子问题合并，就得到了原问题的答案，详见思想篇章 代码 class Solution { private Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; diffWaysToCompute(String","title":"LeetCode 241"},{"content":"思路 幂可以转换为以下形式：\n这样就可以运用递归了，至于模幂运算运用(a * b) % k = ((a % k) * (b % k)) % k即可，详见思想篇章\n还可以运用高效求幂，详见思想\n代码 基本版 class Solution { private int base = 1337; public int superPow(int a, int[] b) { return superPow(a, b, b.length); } private int superPow(int a, int[] b, int len) { if (len == 0) { return 1; } int last = b[len - 1]; int p1 = myPow(a, last); int p2 = myPow(superPow(a, b, len - 1), 10); return (p1 * p2) % base; } private int myPow(int a, int b) { a %= base; int res = 1; while (b != 0) { res = (res * a) % base; b--; } return res; } } 高效版 class Solution { private int base = 1337; public int superPow(int a, int[] b) { return superPow(a, b, b.length); } private int superPow(int a, int[] b, int len) { if (len == 0) { return 1; } int last = b[len - 1]; int p1 = myPow(a, last); int p2 = myPow(superPow(a, b, len - 1), 10); return (p1 * p2) % base; } private int myPow(int a, int b) { if (b == 0) { return 1; } a %= base; if (b % 2 == 1) { return (a * myPow(a, b - 1)) % base; } else { int res = myPow(a, b / 2); return (res * res) % base; } } } References 1. 超级次方 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-372/","summary":"思路 幂可以转换为以下形式： 这样就可以运用递归了，至于模幂运算运用(a * b) % k = ((a % k) * (b % k)) % k即可，详见思想篇章 还可以运用高效求幂，详见思","title":"LeetCode 372"},{"content":"思路 经典素数筛选法，详见思想篇章\n代码 class Solution { public int countPrimes(int n) { boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); double sqrtn = Math.sqrt(n); for (int i = 2; i \u0026lt; sqrtn; i++) { if (isPrime[i]) { for (int j = i * i; j \u0026lt; n; j += i) { isPrime[j] = false; } } } int count = 0; for (int i = 2; i \u0026lt; n; i++) { if (isPrime[i]) { count++; } } return count; } } References 1. 计数质数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-204/","summary":"思路 经典素数筛选法，详见思想篇章 代码 class Solution { public int countPrimes(int n) { boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); double sqrtn = Math.sqrt(n); for (int i = 2; i \u0026lt; sqrtn; i++) { if (isPrime[i]) { for (int j = i * i; j \u0026lt; n; j += i) { isPrime[j] = false; } } }","title":"LeetCode 204"},{"content":"思路 这道题可以复用LeetCode-172的函数，从0-Long.MAX_VALUE之间寻找trailingZeroes(n) == k的值，由于trailingZeroes(n)是单调的，所以可以用二分查找确定左右边界（这点不容易想到），这样比穷举快多了，二分查找相关细节见思想篇章\n代码 class Solution { public int preimageSizeFZF(int k) { return (int) (rightBound(k) - leftBound(k) + 1); } private long leftBound(int target) { long left = 0, right = Long.MAX_VALUE; while (left \u0026lt; right) { long mid = left + (right - left) / 2; if (target \u0026lt;= trailingZeroes(mid)) { right = mid; } else { left = mid + 1; } } return left; } private long rightBound(int target) { long left = 0, right = Long.MAX_VALUE; while (left \u0026lt; right) { long mid = left + (right - left) / 2 + (right - left) % 2; if (target \u0026gt;= trailingZeroes(mid)) { left = mid; } else { right = mid - 1; } } return left; } private long trailingZeroes(long n) { long res = 0; while (n \u0026gt;= 5) { res += n / 5; n /= 5; } return res; } } References 1. 阶乘函数后 K 个零 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-793/","summary":"思路 这道题可以复用LeetCode-172的函数，从0-Long.MAX_VALUE之间寻找trailingZeroes(n) == k的值，由于","title":"LeetCode 793"},{"content":"思路 其实求阶乘结果有几个零就是求阶乘式子里可以分解出来几个因数5，其实就是n/5 + n/25 + n/125 + \u0026hellip;.\n代码 class Solution { public int trailingZeroes(int n) { int res = 0, divisor = 5; while (divisor \u0026lt;= n) { res += n / divisor; divisor *= 5; } return res; } } References 1. 阶乘后的零 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-172/","summary":"思路 其实求阶乘结果有几个零就是求阶乘式子里可以分解出来几个因数5，其实就是n/5 + n/25 + n/125 + \u0026hellip;. 代码 class Solution { public int trailingZeroes(int n) { int res = 0, divisor = 5; while (divisor \u0026lt;= n) { res +=","title":"LeetCode 172"},{"content":"思路 利用并查集的思想即可\n代码 class Solution { public boolean validPath(int n, int[][] edges, int source, int destination) { UF uf = new UF(n); for (int[] edge : edges) { uf.union(edge[0], edge[1]); } return uf.isConnected(source, destination); } class UF { private int[] parent; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } private int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } private void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) { return; } parent[rootP] = rootQ; } private boolean isConnected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } } } References 1. 寻找图中是否存在路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1971/","summary":"思路 利用并查集的思想即可 代码 class Solution { public boolean validPath(int n, int[][] edges, int source, int destination) { UF uf = new UF(n); for (int[] edge : edges) { uf.union(edge[0], edge[1]); } return uf.isConnected(source, destination); } class UF { private int[] parent; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) {","title":"LeetCode 1971"},{"content":"思路 两种思路：\n常规思路 求[0\u0026hellip;n]的前n项和然后减去nums的数之和，就得到了缺失的数组\n位运算思路 由于异或的性质，只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下，注意需要先异或n\n代码 常规思路 class Solution { public int missingNumber(int[] nums) { int n = nums.length; long except = (0 + n) * (n + 1) / 2; long sum = 0; for (int num : nums) { sum += num; } return (int) (except - sum); } } 位运算思路 class Solution { public int missingNumber(int[] nums) { int n = nums.length; int res = n; for (int i = 0; i \u0026lt; n; i++) { res ^= i ^ nums[i]; } return res; } } References 1. 丢失的数字 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-268/","summary":"思路 两种思路： 常规思路 求[0\u0026hellip;n]的前n项和然后减去nums的数之和，就得到了缺失的数组 位运算思路 由于异或的性质，只要把所有的","title":"LeetCode 268"},{"content":"思路 由于一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。那么这道题将所有数异或就得到了结果，在这种场景下可以认为两个相同的数异或后就抵消了\n代码 class Solution { public int singleNumber(int[] nums) { int len = nums.length, result = 0; for (int i = 0; i \u0026lt; len; i++) { result ^= nums[i]; } return result; } } References 1. 只出现一次的数字 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-136/","summary":"思路 由于一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。那么这道题将所有数异或就得到了结果","title":"LeetCode 136"},{"content":"思路 用 n \u0026amp; (n-1) 的技巧来判断n的二进制表示是不是只有一个1\n代码 class Solution { public boolean isPowerOfTwo(int n) { if (n \u0026lt;= 0) { return false; } return (n \u0026amp; (n - 1)) == 0; } } References 1. 2 的幂 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-231/","summary":"思路 用 n \u0026amp; (n-1) 的技巧来判断n的二进制表示是不是只有一个1 代码 class Solution { public boolean isPowerOfTwo(int n) { if (n \u0026lt;= 0) { return false; } return (n \u0026amp; (n - 1)) == 0; } } References 1. 2 的幂","title":"LeetCode 231"},{"content":"思路 需要知道 n \u0026amp; (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。\n代码 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int res = 0; while (n != 0) { n = n \u0026amp; (n - 1); res++; } return res; } } References 1. 位 1 的个数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-191/","summary":"思路 需要知道 n \u0026amp; (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。 代码 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n)","title":"LeetCode 191"},{"content":"思路 不解释了，直接看代码\n代码 class Solution { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map; public Solution(int[] nums) { map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (!map.containsKey(nums[i])) { map.put(nums[i], new LinkedList\u0026lt;\u0026gt;()); } map.get(nums[i]).add(i); } } public int pick(int target) { List\u0026lt;Integer\u0026gt; list = map.get(target); return list.get(new Random().nextInt(list.size())); } } References 1. 随机数索引 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-398/","summary":"思路 不解释了，直接看代码 代码 class Solution { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map; public Solution(int[] nums) { map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (!map.containsKey(nums[i])) { map.put(nums[i], new LinkedList\u0026lt;\u0026gt;()); } map.get(nums[i]).add(i); } } public int pick(int target) { List\u0026lt;Integer\u0026gt; list = map.get(target); return list.get(new Random().nextInt(list.size())); } } References 1. 随机数索引","title":"LeetCode 398"},{"content":"思路 从一堆数据里随机取出一个数据，可以使用蓄水池抽样算法，详见思想篇章\n代码 class Solution { private ListNode head; public Solution(ListNode head) { this.head = head; } public int getRandom() { Random random = new Random(); int i = 0, res = 0; ListNode p = head; while (p != null) { i++; if (random.nextInt(i) == 0) { res = p.val; } p = p.next; } return res; } } References 1. 链表随机节点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-382/","summary":"思路 从一堆数据里随机取出一个数据，可以使用蓄水池抽样算法，详见思想篇章 代码 class Solution { private ListNode head; public Solution(ListNode head) { this.head = head; } public int getRandom() { Random random = new Random(); int i = 0, res = 0; ListNode p =","title":"LeetCode 382"},{"content":"思路 随机算法问题，使用洗牌算法即可，详见思想篇章\n代码 class Solution { private int[] nums; private Random random; public Solution(int[] nums) { this.nums = nums; this.random = new Random(); } public int[] reset() { return nums; } public int[] shuffle() { int n = nums.length; int[] copy = Arrays.copyOf(nums, n); for (int i = 0; i \u0026lt; n; i++) { int r = random.nextInt(n - i) + i; int temp = copy[i]; copy[i] = copy[r]; copy[r] = temp; } return copy; } } References 1. 打乱数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-384/","summary":"思路 随机算法问题，使用洗牌算法即可，详见思想篇章 代码 class Solution { private int[] nums; private Random random; public Solution(int[] nums) { this.nums = nums; this.random = new Random(); } public int[] reset() { return nums; } public int[] shuffle() { int n = nums.length; int[] copy = Arrays.copyOf(nums, n); for (int i","title":"LeetCode 384"},{"content":"思路 四个拨轮，每个都可以向上或者向下，所以有8种选择，由此可以抽象为一个图，BFS算法第一次碰到target时走过的长度就是开锁的最少操作次数，注意deadends可以当成已经访问过的结点\n代码 class Solution { public int openLock(String[] deadends, String target) { Queue\u0026lt;String\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); for (String deadend : deadends) { visited.add(deadend); } if (visited.contains(\u0026#34;0000\u0026#34;)) { return -1; } queue.offer(\u0026#34;0000\u0026#34;); visited.add(\u0026#34;0000\u0026#34;); int step = 0; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { String cur = queue.poll(); if (cur.equals(target)) { return step; } for (int j = 0; j \u0026lt; 4; j++) { String minus = minusOne(cur, j); if (!visited.contains(minus)) { queue.offer(minus); visited.add(minus); } String plus = plusOne(cur, j); if (!visited.contains(plus)) { queue.offer(plus); visited.add(plus); } } } step++; } return -1; } private String minusOne(String s, int i) { char[] chars = s.toCharArray(); chars[i] = (char) ((chars[i] - \u0026#39;0\u0026#39; + 9) % 10 + \u0026#39;0\u0026#39;); return new String(chars); } private String plusOne(String s, int i) { char[] chars = s.toCharArray(); chars[i] = (char) ((chars[i] - \u0026#39;0\u0026#39; + 1) % 10 + \u0026#39;0\u0026#39;); return new String(chars); } } References 1. 打开转盘锁 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-752/","summary":"思路 四个拨轮，每个都可以向上或者向下，所以有8种选择，由此可以抽象为一个图，BFS算法第一次碰到target时走过的长度就是开锁的最少操作次","title":"LeetCode 752"},{"content":"思路 经典BFS问题，BFS同时看是不是叶子节点，是叶子结点就返回深度\n代码 class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); int depth = 1; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode cur = queue.poll(); if (cur.left == null \u0026amp;\u0026amp; cur.right == null) { return depth; } if (cur.left != null) { queue.offer(cur.left); } if (cur.right != null) { queue.offer(cur.right); } } depth++; } return -1; } } References 1. 二叉树的最小深度 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-111/","summary":"思路 经典BFS问题，BFS同时看是不是叶子节点，是叶子结点就返回深度 代码 class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); int depth = 1; while (!queue.isEmpty()) { int size = queue.size(); for","title":"LeetCode 111"},{"content":"思路 经典回溯问题，穷举所有可能并且对不合理的情况剪枝即可，剪枝代码如下：\nif (right \u0026lt; left) { return; } if (right \u0026lt; 0 || left \u0026lt; 0) { return; } 代码 class Solution { public List\u0026lt;String\u0026gt; generateParenthesis(int n) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); StringBuilder track = new StringBuilder(); backtrack(track, n, n, res); return res; } private void backtrack(StringBuilder track, int left, int right, List\u0026lt;String\u0026gt; res) { if (right \u0026lt; left) { return; } if (right \u0026lt; 0 || left \u0026lt; 0) { return; } if (right == 0 \u0026amp;\u0026amp; left == 0) { res.add(track.toString()); } track.append(\u0026#39;(\u0026#39;); backtrack(track, left - 1, right, res); track.deleteCharAt(track.length() - 1); track.append(\u0026#39;)\u0026#39;); backtrack(track, left, right - 1, res); track.deleteCharAt(track.length() - 1); } } References 1. 括号生成 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-22/","summary":"思路 经典回溯问题，穷举所有可能并且对不合理的情况剪枝即可，剪枝代码如下： if (right \u0026lt; left) { return; } if (right \u0026lt; 0 || left \u0026lt; 0) { return; } 代码 class Solution { public List\u0026lt;String\u0026gt; generateParenthesis(int n) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); StringBuilder","title":"LeetCode 22"},{"content":"思路 经典回溯问题，暴力求解即可\n代码 class Solution { public void solveSudoku(char[][] board) { backtrack(board, 0, 0); } private boolean backtrack(char[][] board, int i, int j) { if (j == 9) { i++; j = 0; } if (i == 9) { return true; } if (board[i][j] != \u0026#39;.\u0026#39;) { return backtrack(board, i, j + 1); } boolean[] isValid = getValidNum(board, i, j); for (int k = 1; k \u0026lt;= 9; k++) { if (!isValid[k - 1]) { continue; } board[i][j] = (char) (\u0026#39;0\u0026#39; + k); if (backtrack(board, i, j + 1)) { return true; } board[i][j] = \u0026#39;.\u0026#39;; } return false; } private boolean[] getValidNum(char[][] board, int i, int j) { boolean[] isValid = new boolean[9]; Arrays.fill(isValid, true); for (int k = 0; k \u0026lt; 9; k++) { if (board[i][k] != \u0026#39;.\u0026#39;) { isValid[board[i][k] - \u0026#39;0\u0026#39; - 1] = false; } if (board[k][j] != \u0026#39;.\u0026#39;) { isValid[board[k][j] - \u0026#39;0\u0026#39;- 1] = false; } if (board[i / 3 * 3 + k / 3][j / 3 * 3 + k % 3] != \u0026#39;.\u0026#39;) { isValid[board[i / 3 * 3 + k / 3][j / 3 * 3 + k % 3] - \u0026#39;0\u0026#39; - 1] = false; } } return isValid; } } References 1. 解数独 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-37/","summary":"思路 经典回溯问题，暴力求解即可 代码 class Solution { public void solveSudoku(char[][] board) { backtrack(board, 0, 0); } private boolean backtrack(char[][] board, int i, int j) { if (j == 9) { i++; j = 0; } if (i == 9) { return true; } if (board[i][j] != \u0026#39;.\u0026#39;) { return backtrack(board, i, j + 1); } boolean[] isValid","title":"LeetCode 37"},{"content":"思路 第一题 暴力解法即可，见代码\n第二题 需要知道一个数一定能被分解为质数之积，且是唯一的，分解质数的方法是从2开始除，没法整除就将2加一，再除，直到将原数除成1，这道题需要把数分解同时求和，然后循环这个过程，直到求的和\u0026gt;=上次求的和，那么上次求的和就是答案\n第三题 把度数为奇数的节点记到 odd 中，记 m 为 odd 的长度，分类讨论：\n如果 m=0，那么已经符合要求。 如果 m=2，记 x=odd[0],y=odd[1]： 如果 x 和 y 之间没有边，那么连边之后就符合要求了。 如果 x 和 y 之间有边，那么枚举 [1,n] 的所有不为 x 和 y 的点 i，由于 i 的度数一定是偶数，如果 i 和 x 以及 i 和 y 之间没有边，那么连边之后就符合要求了。 如果 m=4，记 a=odd[0],b=odd[1],c=odd[2],d=odd[3]： 如果 a 和 b 以及 c 和 d 之间没有边，那么连边之后就符合要求了。 如果 a 和 c 以及 b 和 d 之间没有边，那么连边之后就符合要求了。 如果 a 和 d 以及 b 和 c 之间没有边，那么连边之后就符合要求了。 其余情况无法满足要求。 第四题 设 LCA 为 a 和 b 的最近公共祖先，那么环长等于 LCA 到 a 的距离加 LCA 到 b 的距离加一。怎么求LCA？可以这样：\n不断循环，每次循环比较 a 和 b 的大小：\n如果 a\u0026gt;b，则 a 的深度大于等于 b 的深度，那么把 a 移动到其父节点，即 a=a/2； 如果 a\u0026lt;b，则 a 的深度小于等于 b 的深度，那么把 b 移动到其父节点，即 b=b/2； 如果 a=b，则找到了 LCA ，退出循环。 循环次数加一即为环长。\n我的这种做法不够优雅\n代码 第一题 class Solution { private boolean isSimilar(String word1, String word2) { HashSet\u0026lt;Character\u0026gt; set1 = new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Character\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; word1.length(); i++) { set1.add(word1.charAt(i)); } for (int i = 0; i \u0026lt; word2.length(); i++) { set2.add(word2.charAt(i)); } if (set1.size() != set2.size()) { return false; } for (Character character : set2) { if (!set1.contains(character)) { return false; } } return true; } public int similarPairs(String[] words) { int n = words.length, res = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (isSimilar(words[i], words[j])) { res++; } } } return res; } } 第二题 class Solution { public int smallestValue(int n) { int i = 2, res = 0, preRes = Integer.MAX_VALUE; while (i \u0026lt;= n) { if (n % i == 0) { n /= i; res += i; if (n == 1) { if (preRes \u0026lt;= res) { return preRes; } n = res; preRes = res; i = 2; res = 0; } } else { i++; } } return res; } } 第三题 class Solution { private Set\u0026lt;String\u0026gt; edgeSet = new HashSet\u0026lt;\u0026gt;(); public boolean isPossible(int n, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges) { int[] degree = new int[n + 1]; for (List\u0026lt;Integer\u0026gt; edge : edges) { edgeSet.add(edge.get(0) + \u0026#34;,\u0026#34; + edge.get(1)); edgeSet.add(edge.get(1) + \u0026#34;,\u0026#34; + edge.get(0)); degree[edge.get(0)]++; degree[edge.get(1)]++; } ArrayList\u0026lt;Integer\u0026gt; nodes = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= n; i++) { if (degree[i] % 2 == 1) { nodes.add(i); } } int count = nodes.size(); if (count == 0) { return true; } if (count == 2) { if (!edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + nodes.get(1))) { return true; } for (int i = 1; i \u0026lt;= n; i++) { if (i == nodes.get(0) || i == nodes.get(1)) { continue; } if (!edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + i) \u0026amp;\u0026amp; !edgeSet.contains(i + \u0026#34;,\u0026#34; + nodes.get(1))) { return true; } } } if (count == 4) { if (!edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + nodes.get(1)) \u0026amp;\u0026amp; !edgeSet.contains(nodes.get(2) + \u0026#34;,\u0026#34; + nodes.get(3)) || !edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + nodes.get(2)) \u0026amp;\u0026amp; !edgeSet.contains(nodes.get(1) + \u0026#34;,\u0026#34; + nodes.get(3)) || !edgeSet.contains(nodes.get(0) + \u0026#34;,\u0026#34; + nodes.get(3)) \u0026amp;\u0026amp; !edgeSet.contains(nodes.get(1) + \u0026#34;,\u0026#34; + nodes.get(2))) { return true; } } return false; } } 第四题 class Solution { private int getLen(int node1, int node2) { int len1 = 0, len2 = 0, n1 = node1, n2 = node2; while (n1 != 1) { n1 /= 2; len1++; } while (n2 != 1) { n2 /= 2; len2++; } n1 = node1; n2 = node2; int l1 = len1; int l2 = len2; while (n1 != n2) { if (l1 \u0026gt; l2) { n1 /= 2; l1--; } else if (l1 \u0026lt; l2) { n2 /= 2; l2--; } else { n1 /= 2; n2 /= 2; l1--; l2--; } } return len1 - l1 + len2 - l2 + 1; } public int[] cycleLengthQueries(int n, int[][] queries) { int[] answer = new int[queries.length]; for (int i = 0; i \u0026lt; queries.length; i++) { answer[i] = getLen(queries[i][0], queries[i][1]); } return answer; } } References ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-324/","summary":"思路 第一题 暴力解法即可，见代码 第二题 需要知道一个数一定能被分解为质数之积，且是唯一的，分解质数的方法是从2开始除，没法整除就将2加一，再除，","title":"LeetCode 周赛-324"},{"content":"思路 标准KMP算法，套模板即可，详见思想篇章\n代码 class Solution { public int strStr(String haystack, String needle) { return new KMP(needle).search(haystack); } class KMP { private String pat; private int[][] dp; public KMP(String pat) { this.pat = pat; int M = pat.length(); this.dp = new int[M][256]; dp[0][pat.charAt(0)] = 1; int X = 0; for (int j = 1; j \u0026lt; M; j++) { for (int c = 0; c \u0026lt; 256; c++) { dp[j][c] = dp[X][c]; } dp[j][pat.charAt(j)] = j + 1; X = dp[X][pat.charAt(j)]; } } public int search(String str) { int M = pat.length(); int N = str.length(); int j = 0; for (int i = 0; i \u0026lt; N; i++) { j = dp[j][str.charAt(i)]; if (j == M) { return i - M + 1; } } return -1; } } } References 1. 实现 strStr() ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-28/","summary":"思路 标准KMP算法，套模板即可，详见思想篇章 代码 class Solution { public int strStr(String haystack, String needle) { return new KMP(needle).search(haystack); } class KMP { private String pat; private int[][] dp; public KMP(String pat) { this.pat = pat; int M = pat.length(); this.dp = new int[M][256]; dp[0][pat.charAt(0)] = 1; int X = 0; for","title":"LeetCode 28"},{"content":"思路 用双指针逐行比较即可，可以用KMP优化\n代码 class Solution { private boolean isMatch(int[] group, int[] nums, int start) { if (group.length \u0026gt; nums.length - start) { return false; } for (int i = 0; i \u0026lt; group.length; i++) { if (group[i] != nums[start + i]) { return false; } } return true; } public boolean canChoose(int[][] groups, int[] nums) { int i = 0, k = 0; while (i \u0026lt; groups.length \u0026amp;\u0026amp; k \u0026lt; nums.length){ if (isMatch(groups[i], nums, k)) { k += groups[i].length; i++; } else { k++; } } return i == groups.length; } } References 1. 通过连接另一个数组的子数组得到一个数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1764/","summary":"思路 用双指针逐行比较即可，可以用KMP优化 代码 class Solution { private boolean isMatch(int[] group, int[] nums, int start) { if (group.length \u0026gt; nums.length - start) { return false; } for (int i = 0; i \u0026lt; group.length; i++) { if (group[i] != nums[start + i]) { return false; } } return true; } public","title":"LeetCode 1764"},{"content":"思路 和其他岛屿类似，但是需要判断形状是否相同，解决办法也比较巧妙，通过遍历岛屿单元格的顺序来判断形状是否相同，还要把这些顺序序列化成字符串方便去重\n代码 public class Solution { private void dfs(int[][] grid, int i, int j, StringBuilder sb, int dir) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == 0) { return; } grid[i][j] = 0; sb.append(dir).append(\u0026#39;,\u0026#39;); dfs(grid, i + 1, j, sb, 1); dfs(grid, i - 1, j, sb, 2); dfs(grid, i, j + 1, sb, 3); dfs(grid, i, j - 1, sb, 4); sb.append(-dir).append(\u0026#39;,\u0026#39;); } public int numberofDistinctIslands(int[][] grid) { int m = grid.length, n = grid[0].length; Set\u0026lt;String\u0026gt; res = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { StringBuilder sb = new StringBuilder(); dfs(grid, i, j, sb, 666); res.add(sb.toString()); } } } return res.size(); } } References 1. 不同岛屿的数量 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-694/","summary":"思路 和其他岛屿类似，但是需要判断形状是否相同，解决办法也比较巧妙，通过遍历岛屿单元格的顺序来判断形状是否相同，还要把这些顺序序列化成字符串方","title":"LeetCode 694"},{"content":"思路 同LeetCode-1254，只不过需要提前把不可能是子岛屿的岛屿淹掉，剩下的就是子岛屿了\n代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == 0) { return; } grid[i][j] = 0; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); } public int countSubIslands(int[][] grid1, int[][] grid2) { int m = grid1.length, n = grid1[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid1[i][j] == 0 \u0026amp;\u0026amp; grid2[i][j] == 1) { dfs(grid2, i, j); } } } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid2[i][j] == 1) { res++; dfs(grid2, i, j); } } } return res; } } References 1. 统计子岛屿 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1905/","summary":"思路 同LeetCode-1254，只不过需要提前把不可能是子岛屿的岛屿淹掉，剩下的就是子岛屿了 代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i","title":"LeetCode 1905"},{"content":"思路 同LeetCode-200，把返回值改成淹没陆地的数量即可\n代码 class Solution { private int dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return 0; } if (grid[i][j] == 0) { return 0; } grid[i][j] = 0; return 1 + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1); } public int maxAreaOfIsland(int[][] grid) { int m = grid.length, n = grid[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { res = Math.max(res, dfs(grid, i, j)); } } return res; } } References 1. 岛屿的最大面积 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-695/","summary":"思路 同LeetCode-200，把返回值改成淹没陆地的数量即可 代码 class Solution { private int dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return","title":"LeetCode 695"},{"content":"思路 同LeetCode-1254，将边界淹没后，直接统计单元格即可\n代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == 0) { return; } grid[i][j] = 0; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); } public int numEnclaves(int[][] grid) { int m = grid.length, n = grid[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { dfs(grid, i, 0); dfs(grid, i, n - 1); } for (int i = 0; i \u0026lt; n; i++) { dfs(grid, 0, i); dfs(grid, m - 1, i); } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { res++; } } } return res; } } References 1. 飞地的数量 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1020/","summary":"思路 同LeetCode-1254，将边界淹没后，直接统计单元格即可 代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n)","title":"LeetCode 1020"},{"content":"思路 同LeetCode-200，只不过需要提前把边界的岛屿淹没\n代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == 1) { return; } grid[i][j] = 1; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); } public int closedIsland(int[][] grid) { int m = grid.length, n = grid[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { dfs(grid, i, 0); dfs(grid, i, n - 1); } for (int i = 0; i \u0026lt; n; i++) { dfs(grid, 0, i); dfs(grid, m - 1, i); } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 0) { res++; dfs(grid, i, j); } } } return res; } } References 1. 统计封闭岛屿的数目 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1254/","summary":"思路 同LeetCode-200，只不过需要提前把边界的岛屿淹没 代码 class Solution { private void dfs(int[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return;","title":"LeetCode 1254"},{"content":"思路 利用dfs的思想，遍历矩阵，如果碰到陆地就从这个元素开始dfs，同时将陆地全部变为海水，同时统计岛屿的个数\n代码 class Solution { public int numIslands(char[][] grid) { int m = grid.length, n = grid[0].length, res = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { res++; dfs(grid, i, j); } } } return res; } private void dfs(char[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == \u0026#39;0\u0026#39;) { return; } grid[i][j] = \u0026#39;0\u0026#39;; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); } } References 1. 岛屿数量 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-200/","summary":"思路 利用dfs的思想，遍历矩阵，如果碰到陆地就从这个元素开始dfs，同时将陆地全部变为海水，同时统计岛屿的个数 代码 class Solution { public int numIslands(char[][] grid) { int m = grid.length, n","title":"LeetCode 200"},{"content":"思路 经典可复选组合问题，保证递归的时候还能选择已经选择的元素即可\n代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; private void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if (trackSum \u0026gt; target) { return; } for (int i = start; i \u0026lt; nums.length; i++) { track.add(nums[i]); trackSum += nums[i]; backtrack(nums, i, target); track.remove(track.size() - 1); trackSum -= nums[i]; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { backtrack(candidates, 0, target); return res; } } References 1. 组合总和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-39/","summary":"思路 经典可复选组合问题，保证递归的时候还能选择已经选择的元素即可 代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; private void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if","title":"LeetCode 39"},{"content":"思路 经典有重复元素的全排列问题，需要注意怎么去重，可以固定相同元素在全排列里的相对位置来去重，代码如下：\nif (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } 代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); private void backtrack(List\u0026lt;Integer\u0026gt; track, int[] nums, boolean[] used) { if (track.size() == nums.length) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } track.add(nums[i]); used[i] = true; backtrack(track, nums, used); used[i] = false; track.remove(track.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { int n = nums.length; Arrays.sort(nums); boolean[] used = new boolean[n]; List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(track, nums, used); return res; } } References 1. 全排列 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-47/","summary":"思路 经典有重复元素的全排列问题，需要注意怎么去重，可以固定相同元素在全排列里的相对位置来去重，代码如下： if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } 代","title":"LeetCode 47"},{"content":"思路 经典带重复元素的组合问题，详见思想篇章\n代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; private void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if (trackSum \u0026gt; target) { return; } for (int i = start; i \u0026lt; nums.length; i++) { if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } track.add(nums[i]); trackSum += nums[i]; backtrack(nums, i + 1, target); track.remove(track.size() - 1); trackSum -= nums[i]; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); backtrack(candidates, 0, target); return res; } } References 1. 组合总和 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-40/","summary":"思路 经典带重复元素的组合问题，详见思想篇章 代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; private void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if (trackSum \u0026gt; target) { return; } for (int i = start;","title":"LeetCode 40"},{"content":"思路 经典带重复元素的子集问题，详见思想篇章\n代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); private void backtrack(int[] nums, int start) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); for (int i = start; i \u0026lt; nums.length; i++) { if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } track.add(nums[i]); backtrack(nums, i + 1); track.remove(track.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); backtrack(nums, 0); return res; } } References 1. 子集 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-90/","summary":"思路 经典带重复元素的子集问题，详见思想篇章 代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); private void backtrack(int[] nums, int start) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); for (int i = start; i \u0026lt; nums.length; i++) { if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } track.add(nums[i]); backtrack(nums,","title":"LeetCode 90"},{"content":"思路 经典组合问题，不解释了，详见思想篇章\n代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { backtrack(n, 1, k); return res; } private void backtrack(int n, int start, int k) { if (track.size() == k) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i = start; i \u0026lt;= n; i++) { track.add(i); backtrack(n, i + 1, k); track.remove(track.size() - 1); } } } References 1. 组合 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-77/","summary":"思路 经典组合问题，不解释了，详见思想篇章 代码 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { backtrack(n, 1, k); return res; } private void backtrack(int n, int start, int k) { if (track.size() == k) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i =","title":"LeetCode 77"},{"content":"思路 两种思路：\n回溯 经典子集问题，不解释了，详见思想篇章\n迭代 因为每一个元素要么选要么不选，所以可以看成有n个盒子n个数，每个数要么放进盒子，要么不放，可以把放进盒子看成1，不放盒子看成0，那么所有的2^n个情况就是[0, 2^n - 1]。\n代码 回溯 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { backtrack(nums, 0); return res; } private void backtrack(int[] nums, int start) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); for (int i = start; i \u0026lt; nums.length; i++) { track.add(nums[i]); backtrack(nums, i + 1); track.remove(track.size() - 1); } } } 迭代 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;Integer\u0026gt; track = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); int n = nums.length; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask++) { track.clear(); for (int i = 0; i \u0026lt; n; i++) { if ((mask \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0) { track.add(nums[i]); } } res.add(new ArrayList\u0026lt;\u0026gt;(track)); } return res; } } References 1. 子集 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-78/","summary":"思路 两种思路： 回溯 经典子集问题，不解释了，详见思想篇章 迭代 因为每一个元素要么选要么不选，所以可以看成有n个盒子n个数，每个数要么放进盒子，要","title":"LeetCode 78"},{"content":"思路 利用回溯算法，这种排列组合问题的各种变体都可以抽象成「球盒模型」，将子集看成盒子，那么每个盒子遍历一遍数组，要么将元素放盒子里面要么不放，就这样回溯，只不过代码有点难写\n代码 class Solution { private Map\u0026lt;Integer, Boolean\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public boolean canPartitionKSubsets(int[] nums, int k) { int n = nums.length, sum = 0; if (k \u0026gt; n) { return false; } for (int num : nums) { sum += num; } if (sum % k != 0) { return false; } int used = 0; return backtrack(nums, used, 0, 0, sum / k, k); } private boolean backtrack(int[] nums, int used, int bucket, int start ,int target, int k) { if (k == 0) { return true; } if (bucket == target) { boolean res = backtrack(nums, used, 0, 0, target, k - 1); memo.put(used, res); return res; } if (memo.containsKey(used)) { return memo.get(used); } for (int i = start; i \u0026lt; nums.length; i++) { if (((used \u0026gt;\u0026gt; i) \u0026amp; 1) == 1) { continue; } if (bucket + nums[i] \u0026gt; target) { continue; } bucket += nums[i]; used |= 1 \u0026lt;\u0026lt; i; if (backtrack(nums, used, bucket, i + 1, target, k)) { return true; } bucket -= nums[i]; used ^= 1 \u0026lt;\u0026lt; i; } return false; } } References 1. 划分为k个相等的子集 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-698/","summary":"思路 利用回溯算法，这种排列组合问题的各种变体都可以抽象成「球盒模型」，将子集看成盒子，那么每个盒子遍历一遍数组，要么将元素放盒子里面要么不放","title":"LeetCode 698"},{"content":"思路 利用回溯算法，在棋盘上从上往下下棋子，如果不能下就换个格子，如果一整行都不能下，就回溯到上一行换下一个格子\n代码 class Solution { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;StringBuilder\u0026gt; board = new ArrayList\u0026lt;\u0026gt;(); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; n; i++) { sb.append(\u0026#39;.\u0026#39;); } for (int i = 0; i \u0026lt; n; i++) { board.add(new StringBuilder(sb.toString())); } backtrack(board, 0); return res; } private void backtrack(List\u0026lt;StringBuilder\u0026gt; board, int row) { if (row == board.size()) { List\u0026lt;String\u0026gt; r = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; board.size(); i++) { r.add(board.get(i).toString()); } res.add(r); return; } for (int col = 0; col \u0026lt; board.get(row).length(); col++) { if (!canPlace(board, row, col)) { continue; } board.get(row).replace(col, col + 1, \u0026#34;Q\u0026#34;); backtrack(board, row + 1); board.get(row).replace(col, col + 1, \u0026#34;.\u0026#34;); } } private boolean canPlace(List\u0026lt;StringBuilder\u0026gt; board, int row, int col) { int n = board.size(); for (int i = 0; i \u0026lt; row; i++) { if (board.get(i).charAt(col) == \u0026#39;Q\u0026#39;) { return false; } } for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board.get(i).charAt(j) == \u0026#39;Q\u0026#39;) { return false; } } for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board.get(i).charAt(j) == \u0026#39;Q\u0026#39;) { return false; } } return true; } } References 1. N 皇后 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-51/","summary":"思路 利用回溯算法，在棋盘上从上往下下棋子，如果不能下就换个格子，如果一整行都不能下，就回溯到上一行换下一个格子 代码 class Solution { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) {","title":"LeetCode 51"},{"content":"思路 经典回溯问题，直接套模板即可，决策树如下：\n代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { int n = nums.length; boolean[] used = new boolean[n]; List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(track, nums, used); return res; } private void backtrack(List\u0026lt;Integer\u0026gt; track, int[] nums, boolean[] used) { if (track.size() == nums.length) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) { continue; } track.add(nums[i]); used[i] = true; backtrack(track, nums, used); track.remove(track.size() - 1); used[i] = false; } } } References 1. 全排列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-46/","summary":"思路 经典回溯问题，直接套模板即可，决策树如下： 代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { int n = nums.length; boolean[] used = new boolean[n]; List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(track, nums, used); return res; } private void backtrack(List\u0026lt;Integer\u0026gt; track, int[] nums, boolean[] used) { if (track.size()","title":"LeetCode 46"},{"content":"思路 其实就是求同一时刻最多有多少重叠区间，其实投影到x轴然后看看有几个区间重合到一起了就可以，有两种代码思路：\n用数组表示x轴+差分数组优化 举例来说，如果输入 meetings = [[0,30],[5,10],[15,20]]，那么我们就给数组中 [0,30],[5,10],[15,20] 这几个索引区间分别加一，最后遍历数组，求个最大值就行了。\n扫描法 只记录start和end时间，然后扫描这些时间点，碰到start，count++，碰到end，count\u0026ndash;，记录count的最大值即可\n代码 class Solution { public int minMeetingRooms(List\u0026lt;Interval\u0026gt; intervals) { int n = intervals.size(); int[] start = new int[n]; int[] end = new int[n]; for (int i = 0; i \u0026lt; n; i++) { start[i] = intervals.get(i).start; end[i] = intervals.get(i).end; } Arrays.sort(start); Arrays.sort(end); int i = 0, j = 0, res = 0, count = 0; while (i \u0026lt; n) { if (start[i] \u0026lt; end[j]) { count++; i++; } else { count--; j++; } res = Math.max(res, count); } return res; } } References 1. 会议室 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-253/","summary":"思路 其实就是求同一时刻最多有多少重叠区间，其实投影到x轴然后看看有几个区间重合到一起了就可以，有两种代码思路： 用数组表示x轴+差分数组优化 举","title":"LeetCode 253"},{"content":"思路 利用贪心算法，每次跳的时候选择一个最有潜力的结点跳，只不过代码有点难写\n代码 class Solution { public int jump(int[] nums) { int n = nums.length, farthest = 0, jumps = 0, end = 0; for (int i = 0; i \u0026lt; n - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i == end) { jumps++; end = farthest; } } return jumps; } } References 1. 跳跃游戏 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-45/","summary":"思路 利用贪心算法，每次跳的时候选择一个最有潜力的结点跳，只不过代码有点难写 代码 class Solution { public int jump(int[] nums) { int n = nums.length, farthest = 0, jumps = 0, end = 0; for (int i = 0; i \u0026lt; n - 1;","title":"LeetCode 45"},{"content":"思路 利用贪心算法，每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 farthest 做对比，通过每一步的最优解，更新全局最优解\n代码 class Solution { public boolean canJump(int[] nums) { int farthest = 0; for (int i = 0; i \u0026lt;= farthest \u0026amp;\u0026amp; i \u0026lt; nums.length; i++) { farthest = Math.max(farthest, i + nums[i]); } return farthest \u0026gt;= nums.length - 1; } } References 1. 跳跃游戏 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-55/","summary":"思路 利用贪心算法，每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 farthest 做对比，通过每一步的最优解，更新全局最优解 代码 class","title":"LeetCode 55"},{"content":"思路 利用贪心算法，思路很简单，先按start排序，遍历区间，找end最大的区间，然后再遍历区间找start小于前一个end，end最大的区间，就是代码有点难写，算法过程见下图：\n代码 class Solution { public int videoStitching(int[][] clips, int time) { Arrays.sort(clips, (a, b) -\u0026gt; { return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]; }); int n = clips.length, i = 0, curEnd = 0, nextEnd = 0, res = 0; while (i \u0026lt; n \u0026amp;\u0026amp; clips[i][0] \u0026lt;= curEnd) { while (i \u0026lt; n \u0026amp;\u0026amp; clips[i][0] \u0026lt;= curEnd) { nextEnd = Math.max(nextEnd, clips[i][1]); i++; } res++; curEnd = nextEnd; if (curEnd \u0026gt;= time) { return res; } } return -1; } } References 1. 视频拼接 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1024/","summary":"思路 利用贪心算法，思路很简单，先按start排序，遍历区间，找end最大的区间，然后再遍历区间找start小于前一个end，end最大的区间","title":"LeetCode 1024"},{"content":"思路 其实就是求解无重叠区间最多有几个，同LeetCode-435，因为可以每一发都打在无重叠区间中每个区间的最右边，这样下一个区间之前的区间都被贯穿，如下图所示：\n只不过这道题相邻的两个区间边界触碰也算是重叠区间，interval[0] \u0026gt;= x_end改成interval[0] \u0026gt; x_end就可以了\n代码 class Solution { private int intervalSchedule(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u0026gt; { if (a[1] \u0026gt; b[1]) { return 1; } else if (a[1] \u0026lt; b[1]) { return -1; } else { return 0; } }); int count = 1, x_end = intervals[0][1]; for (int[] interval : intervals) { if (interval[0] \u0026gt; x_end) { count++; x_end = interval[1]; } } return count; } public int findMinArrowShots(int[][] points) { return intervalSchedule(points); } } References 1. 用最少数量的箭引爆气球 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-452/","summary":"思路 其实就是求解无重叠区间最多有几个，同LeetCode-435，因为可以每一发都打在无重叠区间中每个区间的最右边，这样下一个区间之前的区间","title":"LeetCode 452"},{"content":"思路 利用贪心算法，每次选择结束最早的区间（这就是局部最优选择），然后统计就可以了\n代码 class Solution { private int intervalSchedule(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u0026gt; { return a[1] - b[1]; }); int count = 1, x_end = intervals[0][1]; for (int[] interval : intervals) { if (interval[0] \u0026gt;= x_end) { count++; x_end = interval[1]; } } return count; } public int eraseOverlapIntervals(int[][] intervals) { return intervals.length - intervalSchedule(intervals); } } References 1. 无重叠区间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-435/","summary":"思路 利用贪心算法，每次选择结束最早的区间（这就是局部最优选择），然后统计就可以了 代码 class Solution { private int intervalSchedule(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u0026gt; { return a[1] - b[1]; }); int count = 1, x_end = intervals[0][1]; for (int[] interval","title":"LeetCode 435"},{"content":"思路 利用动态规划的思想，dp[i][j] = x表示，戳破气球i和气球j之间（开区间，不包括i和j）的所有气球，可以获得的最高分数为x。状态转移方程为：\nfor (int k = i + 1; k \u0026lt; j; k++) { dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]); } base case和遍历顺序如下：\n可以优化空间复杂度\n代码 class Solution { public int maxCoins(int[] nums) { int n = nums.length; int [] points = new int[n + 2]; for (int i = 0; i \u0026lt; n; i++) { points[i + 1] = nums[i]; } points[0] = points[n + 1] = 1; int[][] dp = new int[n + 2][n + 2]; for (int i = n; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n + 2; j++) { for (int k = i + 1; k \u0026lt; j; k++) { dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]); } } } return dp[0][n + 1]; } } References 1. 戳气球 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-312/","summary":"思路 利用动态规划的思想，dp[i][j] = x表示，戳破气球i和气球j之间（开区间，不包括i和j）的所有气球，可以获得的最高分数为x。状态转移","title":"LeetCode 312"},{"content":"思路 比较复杂，详见：https://leetcode.cn/problems/super-egg-drop/solutions/44427/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/\n代码 基本动态规划版(会超时) class Solution { private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int superEggDrop(int k, int n) { if (k == 1) { return n; } if (n == 0) { return 0; } if (memo.containsKey(k + \u0026#34;,\u0026#34; + n)) { return memo.get(k + \u0026#34;,\u0026#34; + n); } int res = Integer.MAX_VALUE; for (int i = 1; i \u0026lt;= n; i++) { res = Math.min(res, Math.max(superEggDrop(k, n - i), superEggDrop(k - 1, i - 1)) + 1); } memo.put(k + \u0026#34;,\u0026#34; + n, res); return res; } } 基本动态规划+二分查找版 class Solution { // 基本动态规划+二分查找版 private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int superEggDrop(int k, int n) { if (k == 1) { return n; } if (n == 0) { return 0; } if (memo.containsKey(k + \u0026#34;,\u0026#34; + n)) { return memo.get(k + \u0026#34;,\u0026#34; + n); } int res = Integer.MAX_VALUE; int left = 1, right = n; while (left \u0026lt;= right) { int mid = (left + right) / 2; int broken = superEggDrop(k - 1, mid - 1); int notBroken = superEggDrop(k, n - mid); int midVal = broken - notBroken; if (0 \u0026gt; midVal) { left = mid + 1; res = Math.min(res, notBroken + 1); } else if (0 \u0026lt; midVal) { right = mid - 1; res = Math.min(res, broken + 1); } else { res = broken + 1; break; } } memo.put(k + \u0026#34;,\u0026#34; + n, res); return res; } } 进阶动态规划版 class Solution { // 进阶动态规划版 public int superEggDrop(int k, int n) { int[][] dp = new int[k + 1][n + 1]; int m = 0; while (dp[k][m] \u0026lt; n) { m++; for (int i = 1; i \u0026lt;= k; i++) { dp[i][m] = dp[i][m - 1] + 1 + dp[i - 1][m - 1]; } } return m; } } References 1. 鸡蛋掉落 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-887/","summary":"思路 比较复杂，详见：https://leetcode.cn/problems/super-egg-drop/solutions/44427/","title":"LeetCode 887"},{"content":"思路 同LeetCode-198，只不过变成了二叉树\n代码 原版 class Solution { private Map\u0026lt;TreeNode, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int rob(TreeNode root) { if (root == null) { return 0; } if (memo.containsKey(root)) { return memo.get(root); } int do_it = root.val + (root.left == null ? 0 : rob(root.left.left) + rob(root.left.right)) + (root.right == null ? 0 : rob(root.right.left) + rob(root.right.right)); int not_do = rob(root.left) + rob(root.right); int res = Math.max(do_it, not_do); memo.put(root, res); return res; } } 更加优秀的版本 class Solution { private int[] dp(TreeNode root) { if (root == null) { return new int[]{0, 0}; } int[] left = dp(root.left); int[] right = dp(root.right); int do_it = root.val + left[0] + right[0]; int not_do = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); return new int[]{not_do, do_it}; } public int rob(TreeNode root) { int[] res = dp(root); return Math.max(res[0], res[1]); } } References 1. 打家劫舍 III ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-337/","summary":"思路 同LeetCode-198，只不过变成了二叉树 代码 原版 class Solution { private Map\u0026lt;TreeNode, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int rob(TreeNode root) { if (root == null) { return 0; } if (memo.containsKey(root)) { return memo.get(root); } int do_it = root.val + (root.left == null ? 0 : rob(root.left.left)","title":"LeetCode 337"},{"content":"思路 同LeetCode-198，只不过首尾不能同时偷，共有三种情况，其中第一种情况不需要考虑因为肯定比其他两种小\n代码 class Solution { private int robRange(int[] nums, int start, int end) { int dp_i_0 = 0, dp_i_1 = 0, dp_i_2 = 0; for (int i = 2 + start; i \u0026lt; end + 3; i++) { dp_i_2 = Math.max(dp_i_1, dp_i_0 + nums[i - 2]); dp_i_0 = dp_i_1; dp_i_1 = dp_i_2; } return dp_i_2; } public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1)); } } References 1. 打家劫舍 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-213/","summary":"思路 同LeetCode-198，只不过首尾不能同时偷，共有三种情况，其中第一种情况不需要考虑因为肯定比其他两种小 代码 class Solution { private int robRange(int[] nums, int start, int end) {","title":"LeetCode 213"},{"content":"思路 利用动态规划的思想，dp数组里存截止到当前户最多偷到多少钱，状态转移方程为：\ndp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 2]); base case 为dp[0]和dp[1]为0，可以优化空间复杂度\n代码 原版 class Solution { public int rob(int[] nums) { int n = nums.length; int[] dp = new int[n + 2]; for (int i = 2; i \u0026lt; n + 2; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 2]); } return dp[n + 1]; } } 优化空间复杂度 class Solution { public int rob(int[] nums) { int n = nums.length; int dp_i_0 = 0, dp_i_1 = 0, dp_i_2 = 0; for (int i = 2; i \u0026lt; n + 2; i++) { dp_i_2 = Math.max(dp_i_1, dp_i_0 + nums[i - 2]); dp_i_0 = dp_i_1; dp_i_1 = dp_i_2; } return dp_i_2; } } References 1. 打家劫舍 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-198/","summary":"思路 利用动态规划的思想，dp数组里存截止到当前户最多偷到多少钱，状态转移方程为： dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 2]); base case 为dp[0]和dp[1]为0，可","title":"LeetCode 198"},{"content":"思路 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/96/\n代码 121题 class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); } return dp[n - 1][0]; } } 122题 class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]); } return dp[n - 1][0]; } } 309题 class Solution { public int maxProfit(int[] prices) { if (prices.length == 1) { return 0; } int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]); dp[1][1] = Math.max(dp[0][1], -prices[1]); for (int i = 2; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]); } return dp[n - 1][0]; } } 714题 class Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0] - fee; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee); } return dp[n - 1][0]; } } 123题 class Solution { public int maxProfit(int[] prices) { int max_k = 2, n = prices.length; int[][][] dp = new int[n][max_k + 1][2]; for (int i = max_k; i \u0026gt;= 1; i--) { dp[0][i][0] = 0; dp[0][i][1] = -prices[0]; } for (int i = 1; i \u0026lt; n; i++) { for (int k = max_k; k \u0026gt;= 1; k--) { dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } } return dp[n - 1][max_k][0]; } } 188题 class Solution { private int maxProfit_k_inf(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]); } return dp[n - 1][0]; } public int maxProfit(int max_k, int[] prices) { int n = prices.length; if (n \u0026lt;= 0) { return 0; } if (max_k \u0026gt;= n / 2) { // 复用之前交易次数 k 没有限制的情况 return maxProfit_k_inf(prices); } // base case： // dp[-1][...][0] = dp[...][0][0] = 0 // dp[-1][...][1] = dp[...][0][1] = -infinity int[][][] dp = new int[n][max_k + 1][2]; // k = 0 时的 base case for (int i = 0; i \u0026lt; n; i++) { dp[i][0][1] = Integer.MIN_VALUE; dp[i][0][0] = 0; } for (int i = 0; i \u0026lt; n; i++) for (int k = max_k; k \u0026gt;= 1; k--) { if (i - 1 == -1) { // 处理 i = -1 时的 base case dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; } dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } return dp[n - 1][max_k][0]; } } References 1. 买卖股票的最佳时机 2. 买卖股票的最佳时机 II 3. 买卖股票的最佳时机 III 4. 买卖股票的最佳时机 IV 5. 最佳买卖股票时机含冷冻期 6. 买卖股票的最佳时机含手续费 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-121+122+123+188+309+714/","summary":"思路 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/96/ 代码 121题 class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][]","title":"LeetCode 121+122+123+188+309+714"},{"content":"思路 利用动态规划的思想，dp数组里存s[i\u0026hellip;j]的最长回文子序列，状态转移方程如下：\nif (s.charAt(j) == s.charAt(j + i)) { dp[j][j + i] = 2 + dp[j + 1][j + i - 1]; } else { dp[j][j + i] = Math.max(dp[j + 1][j + i], dp[j][j + i - 1]); } base case为如下的0和1：\n可以斜着遍历，也可以从下往上遍历，可以优化空间复杂度\n代码 class Solution { public int longestPalindromeSubseq(String s) { int n = s.length(); int[][] dp = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { dp[i][i] = 1; } for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n - i; j++) { if (s.charAt(j) == s.charAt(j + i)) { dp[j][j + i] = 2 + dp[j + 1][j + i - 1]; } else { dp[j][j + i] = Math.max(dp[j + 1][j + i], dp[j][j + i - 1]); } } } return dp[0][n - 1]; } } References 1. 最长回文子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-516/","summary":"思路 利用动态规划的思想，dp数组里存s[i\u0026hellip;j]的最长回文子序列，状态转移方程如下： if (s.charAt(j) == s.charAt(j + i)) { dp[j][j + i] = 2 + dp[j + 1][j + i - 1]; }","title":"LeetCode 516"},{"content":"思路 dp数组里存s[i\u0026hellip;]和p[j\u0026hellip;]是否匹配，状态转移方程需要根据s[i]和p[j]是否相等来选择，具体如下：\nif (p.charAt(j) == \u0026#39;.\u0026#39; || s.charAt(i) == p.charAt(j)) { if (p.charAt(j + 1) == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j + 2] || dp[i + 1][j]; } else { dp[i][j] = dp[i + 1][j + 1]; } } else { if (p.charAt(j + 1) == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j + 2]; } else { dp[i][j] = false; } } base case为：\ndp[m][n] = true; for (int i = n - 2; i \u0026gt;= 0; i -= 2) { dp[m][i] = dp[m][i + 2] \u0026amp;\u0026amp; (p.charAt(i + 1) == \u0026#39;*\u0026#39;); } 可以优化空间复杂度，详见：https://mp.weixin.qq.com/s/rnaFK05IcFWvNN1ppNf2ug\n代码 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); s = s + \u0026#34;#\u0026#34;; p = p + \u0026#34;#\u0026#34;; boolean[][] dp = new boolean[m + 1][n + 1]; dp[m][n] = true; for (int i = n - 2; i \u0026gt;= 0; i -= 2) { dp[m][i] = dp[m][i + 2] \u0026amp;\u0026amp; (p.charAt(i + 1) == \u0026#39;*\u0026#39;); } for (int i = m - 1; i \u0026gt;= 0; i--) { for (int j = n - 1; j \u0026gt;= 0; j--) { if (p.charAt(j) == \u0026#39;*\u0026#39;) { continue; } if (p.charAt(j) == \u0026#39;.\u0026#39; || s.charAt(i) == p.charAt(j)) { if (p.charAt(j + 1) == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j + 2] || dp[i + 1][j]; } else { dp[i][j] = dp[i + 1][j + 1]; } } else { if (p.charAt(j + 1) == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j + 2]; } else { dp[i][j] = false; } } } } return dp[0][0]; } } References 1. 正则表达式匹配 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-10/","summary":"思路 dp数组里存s[i\u0026hellip;]和p[j\u0026hellip;]是否匹配，状态转移方程需要根据s[i]和p[j]是否相等来选择，具体如下：","title":"LeetCode 10"},{"content":"思路 与LeetCode-64类似，只不过dp数组中dp[i][j]的定义是从 grid[i][j] 到达终点（右下角）所需的最少生命值\n代码 class Solution { public int calculateMinimumHP(int[][] dungeon) { int m = dungeon.length, n = dungeon[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt; m; i++) { dp[i][n] = Integer.MAX_VALUE; } for (int i = 0; i \u0026lt; m; i++) { dp[i][n] = Integer.MAX_VALUE; } for (int i = 0; i \u0026lt; n; i++) { dp[m][i] = Integer.MAX_VALUE; } dp[m - 1][n - 1] = dungeon[m - 1][n - 1] \u0026gt;= 0 ? 1 : -dungeon[m - 1][n - 1] + 1; for (int i = m - 1; i \u0026gt;= 0; i--) { for (int j = n - 1; j \u0026gt;= 0; j--) { if (i != m - 1 || j != n - 1) { int temp = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]; dp[i][j] = temp \u0026gt; 0 ? temp : 1; } } } return dp[0][0]; } } References 1. 地下城游戏 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-174/","summary":"思路 与LeetCode-64类似，只不过dp数组中dp[i][j]的定义是从 grid[i][j] 到达终点（右下角）所需的最少生命值 代码 class Solution { public int calculateMinimumHP(int[][] dungeon) { int m = dungeon.length,","title":"LeetCode 174"},{"content":"思路 经典动态规划问题，构造dp[][]数组，里面存放从(0, 0)到(i, j)的最小路径，dp[i][j]由min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]得来，base case为第一行和第一列，可以优化空间复杂度\n代码 class Solution { public int minPathSum(int[][] grid) { int m = grid.length, n = grid[0].length; int[][] dp = new int[m][n]; dp[0][0] = grid[0][0]; for (int i = 1; i \u0026lt; m; i++) { dp[i][0] = dp[i - 1][0] + grid[i][0]; } for (int i = 1; i \u0026lt; n; i++) { dp[0][i] = dp[0][i - 1] + grid[0][i]; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; } } References 1. 最小路径和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-64/","summary":"思路 经典动态规划问题，构造dp[][]数组，里面存放从(0, 0)到(i, j)的最小路径，dp[i][j]由min(dp[i - 1][j], dp[i][j - 1]) + gri","title":"LeetCode 64"},{"content":"思路 有三种思路：\n递归思路 findTargetSumWays(nums, i, remain) = findTargetSumWays(nums, i + 1, remain - nums[i]) + findTargetSumWays(nums, i + 1, remain + nums[i])，直接看代码\n回溯思路 经典回溯问题，套模板即可\n动态规划 这道题还可以转换为子集划分问题，如果我们把 nums 划分成两个子集 A 和 B，分别代表分配 + 的数和分配 - 的数，那么他们和 target 存在如下关系：\nsum(A) - sum(B) = target sum(A) = target + sum(B) sum(A) + sum(A) = target + sum(B) + sum(A) 2 * sum(A) = target + sum(nums) 综上，可以推出 sum(A) = (target + sum(nums)) / 2，也就是把原问题转化成：nums 中存在几个子集 A，使得 A 中元素的和为 (target + sum(nums)) / 2？这就是一个子集背包问题了，直接套模板即可，详见思想篇章\n代码 递归解法 class Solution { private int findTargetSumWays(int[] nums, int i, int remain) { if (i == nums.length) { if (remain == 0) { return 1; } return 0; } return findTargetSumWays(nums, i + 1, remain - nums[i]) + findTargetSumWays(nums, i + 1, remain + nums[i]); } public int findTargetSumWays(int[] nums, int target) { // 递归解法 return findTargetSumWays(nums, 0, target); } } 回溯解法 class Solution { private int count = 0; private void backtrack(int[] nums, int i, int remain) { if (i == nums.length) { if (remain == 0) { count++; } return; } remain -= nums[i]; backtrack(nums, i + 1, remain); remain += nums[i]; remain += nums[i]; backtrack(nums, i + 1, remain); remain -= nums[i]; } public int findTargetSumWays(int[] nums, int target) { // 回溯解法 backtrack(nums, 0, target); return count; } } 子集背包解法 // 原版 class Solution { public int findTargetSumWays(int[] nums, int target) { // 动态规划(子集背包问题) int n = nums.length, sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; } if (Math.abs(target) \u0026gt; sum || (sum + target) % 2 == 1) { return 0; } sum = (sum + target) / 2; int[][] dp = new int[n + 1][sum + 1]; dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= sum; j++) { if (j \u0026lt; nums[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]; } } } return dp[n][sum]; } } // 优化空间复杂度 class Solution { public int findTargetSumWays(int[] nums, int target) { // 动态规划(子集背包问题) int n = nums.length, sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; } if (Math.abs(target) \u0026gt; sum || (sum + target) % 2 == 1) { return 0; } sum = (sum + target) / 2; int[] dp = new int[sum + 1]; dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = sum; j \u0026gt;= 0; j--) { if (j \u0026gt;= nums[i - 1]) { dp[j] = dp[j] + dp[j - nums[i - 1]]; } } } return dp[sum]; } } References 1. 目标和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-494/","summary":"思路 有三种思路： 递归思路 findTargetSumWays(nums, i, remain) = findTargetSumWays(nums, i + 1, remain - nums[i]) + findTargetSumWays(nums, i + 1, remain + nums[i])，直接看代码 回溯思路 经典回溯问题，套模板即可 动态规划 这道题还可以","title":"LeetCode 494"},{"content":"思路 经典完全背包问题，直接套模板即可，详见思想篇章，可以优化空间复杂度\n代码 原版 class Solution { public int change(int amount, int[] coins) { int n = coins.length; int[][] dp = new int[n + 1][amount + 1]; for (int i = 0; i \u0026lt;= n; i++) { dp[i][0] = 1; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= amount; j++) { if (j \u0026lt; coins[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; } } } return dp[n][amount]; } } 优化空间复杂度 class Solution { public int change(int amount, int[] coins) { int n = coins.length; int[] dp = new int[amount + 1]; dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= amount; j++) { if (j \u0026gt;= coins[i - 1]) { dp[j] = dp[j] + dp[j - coins[i - 1]]; } } } return dp[amount]; } } References 1. 零钱兑换 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-518/","summary":"思路 经典完全背包问题，直接套模板即可，详见思想篇章，可以优化空间复杂度 代码 原版 class Solution { public int change(int amount, int[] coins) { int n = coins.length; int[][] dp = new int[n + 1][amount + 1]; for (int i = 0; i \u0026lt;= n;","title":"LeetCode 518"},{"content":"思路 其实就是背包问题，直接套背包问题模板，构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下 dp[i][w]表示能否将该背包装满。base case是第一列取值为true，可以优化空间复杂度，但是要注意j需要倒着遍历\n代码 原版 class Solution { public boolean canPartition(int[] nums) { int n = nums.length, sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; } if (sum % 2 != 0) { return false; } boolean[][] dp = new boolean[n + 1][sum / 2 + 1]; for (int i = 0; i \u0026lt;= n; i++) { dp[i][0] = true; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= sum / 2; j++) { if (j \u0026lt; nums[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]; } } } return dp[n][sum / 2]; } } 优化空间复杂度 class Solution { public boolean canPartition(int[] nums) { int n = nums.length, sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += nums[i]; } if (sum % 2 != 0) { return false; } boolean[] dp = new boolean[sum / 2 + 1]; dp[0] = true; for (int i = 1; i \u0026lt;= n; i++) { for (int j = sum / 2; j \u0026gt;= 1; j--) { if (j \u0026gt;= nums[i - 1]) { dp[j] = dp[j] || dp[j - nums[i - 1]]; } } } return dp[sum / 2]; } } References 1. 分割等和子集 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-416/","summary":"思路 其实就是背包问题，直接套背包问题模板，构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下 dp[","title":"LeetCode 416"},{"content":"思路 利用动态规划的思想，同LeetCode-583，只不过不是计算删除操作数，而是删除的ASCII码\n代码 class Solution { public int minimumDeleteSum(String s1, String s2) { int m = s1.length(), n = s2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= n; i++) { dp[0][i] = dp[0][i - 1] + s2.charAt(i - 1); } for (int i = 1; i \u0026lt;= m; i++) { dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1); } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (s1.charAt(i - 1) == s2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i][j - 1] + s2.charAt(j - 1), dp[i - 1][j] + s1.charAt(i - 1)); } } } return dp[m][n]; } } References 1. 两个字符串的最小ASCII删除和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-712/","summary":"思路 利用动态规划的思想，同LeetCode-583，只不过不是计算删除操作数，而是删除的ASCII码 代码 class Solution { public int minimumDeleteSum(String s1, String s2) { int m = s1.length(), n = s2.length(); int[][]","title":"LeetCode 712"},{"content":"思路 基本同最长公共子序列：LeetCode-1143，也可以直接重用LCS，因为删除的结果不就是它俩的最长公共子序列，那么删除的次数就是word1.length() + word2.length() - 2 * lcsLen\n代码 class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt;= n; i++) { dp[0][i] = i; } for (int i = 0; i \u0026lt;= m; i++) { dp[i][0] = i; } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1); } } } return dp[m][n]; } } References 1. 两个字符串的删除操作 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-583/","summary":"思路 基本同最长公共子序列：LeetCode-1143，也可以直接重用LCS，因为删除的结果不就是它俩的最长公共子序列，那么删除的次数就是wo","title":"LeetCode 583"},{"content":"思路 利用动态规划的思想，dp数组里存s1[0\u0026hellip;i]和s2[0\u0026hellip;j]的最长公共子序列，如果s1[i]==s2[j]，dp[i][j]由dp[i-1][j-1]+1得来，否则dp[i][j]由max(dp[i][j-1], dp[i-1][j])得来，base case是dp[0][\u0026hellip;]和dp[\u0026hellip;][0]为0，可以优化空间复杂度\n代码 class Solution { public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { dp[i][j] = 1 + dp[i - 1][j - 1]; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } } References 1. 最长公共子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1143/","summary":"思路 利用动态规划的思想，dp数组里存s1[0\u0026hellip;i]和s2[0\u0026hellip;j]的最长公共子序列，如果s1[i]==s2[j]","title":"LeetCode 1143"},{"content":"思路 三种思路：\n动态规划 dp数组里放以该元素结尾的最大子数组和，可以由前面那个元素推出来，base case是dp[0] = nums[0]，可以优化空间复杂度\n滑动窗口 其实和动态规划一样，就是窗口里的元素和如果大于0，就扩大窗口（因为是正的加上后面的元素才有可能更大），窗口里的元素和如果小于0，就缩小窗口（因为是负的加上后面的元素只会更大），和动态规划其实一样的\n前缀和数组 利用前缀和数组的思想，最大子数组之和其实就是 preSum[i+1] - min(preSum[0..i])\n代码 动态规划 class Solution { public int maxSubArray(int[] nums) { // 动态规划 int n = nums.length; int dp_0 = nums[0], res = dp_0; for (int i = 1; i \u0026lt; n; i++) { dp_0 = Math.max(dp_0 + nums[i], nums[i]); res = Math.max(res, dp_0); } return res; } } 滑动窗口 class Solution { public int maxSubArray(int[] nums) { // 滑动窗口 int left = 0, right = 0; int windowSum = 0, res = Integer.MIN_VALUE; while (right \u0026lt; nums.length) { windowSum += nums[right]; right++; res = Math.max(res, windowSum); while (windowSum \u0026lt; 0) { windowSum -= nums[left]; left++; } } return res; } } 前缀和数组 class Solution { public int maxSubArray(int[] nums) { // 前缀和数组 int n = nums.length; int[] preSum = new int[n + 1]; for (int i = 0; i \u0026lt; n ; i++) { preSum[i + 1] = preSum[i] + nums[i]; } int minVal = Integer.MAX_VALUE, res = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; n; i++) { minVal = Math.min(minVal, preSum[i]); res = Math.max(res, preSum[i + 1] - minVal); } return res; } } References 1. 最大子数组和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-53/","summary":"思路 三种思路： 动态规划 dp数组里放以该元素结尾的最大子数组和，可以由前面那个元素推出来，base case是dp[0] = nums[0]，可以优","title":"LeetCode 53"},{"content":"思路 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来：\nbase case是第一行和第一列，可以优化空间复杂度但是懒得弄了\n补充：具体s1是怎么转换为s2的，可以在dp数组的每个元素里补充额外的信息，详见：https://labuladong.gitee.io/algo/3/26/75/\n代码 class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt;= m; i++) { dp[i][0] = i; } for (int i = 0; i \u0026lt;= n; i++) { dp[0][i] = i; } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1)); } } } return dp[m][n]; } } References 1. 编辑距离 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-72/","summary":"思路 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来： base case是第一行和第一","title":"LeetCode 72"},{"content":"思路 利用动态规划的思想，dp数组里放落到该位置的最小路径和，由上一行临近自己的三个元素最小值+自己元素的大小得到，base case是dp数组第一行为matrix数组第一行，可以优化空间复杂度，因为只用到了两行，但是懒得弄了\n代码 class Solution { public int minFallingPathSum(int[][] matrix) { int n = matrix.length; int[][] dp = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { dp[0][i] = matrix[0][i]; } for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.min(dp[i - 1][0], dp[i - 1][1]) + matrix[i][0]; for (int j = 1; j \u0026lt; n - 1; j++) { dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j + 1])) + matrix[i][j]; } dp[i][n - 1] = Math.min(dp[i - 1][n - 1], dp[i - 1][n - 2]) + matrix[i][n - 1]; } int res = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; n; i++) { res = Math.min(res, dp[n - 1][i]); } return res; } } References 1. 下降路径最小和 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-931/","summary":"思路 利用动态规划的思想，dp数组里放落到该位置的最小路径和，由上一行临近自己的三个元素最小值+自己元素的大小得到，base case是dp数组","title":"LeetCode 931"},{"content":"思路 本质上就是最长递增子序列问题，见LeetCode-300，只不过需要先对width升序排序，然后计算height的最长递增子序列即可\nps：此版本会超时，需要融合二分查找\n代码 class Solution { public int maxEnvelopes(int[][] envelopes) { int n = envelopes.length; Arrays.sort(envelopes, (a, b) -\u0026gt; { return a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]; }); int[] dp = new int[n]; Arrays.fill(dp, 1); int res = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (envelopes[j][1] \u0026lt; envelopes[i][1]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } res = Math.max(res, dp[i]); } return res; } } References 1. 俄罗斯套娃信封问题 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-354/","summary":"思路 本质上就是最长递增子序列问题，见LeetCode-300，只不过需要先对width升序排序，然后计算height的最长递增子序列即可 ps","title":"LeetCode 354"},{"content":"思路 两种解法：\n动态规划 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素的索引，base case为f(0) = 1，具有最优子结构，状态转移方程为f(x) = \u0026hellip;.(懒得写了)，会有重叠子问题所以用dp数组记录，无法优化空间复杂度\n动态规划+二分查找 没看懂，也不重要，以后再说吧 // TODO\n代码 动态规划 class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length, res = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[j] \u0026lt; nums[i]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } res = Math.max(res, dp[i]); } return res; } } References 1. 最长递增子序列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-300/","summary":"思路 两种解法： 动态规划 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素","title":"LeetCode 300"},{"content":"动态规划基本问题 解法 经典动态规划问题，详见思想篇章\n题目 1. 斐波那契数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-509/\n2. 零钱兑换 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-322/\n3. 下降路径最小和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-931/\n4. 最小路径和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-64/\n5. 地下城游戏 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-174/\n6. 鸡蛋掉落 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-887/\n7. 戳气球 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-312/\n8. 单词拆分 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-139/\n9. 比特位计数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-338/\n10. 乘积最大子数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-152/\n11. 最大矩形 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-85/\n12. 最大正方形 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-221/\n13. 最长有效括号 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-32/\n14. 爬楼梯 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-70/\n正则表达式匹配 解法 详见题解\n题目 1. 正则表达式匹配 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-10/\n股票问题 解法 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/96/\n题目 1. 买卖股票的最佳时机 2. 买卖股票的最佳时机 II 3. 买卖股票的最佳时机 III 4. 买卖股票的最佳时机 IV 5. 最佳买卖股票时机含冷冻期 6. 买卖股票的最佳时机含手续费 打家劫舍问题 解法 详见题解\n题目 1. 打家劫舍 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-198/\n2. 打家劫舍 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-213/\n2. 打家劫舍 III 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-337/\nKMP算法 解法 详见思想篇章\n题目 1. 实现 strStr() 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-28/\n2. 通过连接另一个数组的子数组得到一个数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1764/\n子序列问题 最长递增子序列 解法 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素的索引，base case为f(0) = 1，具有最优子结构，状态转移方程为f(x) = \u0026hellip;.(懒得写了)，会有重叠子问题所以用dp数组记录，无法优化空间复杂度\n题目 1. 最长递增子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-300/\n2. 俄罗斯套娃信封问题 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-354/\n编辑距离 解法 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来：\nbase case是第一行和第一列，可以优化空间复杂度但是懒得弄了\n补充：具体s1是怎么转换为s2的，可以在dp数组的每个元素里补充额外的信息，详见：https://labuladong.gitee.io/algo/3/26/75/\n题目 1. 编辑距离 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-72/\n最大子数组和 解法 dp数组里放以该元素结尾的最大子数组和，可以由前面那个元素推出来，base case是dp[0] = nums[0]，可以优化空间复杂度\n还可以利用滑动窗口和前缀和数组解决\n题目 1. 最大子数组和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-53/\n最长公共子序列 解法 利用动态规划的思想，dp数组里存s1[0\u0026hellip;i]和s2[0\u0026hellip;j]的最长公共子序列，如果s1[i]==s2[j]，dp[i][j]由dp[i-1][j-1]+1得来，否则dp[i][j]由max(dp[i][j-1], dp[i-1][j])得来，base case是dp[0][\u0026hellip;]和dp[\u0026hellip;][0]为0，可以优化空间复杂度\n题目 1. 最长公共子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1143/\n2. 两个字符串的删除操作 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-583/\n3. 两个字符串的最小ASCII删除和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-712/\n最长回文子序列 解法 见题解\n题目 1. 最长回文子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-516/\n2. 回文子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-647/\n背包问题 0-1背包问题 解法 见思想篇章\n子集背包问题 解法 见思想篇章\n题目 1. 分割等和子集 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-416/\n2. 目标和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-494/\n完全背包问题 解法 见思想篇章\n题目 1. 零钱兑换 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-518/\n贪心算法 无重叠区间最多有几个 解法 利用贪心算法，每次选择结束最早的区间（这就是局部最优选择），然后统计就可以了\n题目 1. 无重叠区间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-435/\n2. 用最少数量的箭引爆气球 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-452/\n最少需要几个区间才能覆盖整个x轴 解法 利用贪心算法，思路很简单，先按start排序，遍历区间，找end最大的区间，然后再遍历区间找start小于前一个end，end最大的区间，就是代码有点难写\n题目 1. 视频拼接 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1024/\n跳跃游戏 解法 见题解\n题目 1. 跳跃游戏 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-55/\n2. 跳跃游戏 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-45/\n同一时刻最多有多少重叠区间 解法 见题解\n题目 1. 会议室 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-253/\n暴力搜索算法 回溯 一般回溯问题 解法 详见题解\n题目 1. 电话号码的字母组合 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-17/\nN皇后 解法 利用回溯算法，在棋盘上从上往下下棋子，如果不能下就换个格子，如果一整行都不能下，就回溯到上一行换下一个格子\n题目 1. N 皇后 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-51/\n集合划分问题 解法 利用回溯算法，这种排列组合问题的各种变体都可以抽象成「球盒模型」，将子集看成盒子，那么每个盒子遍历一遍数组，要么将元素放盒子里面要么不放，就这样回溯，只不过代码有点难写\n题目 1. 划分为k个相等的子集 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-698/\n排列组合子集问题 解法 详见思想篇章\n题目 1. 子集 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-78/\n2. 组合 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-77/\n3. 全排列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-46/\n4. 子集 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-90/\n5. 组合总和 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-40/\n6. 全排列 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-47/\n7. 组合总和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-39/\n岛屿问题 解法 利用dfs的思想，遍历矩阵，如果碰到陆地就从这个元素开始dfs，同时将陆地全部变为海水，同时统计岛屿的个数\n详见：https://labuladong.gitee.io/algo/4/31/107/\n题目 1. 岛屿数量 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-200/\n2. 统计封闭岛屿的数目 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1254/\n3. 飞地的数量 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1020/\n4. 岛屿的最大面积 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-695/\n5. 统计子岛屿 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1905/\n6. 不同岛屿的数量 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-694/\n数独问题 解法 经典回溯问题，暴力求解即可\n题目 1. 解数独 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-37/\n括号生成 解法 经典回溯问题，穷举所有可能并且对不合理的情况剪枝即可\n题目 1. 括号生成 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-22/\nBFS BFS基本问题 解法 套模板即可，详见思想篇章\n题目 1. 二叉树的最小深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-111/\n2. 打开转盘锁 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-752/\nDFS DFS基本问题 解法 详见题解\n题目 1. 删除无效的括号 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-301/\n数学问题 随机算法 解法 有洗牌算法和蓄水池抽样算法两种，详见思想篇章\n题目 1. 打乱数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-384/\n2. 链表随机节点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-382/\n3. 随机数索引 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-398/\n位运算 解法 就那几个技巧，详见思想篇章\n题目 1. 位 1 的个数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-191/\n2. 2 的幂 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-231/\n3. 只出现一次的数字 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-136/\n4. 丢失的数字 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-268/\n阶乘后的零 解法 其实求阶乘结果有几个零就是求阶乘式子里可以分解出来几个因数5，其实就是n/5 + n/25 + n/125 + \u0026hellip;.\n题目 1. 阶乘后的零 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-172/\n2. 阶乘函数后 K 个零 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-793/\n素数筛选法 解法 详见思想篇章\n题目 1. 计数质数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-204/\n模幂运算 解法 详见思想篇章\n题目 1. 超级次方 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-372/\n经典面试题 分治算法 解法 通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。\n题目 1. 为运算表达式设计优先级 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-241/\n分割数组为连续子序列 解法 详见题解\n题目 1. 分割数组为连续子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-659/\n大整数乘法 解法 详见题解\n题目 1. 字符串相乘 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-43/\n实现计算器 解法 根本思想是建立一个栈，栈里存放目前遍历到的数字，比如1-2+3，栈里存放1、-2、3，最后将栈里的数字相加即可，详见：https://labuladong.gitee.io/algo/4/33/127/\n题目 1. 基本计算器 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-224/\n2. 基本计算器 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-227/\n括号相关问题 解法 详见题解\n题目 1. 有效的括号 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-20/\n2. 使括号有效的最少添加 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-921/\n3. 平衡括号字符串的最少插入次数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1541/\n区间问题 解法 区间类问题看起来都比较复杂，情况很多难以处理，但实际上通过观察各种不同情况之间的共性可以发现规律，用简洁的代码就能处理。\n题目 1. 删除被覆盖区间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1288/\n2. 合并区间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-56/\n3. 区间列表的交集 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-986/\n接雨水 解法 详见题解\n题目 1. 接雨水 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-42/\n2. 盛最多水的容器 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-11/\n完美矩形 解法 详见题解\n题目 1. 完美矩形 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-391/\n二分查找高效判定子序列 解法 详见题解\n题目 1. 判断子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-392/\n2. 匹配子序列的单词数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-792/\n思想 动态规划 动态规划问题有两个重要的特点，分别是最优子结构性质和存在重叠子问题，只要满足这两个条件都可以用动态规划\n流程 明确状态方程y = f(x)的定义\n确定「状态」，就是能描述一个问题局面所需的变量，也是原问题和子问题中会变化的变量。即y = f(x)中的x 确定y = f(x)中的y，一般是问题要求我们计算的量 确定「选择」，也就是导致「状态」产生变化的行为。即状态转移方程里的x应该选择哪一个 确定base case 写出状态转移方程（列出状态转移方程，就是在解决“如何穷举”的问题。），这个过程就是判断问题是否具有最优子结构性质（就是能否通过子问题的最优解求出原问题的最优解），此时可以通过状态转移方程写出递归写法，递归写法就是自顶向下的解法，但是这种写法一般存在重叠子问题\n判断问题是否具有重叠子问题，如果有，使用DP table代替f(x)函数，同时将递归改成迭代（也就是自底向上），DP table起到了记录子问题的作用，DP table 就是在追求“如何聪明地穷举”\n优化空间复杂度，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度\n精简流程 构造一个dp数组，确定数组的索引是什么含义 确定dp数组里面放什么 dp数组里的元素怎么根据前面元素推出来（即状态转移方程） base case 优化空间复杂度 注意点 动态规划的核心问题是“如何穷举”（状态转移方程），然后考虑“如何聪明地穷举”（消除重叠子问题、剪枝） 算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举” 递归是自顶向下，dp table迭代是自底向上 dp数组的大小有时候要比原问题大一点，目的是防止特殊判断和dummy node的原理类似 dp 数组的遍历方向只要保证两点即可 遍历的过程中，所需的状态必须是已经计算出来的 遍历结束后，存储结果的那个位置必须已经被计算出来 经典问题 子序列问题 一般y = f(x)的x都是数组的索引，y是以这个索引对应的元素结尾的最长\u0026hellip;子序列或者数组[0\u0026hellip;x]的最长\u0026hellip;子序列，两个数组同理，只不过是二维的\n如果是两个字符串，求最长\u0026hellip;子序列，一个常用的思路就是根据每两个字符是否相同来判断他们是否在结果子序列中，从而避免了对所有子序列进行穷举。\n记住一个思想s1[i]和s2[j]不相等时，不可能同时出现在最长\u0026hellip;子序列中，因为对于当前的子问题来说，s1[i]和s2[j]是字符串的最后一个字符\n一般有两种思路，第一种思路模板是一个一维的 dp 数组：\nint n = array.length; int[] dp = new int[n]; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { dp[i] = 最值(dp[i], dp[j] + ...) } } 第二种思路模板是一个二维的 dp 数组：\nint n = arr.length; int[][] dp = new dp[n][n]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (arr[i] == arr[j]) dp[i][j] = dp[i][j] + ... else dp[i][j] = 最值(...) } } 背包问题 0-1背包问题 构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。base case是第一行和第一列取值为0，可以优化空间复杂度，模板如下：\nint knapsack(int W, int N, int[] wt, int[] val) { assert N == wt.length; // base case 已初始化 int[][] dp = new int[N + 1][W + 1]; for (int i = 1; i \u0026lt;= N; i++) { for (int w = 1; w \u0026lt;= W; w++) { if (w - wt[i - 1] \u0026lt; 0) { // 这种情况下只能选择不装入背包 dp[i][w] = dp[i - 1][w]; } else { // 装入或者不装入背包，择优 dp[i][w] = Math.max( dp[i - 1][w - wt[i-1]] + val[i-1], dp[i - 1][w] ); } } } return dp[N][W]; } 详见：https://labuladong.gitee.io/algo/3/27/81/\n子集背包问题 子集背包问题就是子集划分问题，就是给定一个数组和一个数字，让求数组里有几种子集和为该数字\n与0-1背包问题相似，就是问题不是该背包最多能装多少东西，而是被刚好装满有几种方式\n构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下 dp[i][w]表示被刚好装满有几种方式。base case是dp[0][0]=1（第一列不能都为0，因为数组里可能有0），可以优化空间复杂度，但是要注意j需要倒着遍历\n模板如下：\n/* 计算 nums 中有几个子集的和为 sum */ int subsets(int[] nums, int sum) { int n = nums.length; int[][] dp = new int[n + 1][sum + 1]; // base case dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= sum; j++) { if (j \u0026gt;= nums[i-1]) { // 两种选择的结果之和 dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]; } else { // 背包的空间不足，只能选择不装物品 i dp[i][j] = dp[i-1][j]; } } } return dp[n][sum]; } 详见：https://labuladong.gitee.io/algo/3/27/82/\n完全背包问题 与0-1背包问题相似，构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，可以重复选择第i个物品，这种情况下正好将背包装满的方式有 dp[i][w] 种。base case是第一列取值为1，可以优化空间复杂度，模板如下：\nint change(int amount, int[] coins) { int n = coins.length; int[][] dp = int[n + 1][amount + 1]; // base case for (int i = 0; i \u0026lt;= n; i++) dp[i][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= amount; j++) if (j - coins[i-1] \u0026gt;= 0) dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i-1]]; else dp[i][j] = dp[i - 1][j]; } return dp[n][amount]; } 详见：https://labuladong.gitee.io/algo/3/27/83/\nKMP算法 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/97/\n其中状态机的影子X比较难理解，其实就是对于一个自动机，s[0\u0026hellip;i]输入之后会走到j这个状态，X就是s[1\u0026hellip;i]输入自动机之后走到的状态（所以X = dp[X][pat.charAt(j)];，j从1开始），也就是s[0\u0026hellip;i]不匹配之后应该走到的状态（因为s[0\u0026hellip;i]不匹配，那肯定重新从s[1\u0026hellip;i]开始匹配），也就是j这个状态不匹配时应该回到X这个状态，所以有当pat.charAt(j) != c时dp[j][c] = dp[X][c];，还要注意该自动机是一边生成一边推进j和X的（其实就是动态规划），而不是先生成好自动机，再进行匹配，而且j用到了X（不匹配的时候），X也用到了j（因为X在j的后面，j走过的路自动机已经生成好了），就是下面这张图：\n模板如下：\npublic class KMP { private int[][] dp; private String pat; public KMP(String pat) { this.pat = pat; int M = pat.length(); // dp[状态][字符] = 下个状态 dp = new int[M][256]; // base case dp[0][pat.charAt(0)] = 1; // 影子状态 X 初始为 0 int X = 0; // 构建状态转移图（稍改的更紧凑了） for (int j = 1; j \u0026lt; M; j++) { for (int c = 0; c \u0026lt; 256; c++) dp[j][c] = dp[X][c]; dp[j][pat.charAt(j)] = j + 1; // 更新影子状态 X = dp[X][pat.charAt(j)]; } } public int search(String txt) { int M = pat.length(); int N = txt.length(); // pat 的初始态为 0 int j = 0; for (int i = 0; i \u0026lt; N; i++) { // 计算 pat 的下一个状态 j = dp[j][txt.charAt(i)]; // 到达终止态，返回结果 if (j == M) return i - M + 1; } // 没到达终止态，匹配失败 return -1; } } 贪心算法 贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。\n什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。\n贪心算法题目，大多一眼就能看出来，大不了就先用动态规划求解，如果动态规划都超时，说明该问题存在贪心选择性质无疑了。\n回溯 回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」\n废话不多说，直接上回溯算法框架，解决一个回溯问题，实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，你只需要思考 3 个问题：\n1、路径：也就是已经做出的选择。\n2、选择列表：也就是你当前可以做的选择。\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。（注意结束条件不只有满足条件的情况，也要考虑不满足条件的情况，到决策树底层就得结束）\n模板 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: # 做选择 将该选择从选择列表移除 路径.add(选择) backtrack(路径, 选择列表) # 撤销选择 路径.remove(选择) 将该选择再加入选择列表 思考回溯问题时，一定要把递归过程想成一棵树，不同的选择就是不同的分支，backtrack函数开头就是进入一个结点时要做什么，一般都是判断是否应该进入这个结点（其实就是剪枝）和当前结点是否满足结束条件，其实仔细想想，只要是牵扯到递归的都可以想象成一棵树（因为考虑问题比较方便），比如dfs，回溯，等等\n其实想想看，回溯算法和动态规划是不是有点像呢？动态规划的三个需要明确的点就是「状态」「选择」和「base case」，正好就对应着走过的「路径」，当前的「选择列表」和「结束条件」\n注意：\n带备忘录的回溯就叫做记忆化回溯，记忆化回溯就相当于动态规划，因为记忆化回溯消除了重叠子问题，消除了重叠子问题就相当于动态规划了\n排列组合子集问题 由于子集问题和组合问题本质上是一样的，无非就是 base case 有一些区别，所以把这两个问题放在一起看。\n形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，backtrack 核心代码如下：\n/* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i \u0026lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.removeLast(); } } /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { // 剪枝逻辑 if (used[i]) { continue; } // 做选择 used[i] = true; track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); used[i] = false; } } 形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝，backtrack 核心代码如下：\nArrays.sort(nums); /* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i \u0026lt; nums.length; i++) { // 剪枝逻辑，跳过值相同的相邻树枝 if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.removeLast(); } } Arrays.sort(nums); /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { // 剪枝逻辑 if (used[i]) { continue; } // 剪枝逻辑，固定相同的元素在排列中的相对位置 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } // 做选择 used[i] = true; track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); used[i] = false; } } 形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可，backtrack 核心代码如下：\n/* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i \u0026lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i); // 撤销选择 track.removeLast(); } } /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); } } 详见：https://labuladong.gitee.io/algo/4/31/106/\nBFS 即广度优先搜索，不多说了，模板如下：\n// 计算从起点 start 到终点 target 的最近距离 int BFS(Node start, Node target) { Queue\u0026lt;Node\u0026gt; q; // 核心数据结构 Set\u0026lt;Node\u0026gt; visited; // 避免走回头路 q.offer(start); // 将起点加入队列 visited.add(start); int step = 0; // 记录扩散的步数 while (q not empty) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i \u0026lt; sz; i++) { Node cur = q.poll(); /* 划重点：这里判断是否到达终点 */ if (cur is target) return step; /* 将 cur 的相邻节点加入队列 */ for (Node x : cur.adj()) { if (x not in visited) { q.offer(x); visited.add(x); } } } /* 划重点：更新步数在这里 */ step++; } } 队列 q 就不说了，BFS 的核心数据结构；cur.adj() 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；visited 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。\n流程如下所示：\n数学 随机算法 洗牌算法 一般解决随机打乱一个数组问题，算法如下：\npublic int[] shuffle(int[] nums) { int n = nums.length; for (int i = 0 ; i \u0026lt; n; i++) { // 生成一个 [i, n-1] 区间内的随机数 int r = i + rand.nextInt(n - i); // 交换 nums[i] 和 nums[r] swap(nums, i, r); } return copy; } 蓄水池抽样算法 可以解决在一堆数据中随机取出一个或多个数据，算法如下：\n/* 返回链表中一个随机节点的值 */ int getRandom(ListNode head) { Random r = new Random(); int i = 0, res = 0; ListNode p = head; // while 循环遍历链表 while (p != null) { i++; // 生成一个 [0, i) 之间的整数 // 这个整数等于 0 的概率就是 1/i if (0 == r.nextInt(i)) { res = p.val; } p = p.next; } return res; } 证明如下：\n取出k个元素：\n/* 返回链表中 k 个随机节点的值 */ int[] getRandom(ListNode head, int k) { Random r = new Random(); int[] res = new int[k]; ListNode p = head; // 前 k 个元素先默认选上 for (int i = 0; i \u0026lt; k \u0026amp;\u0026amp; p != null; i++) { res[i] = p.val; p = p.next; } int i = k; // while 循环遍历链表 while (p != null) { i++; // 生成一个 [0, i) 之间的整数 int j = r.nextInt(i); // 这个整数小于 k 的概率就是 k/i if (j \u0026lt; k) { res[j] = p.val; } p = p.next; } return res; } 证明如下：\n详见：https://labuladong.gitee.io/algo/4/32/113/\n位运算 判断两个数是否异号 int x = -1, y = 2; boolean f = ((x ^ y) \u0026lt; 0); // true int x = 3, y = 2; boolean f = ((x ^ y) \u0026lt; 0); // false n \u0026amp; (n-1) 的运用 消除数字 n 的二进制表示中的最后一个 1，即Brian Kernighan算法\na ^ a = 0 的运用 一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。而且异或运算满足交换律和结合律\n素数筛选法 求[2\u0026hellip;n]之间的所有的素数可以这样求，从2开始遍历，遍历到的数字的整数倍一定不是素数，这样排除遍历到n的时候，没被排除的就是[2\u0026hellip;n]的素数，模板如下：\nint countPrimes(int n) { boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); for (int i = 2; i * i \u0026lt; n; i++) if (isPrime[i]) for (int j = i * i; j \u0026lt; n; j += i) isPrime[j] = false; int count = 0; for (int i = 2; i \u0026lt; n; i++) if (isPrime[i]) count++; return count; } 这里优化了两个地方，详见：https://labuladong.gitee.io/algo/4/32/116/\n模幂运算 模幂运算就是求a^b%k，就是对幂取模，所以叫模幂运算\n(a * b) % k = ((a % k) * (b % k)) % k，当a*b会溢出时可以用这个技巧，可以拓展到多个数相乘然后取余，只不过要记得每个乘法都要做一次这个运算，比如(a * b * c) % k -\u0026gt; (((a % k) * (b % k)) % k) * c = (((a % k) * (b % k)) % k) * (c % k) % k，只要做乘法就要取模\n模板 int base = 1337; // 计算 a 的 k 次方然后与 base 求模的结果 int mypow(int a, int k) { // 对因子求模 a %= base; int res = 1; for (int _ = 0; _ \u0026lt; k; _++) { // 这里有乘法，是潜在的溢出点 res *= a; // 对乘法结果求模 res %= base; } return res; } 如何高效求幂？\n利用幂运算的性质，我们可以写出这样一个递归式：\n这样就不用傻乎乎的从第一个乘到最后一个了\n模板 int mypow(int a, int k, int MOD) { if (k == 0) return 1; a %= MOD; if (k % 2 == 1) { // k 是奇数 return (int) (((long)a * mypow(a, k - 1, MOD)) % MOD); } else { // k 是偶数 int sub = mypow(a, k / 2, MOD); return (int) (((long)sub * sub) % MOD); } // 还有一种迭代的写法 // int res = 1; // while(k != 0) { // if (k \u0026amp; 1 == 1) { // res = ((long)res * a) % MOD; // } // k /= 2; // a = ((long)a * a) % MOD; // } // return res; } 求组合数 模板如下：\npublic int combination(int m, int n) { long res = 1; for (int i = n - m + 1, j = 1; j \u0026lt;= m; i++, j++) { res = res * i / j; } return (int) res; } 注意i必须从n - m + 1开始乘，因为从n开始乘会溢出\n零碎 四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。详见：https://leetcode.cn/problems/perfect-squares/solutions/822940/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/ 分治算法 分治算法可以认为是一种算法思想，通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。\n与动态规划和回溯类似，都是通过子问题的解推出来的原问题的解\n详见：https://labuladong.gitee.io/algo/4/33/122/\n自动机 就是根据不同的输入进入不同的状态\n模板 class Solution { public int myAtoi(String s) { Automaton automaton = new Automaton(); for (char c : s.toCharArray()) { automaton.get(c); } return (int) (automaton.sign * automaton.res); } class Automaton { int sign = 1; long res = 0; String state = \u0026#34;start\u0026#34;; Map\u0026lt;String, String[]\u0026gt; table = new HashMap\u0026lt;\u0026gt;() { { put(\u0026#34;start\u0026#34;, new String[]{\u0026#34;start\u0026#34;, \u0026#34;signed\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;signed\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;in_number\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;in_number\u0026#34;, \u0026#34;end\u0026#34;}); put(\u0026#34;end\u0026#34;, new String[]{\u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;end\u0026#34;}); } }; public void get(char c) { state = table.get(state)[getCol(c)]; if (state == \u0026#34;in_number\u0026#34;) { res = res * 10 + c - \u0026#39;0\u0026#39;; res = sign == 1 ? Math.min(res, Integer.MAX_VALUE) : Math.min(res, -(long) Integer.MIN_VALUE); } else if (state == \u0026#34;signed\u0026#34;) { sign = c == \u0026#39;+\u0026#39; ? 1 : -1; } } private int getCol(char c) { if (c == \u0026#39; \u0026#39;) { return 0; } if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) { return 1; } if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return 2; } return 3; } } } 这是力扣第8题的答案\n其他 零碎 二分查找的左侧边界的定义就是该边界及该边界右边的元素都大于等于查找元素，右侧边界的定义就是该边界及该边界左边的元素都小于等于查找元素\n向上取整可以用(val + 2) / 3，即(val + n - 1) / n\n字符串比较大小 比如ABC与ACDE比较，第一个字符相同，继续比较第二个字符，由于第二个字符是后面一个串大，所以不再继续比较，结果就是后面个串大。再如ABC与ABC123比较，比较三个字符后第一个串结束，所以就是后面一个串大，可以认为一个字符串到头了那这个字符串当前比较的字符就是最小的（因为这个字符都不存在）\n待做 LinkedHashMap是什么\nhttps://labuladong.gitee.io/algo/3/28/88/没看\nhttps://labuladong.gitee.io/algo/3/28/89/没看\nhttps://labuladong.gitee.io/algo/3/28/93/没看\nhttps://labuladong.gitee.io/algo/3/28/94/没看\nhttps://labuladong.gitee.io/algo/3/28/91/没看\nhttps://labuladong.gitee.io/algo/3/28/92/没看\nhttps://labuladong.gitee.io/algo/4/31/111/没看\nhttps://labuladong.gitee.io/algo/4/32/118/没看\nhttps://labuladong.gitee.io/algo/4/33/125/没看\nhttps://labuladong.gitee.io/algo/4/33/131/没看\n山谷(Valley)问题是什么（二分查找）\n技巧 学习方法 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-2/","summary":"动态规划基本问题 解法 经典动态规划问题，详见思想篇章 题目 1. 斐波那契数 题解详见：https://blog.zhangmengyang.tk/po","title":"LeetCode Note 2"},{"content":"思路 经典动态规划问题，具有最优子结构性质，“状态”为金额，“选择”为硬币的面值，dp数组定义为dp[金额] = 取得该金额需要的最少硬币，”basecase“为dp[0] = 0，状态转移方程如下：\n直接递归存在重复子问题，所以用dp数组迭代方式\n代码 class Solution { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for(int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i - coin \u0026lt; 0) { continue; } dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] == amount + 1 ? -1 : dp[amount]; } } References 1. 零钱兑换 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-322/","summary":"思路 经典动态规划问题，具有最优子结构性质，“状态”为金额，“选择”为硬币的面值，dp数组定义为dp[金额] = 取得该金额需要的最少硬币，”ba","title":"LeetCode 322"},{"content":"思路 状态转移方程很简单，注意一下直接递归会有重复子问题，所以可以使用数组备份一下（其实就是dp数组），又发现只会用到每个元素的前两个元素，所以可以把数组换成前两个元素\n代码 class Solution { public int fib(int n) { if (n == 0 || n == 1) { return n; } int dp_i_1 = 0, dp_i_2 = 1; for (int i = 2; i \u0026lt;= n; i++) { int dp_i_3 = dp_i_1 + dp_i_2; dp_i_1 = dp_i_2; dp_i_2 = dp_i_3; } return dp_i_2; } } References 1. 斐波那契数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-509/","summary":"思路 状态转移方程很简单，注意一下直接递归会有重复子问题，所以可以使用数组备份一下（其实就是dp数组），又发现只会用到每个元素的前两个元素，所","title":"LeetCode 509"},{"content":"思路 直接套用队列实现栈的模板即可，详见思想篇章\n代码 class MyStack { private Queue\u0026lt;Integer\u0026gt; q; private int topElem; public MyStack() { q = new LinkedList\u0026lt;\u0026gt;(); } public void push(int x) { q.offer(x); topElem = x; } public int pop() { int size = q.size(); while (size \u0026gt; 2) { q.offer(q.poll()); size--; } topElem = q.peek(); q.offer(q.poll()); return q.poll(); } public int top() { return topElem; } public boolean empty() { return q.isEmpty(); } } References 1. 用队列实现栈 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-225/","summary":"思路 直接套用队列实现栈的模板即可，详见思想篇章 代码 class MyStack { private Queue\u0026lt;Integer\u0026gt; q; private int topElem; public MyStack() { q = new LinkedList\u0026lt;\u0026gt;(); } public void push(int x) { q.offer(x); topElem = x; } public int pop() { int size = q.size(); while (size \u0026gt; 2) { q.offer(q.poll()); size--; } topElem =","title":"LeetCode 225"},{"content":"思路 直接套栈实现队列模板即可，详见思想篇章\n代码 class MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { s2.push(x); } public int pop() { peek(); return s1.pop(); } public int peek() { if (s1.isEmpty()) { while (!s2.isEmpty()) { s1.push(s2.pop()); } } return s1.peek(); } public boolean empty() { return s1.isEmpty() \u0026amp;\u0026amp; s2.isEmpty(); } } References 1. 用栈实现队列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-232/","summary":"思路 直接套栈实现队列模板即可，详见思想篇章 代码 class MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { s2.push(x); } public int pop() { peek(); return s1.pop(); } public int peek() { if (s1.isEmpty()) { while (!s2.isEmpty()) { s1.push(s2.pop()); } }","title":"LeetCode 232"},{"content":"思路 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色），详见思想篇章\n代码 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); MonotonicQueue window = new MonotonicQueue(); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026lt; k - 1) { window.push(nums[i]); } else { window.push(nums[i]); res.add(window.max()); window.poll(nums[i - k + 1]); } } int[] arr = new int[res.size()]; for (int i = 0; i \u0026lt; res.size(); i++) { arr[i] = res.get(i); } return arr; } class MonotonicQueue { LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); private void push(int n) { while (!queue.isEmpty() \u0026amp;\u0026amp; queue.getLast() \u0026lt; n) { queue.pollLast(); } queue.addLast(n); } private void poll(int n) { if (n == queue.getFirst()) { queue.pollFirst(); } } private int max() { return queue.getFirst(); } } } References 1. 滑动窗口最大值 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-239/","summary":"思路 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色","title":"LeetCode 239"},{"content":"思路 利用单调栈的思想，同LeetCode-496，只不过牵扯到循环数组的问题，常用套路就是将数组长度翻倍，代码实现的时候也可以用i % nums.length来模拟数组长度翻倍\n代码 class Solution { public int[] nextGreaterElements(int[] nums) { int n = nums.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i = 2 * n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026lt;= nums[i % n]) { stack.pop(); } res[i % n] = stack.isEmpty() ? -1 : stack.peek(); stack.push(nums[i % n]); } return res; } } References 1. 下一个更大元素 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-503/","summary":"思路 利用单调栈的思想，同LeetCode-496，只不过牵扯到循环数组的问题，常用套路就是将数组长度翻倍，代码实现的时候也可以用i % nums","title":"LeetCode 503"},{"content":"思路 利用单调栈的思想即可，同LeetCode-496，只不过这次存的是索引而不是元素\n代码 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i = n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt;= temperatures[i]) { stack.pop(); } res[i] = stack.isEmpty() ? 0 : (stack.peek() - i); stack.push(i); } return res; } } References 1. 每日温度 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-739/","summary":"思路 利用单调栈的思想即可，同LeetCode-496，只不过这次存的是索引而不是元素 代码 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i =","title":"LeetCode 739"},{"content":"思路 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充当下一个更大元素的角色（中间去除的元素是无法充当这种角色的），那么此时栈顶就是当前元素下一个更大元素\n代码 class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int n = nums2.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; res = new HashMap\u0026lt;\u0026gt;(); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026lt;= nums2[i]) { stack.pop(); } res.put(nums2[i], stack.isEmpty() ? -1 : stack.peek()); stack.push(nums2[i]); } for (int i = 0; i \u0026lt; nums1.length; i++) { nums1[i] = res.get(nums1[i]); } return nums1; } } References 1. 下一个更大元素 I ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-496/","summary":"思路 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充","title":"LeetCode 496"},{"content":"思路 经典TrieMap问题，不解释\n代码 class MapSum { private TrieMap\u0026lt;Integer\u0026gt; trieMap; public MapSum() { this.trieMap = new TrieMap(); } public void insert(String key, int val) { trieMap.put(key, val); } public int sum(String prefix) { List\u0026lt;String\u0026gt; keys = trieMap.keysWithPrefix(prefix); int res = 0; for (String key : keys) { res += trieMap.get(key); } return res; } class TrieMap { /* 见思想篇章 */ } } References 1. 键值映射 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-677/","summary":"思路 经典TrieMap问题，不解释 代码 class MapSum { private TrieMap\u0026lt;Integer\u0026gt; trieMap; public MapSum() { this.trieMap = new TrieMap(); } public void insert(String key, int val) { trieMap.put(key, val); } public int sum(String prefix) { List\u0026lt;String\u0026gt; keys = trieMap.keysWithPrefix(prefix); int res = 0; for (String key : keys) { res += trieMap.get(key); } return res; } class","title":"LeetCode 677"},{"content":"思路 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg\n代码 class MedianFinder { private Queue\u0026lt;Integer\u0026gt; small; private Queue\u0026lt;Integer\u0026gt; large; public MedianFinder() { small = new PriorityQueue\u0026lt;\u0026gt;(); large = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b - a; }); } public void addNum(int num) { if (small.size() \u0026gt; large.size()) { small.offer(num); large.offer(small.poll()); } else { large.offer(num); small.offer(large.poll()); } } public double findMedian() { if (small.size() \u0026gt; large.size()) { return small.peek(); } else if (small.size() \u0026lt; large.size()) { return large.peek(); } else { return (small.peek() + large.peek()) / 2.0; } } } References 1. 数据流的中位数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-295/","summary":"思路 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：h","title":"LeetCode 295"},{"content":"思路 利用Trie树的思想即可，详见思想篇章\n代码 class WordDictionary { private TrieNode root; private static class TrieNode { boolean isEnd = false; TrieNode[] children = new TrieNode[26]; } public WordDictionary() { this.root = new TrieNode(); } public void addWord(String word) { this.root = put(root, word, 0); } private TrieNode put(TrieNode node, String word, int i) { if (node == null) { node = new TrieNode(); } if (i == word.length()) { node.isEnd = true; return node; } int c = word.charAt(i) - \u0026#39;a\u0026#39;; node.children[c] = put(node.children[c], word, i + 1); return node; } public boolean search(String word) { return hasKeyWithPattern(root, word, 0); } private boolean hasKeyWithPattern(TrieNode node, String word, int i) { if (node == null) { return false; } if (i == word.length()) { return node.isEnd; } char c = word.charAt(i); if (c != \u0026#39;.\u0026#39;) { return hasKeyWithPattern(node.children[c - \u0026#39;a\u0026#39;], word, i + 1); } for (int j = 0; j \u0026lt; 26; j++) { if (hasKeyWithPattern(node.children[j], word, i + 1)) { return true; } } return false; } } References 1. 添加与搜索单词 - 数据结构设计 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-211/","summary":"思路 利用Trie树的思想即可，详见思想篇章 代码 class WordDictionary { private TrieNode root; private static class TrieNode { boolean isEnd = false; TrieNode[] children = new TrieNode[26]; } public WordDictionary() { this.root = new TrieNode(); } public void addWord(String word) { this.root = put(root, word, 0); } private TrieNode put(TrieNode node, String word, int","title":"LeetCode 211"},{"content":"思路 经典前缀树（Trie）问题，只不过需要注意将dictionary添加进set即可（因为只添加进set的字符串才能充当前缀）\n代码 class Solution { public String replaceWords(List\u0026lt;String\u0026gt; dictionary, String sentence) { TrieSet trieSet = new TrieSet(); for (String key : dictionary) { trieSet.add(key); } String[] words = sentence.split(\u0026#34; \u0026#34;); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; words.length; i++) { String word = words[i]; String prefix = trieSet.shortestPrefixOf(word); if (prefix.isEmpty()) { sb.append(word); } else { sb.append(prefix); } if (i != words.length - 1) { sb.append(\u0026#34; \u0026#34;); } } return sb.toString(); } class TrieSet { /* 见思想篇章 */ } class TrieMap { /* 见思想篇章 */ } } References 1. 单词替换 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-648/","summary":"思路 经典前缀树（Trie）问题，只不过需要注意将dictionary添加进set即可（因为只添加进set的字符串才能充当前缀） 代码 class Solution { public String","title":"LeetCode 648"},{"content":"思路 经典前缀树（Trie）问题，直接套模板即可，详见思想篇章\n代码 class Trie { private TrieSet trieSet; public Trie() { this.trieSet = new TrieSet(); } public void insert(String word) { trieSet.add(word); } public boolean search(String word) { return trieSet.contains(word); } public boolean startsWith(String prefix) { return trieSet.hasKeyWithPrefix(prefix); } class TrieSet { /* 见思想篇章 */ } class TrieMap { /* 见思想篇章 */ } } References 1. 实现 Trie (前缀树) ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-208/","summary":"思路 经典前缀树（Trie）问题，直接套模板即可，详见思想篇章 代码 class Trie { private TrieSet trieSet; public Trie() { this.trieSet = new TrieSet(); } public void insert(String word) { trieSet.add(word); } public boolean search(String word) { return trieSet.contains(word); } public boolean startsWith(String prefix) { return trieSet.hasKeyWithPrefix(prefix); } class","title":"LeetCode 208"},{"content":"思路 两种做法：\n手写LinkedHashMap 经典LRU缓存问题，直接套LRU模板即可，详见思想篇章\n用Java自带的LinkedHashMap 直接看代码，一般面试的时候不让用LinkedHashMap\n代码 手写轮子 class LRUCache { private Map\u0026lt;Integer, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private DoubleList cache = new DoubleList(); private int capacity; public LRUCache(int capacity) { this.capacity = capacity; } public int get(int key) { if (!map.containsKey(key)) { return -1; } makeRecently(key); return map.get(key).val; } public void put(int key, int value) { if (map.containsKey(key)) { deleteKey(key); addRecently(key, value); return; } if (cache.size() == capacity) { removeLeastRecently(); } addRecently(key, value); } private void makeRecently(int key) { Node x = map.get(key); cache.remove(x); cache.addLast(x); } private void addRecently(int key, int val) { Node x = new Node(key, val); cache.addLast(x); map.put(key, x); } private void deleteKey(int key) { Node x = map.get(key); cache.remove(x); map.remove(key); } private void removeLeastRecently() { Node x = cache.removeFirst(); map.remove(x.key); } class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class DoubleList { private Node head, tail; private int size; public DoubleList() { this.head = new Node(0, 0); this.tail = new Node(0, 0); head.next = tail; tail.prev = head; size = 0; } public void addLast(Node x) { x.next = tail; x.prev = tail.prev; tail.prev.next = x; tail.prev = x; size++; } public void remove(Node x) { x.prev.next = x.next; x.next.prev = x.prev; size--; } public Node removeFirst() { if (size == 0) { return null; } Node first = head.next; remove(first); return first; } public int size() { return size; } } } 重用LinkedHashMap 手动控制访问顺序 class LRUCache { int cap; LinkedHashMap\u0026lt;Integer, Integer\u0026gt; cache = new LinkedHashMap\u0026lt;\u0026gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() \u0026gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); } } 自动控制访问顺序 class LRUCache extends LinkedHashMap\u0026lt;Integer, Integer\u0026gt;{ private int capacity; public LRUCache(int capacity) { super(capacity, 0.75F, true); this.capacity = capacity; } public int get(int key) { return super.getOrDefault(key, -1); } public void put(int key, int value) { super.put(key, value); } @Override protected boolean removeEldestEntry(Map.Entry\u0026lt;Integer, Integer\u0026gt; eldest) { return size() \u0026gt; capacity; } } References 1. LRU 缓存 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-146/","summary":"思路 两种做法： 手写LinkedHashMap 经典LRU缓存问题，直接套LRU模板即可，详见思想篇章 用Java自带的LinkedHashMap","title":"LeetCode 146"},{"content":"思路 经典LFU缓存问题，直接套LFU模板即可，详见思想篇章\n代码 class LFUCache { private Map\u0026lt;Integer, Integer\u0026gt; keyToVal; private Map\u0026lt;Integer, Integer\u0026gt; keyToFreq; private Map\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; private int minFreq; private int capacity; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.capacity = capacity; this.minFreq = 0; } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } increaseFreq(key); return keyToVal.get(key); } public void put(int key, int value) { if (this.capacity == 0) { return; } if (keyToVal.containsKey(key)) { keyToVal.put(key, value); increaseFreq(key); return; } if (keyToVal.size() == this.capacity) { removeMinFreqKey(); } keyToVal.put(key, value); keyToFreq.put(key, 1); freqToKeys.putIfAbsent(1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(1).add(key); this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); keyToFreq.put(key, freq + 1); freqToKeys.get(freq).remove(key); freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(freq + 1).add(key); if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); if (this.minFreq == freq) { this.minFreq++; } } } private void removeMinFreqKey() { LinkedHashSet\u0026lt;Integer\u0026gt; keyList = freqToKeys.get(this.minFreq); int deleteKey = keyList.iterator().next(); keyList.remove(deleteKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 这里不用修改minFreq因为后面会置为1 } keyToVal.remove(deleteKey); keyToFreq.remove(deleteKey); } } References 1. LFU 缓存 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-460/","summary":"思路 经典LFU缓存问题，直接套LFU模板即可，详见思想篇章 代码 class LFUCache { private Map\u0026lt;Integer, Integer\u0026gt; keyToVal; private Map\u0026lt;Integer, Integer\u0026gt; keyToFreq; private Map\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; private int minFreq; private int capacity; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.capacity =","title":"LeetCode 460"},{"content":"思路 两种思路：\nkruskal 利用kruskal算法即可，只不过这里的边需要自己生成，详见思想章节\nprim 利用prim算法即可，只不过这里的边需要自己生成，详见思想章节\n代码 kruskal class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; List\u0026lt;int[]\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { int xi = points[i][0], yi = points[i][1]; int xj = points[j][0], yj = points[j][1]; edges.add(new int[]{i, j, Math.abs(xi - xj) + Math.abs(yi- yj)}); } } Collections.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UF uf = new UF(n); int mst = 0; for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (uf.connected(u, v)) { continue; } mst += weight; uf.union(u, v); } return mst; } class UF { // 连通分量个数 private int count; // 存储每个节点的父节点 private int[] parent; // n 为图中节点的个数 public UF(int n) { this.count = n; parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } // 将节点 p 和节点 q 连通 public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootQ] = rootP; // 两个连通分量合并成一个连通分量 count--; } // 判断节点 p 和节点 q 是否连通 public boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } // 返回图中的连通分量个数 public int count() { return count; } } } prim class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; List\u0026lt;int[]\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { int xi = points[i][0], yi = points[i][1]; int xj = points[j][0], yj = points[j][1]; int weight = Math.abs(xi - xj) + Math.abs(yi- yj); graph[i].add(new int[]{i, j, weight}); graph[j].add(new int[]{j, i, weight}); } } return new Prim(graph).getWeightSum(); } class Prim { private List\u0026lt;int[]\u0026gt;[] graph; private Queue\u0026lt;int[]\u0026gt; pq; private boolean[] inMST; private int weightSum = 0; public Prim(List\u0026lt;int[]\u0026gt;[] graph) { this.graph = graph; this.pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a[2] - b[2]; }); int n = graph.length; inMST = new boolean[n]; inMST[0] = true; cut(0); while (!pq.isEmpty()) { int[] edge = pq.poll(); int to = edge[1]; int weight = edge[2]; if (inMST[to]) { continue; } weightSum += weight; inMST[to] = true; cut(to); } } private void cut(int s) { for (int[] edge : graph[s]) { int to = edge[1]; if (inMST[to]) { continue; } pq.offer(edge); } } private int getWeightSum() { return weightSum; } private boolean allConnected() { for (boolean b : inMST) { if (!b) { return false; } } return true; } } } References 1. 连接所有点的最小费用 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1584/","summary":"思路 两种思路： kruskal 利用kruskal算法即可，只不过这里的边需要自己生成，详见思想章节 prim 利用prim算法即可，只不过这里的边需要自己生成，详见","title":"LeetCode 1584"},{"content":"思路 dijkstra问题的变种，利用dijkstra模板即可，主要有两个注意点：\n首先需要构造图，构造图时注意无向图的一条边相当于两条有向边 weight计算方式与普通的dijkstra不同，即需要修改weight函数 代码 class Solution { class State { int id; double probFromStart; public State(int id, double probFromStart) { this.id = id; this.probFromStart = probFromStart; } } private double dijkstra(List\u0026lt;double[]\u0026gt;[] graph, int start, int end) { double[] probTo = new double[graph.length]; Arrays.fill(probTo, -1); probTo[start] = 1; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;State\u0026gt;((a, b) -\u0026gt; { return Double.compare(b.probFromStart, a.probFromStart); }); pq.offer(new State(start, 1)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeId = curState.id; double curProbFromStart = curState.probFromStart; if (curNodeId == end) { return probTo[end]; } if (curProbFromStart \u0026lt; probTo[curNodeId]) { continue; } for (double[] neighbor : graph[curNodeId]) { int nextId = (int) neighbor[0]; double nextProbFromStart = curProbFromStart * neighbor[1]; if (nextProbFromStart \u0026gt; probTo[nextId]) { probTo[nextId] = nextProbFromStart; pq.offer(new State(nextId, nextProbFromStart)); } } } return 0.0; } public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) { List\u0026lt;double[]\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; succProb.length; i++) { int from = edges[i][0]; int to = edges[i][1]; double weight = succProb[i]; graph[from].add(new double[]{to, weight}); graph[to].add(new double[]{from, weight}); } return dijkstra(graph, start, end); } } References 1. 概率最大的路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1514/","summary":"思路 dijkstra问题的变种，利用dijkstra模板即可，主要有两个注意点： 首先需要构造图，构造图时注意无向图的一条边相当于两条有向边 w","title":"LeetCode 1514"},{"content":"思路 利用dijkstra的思想，只不过需要把矩阵里的每个元素当成一个结点，求一个结点的相邻结点与一般的图不同（即adj函数），而且最后求的体力消耗是路径上体力的最大值，不是体力消耗之和，所以刷新权重的时候需要编写相应的weight函数\n其实dijsktra问题的变种只要编写相应的adj函数和weight函数即可\n代码 class Solution { class State { int x, y; int effortFromStart; public State(int x, int y, int effortFromStart) { this.x = x; this.y = y; this.effortFromStart = effortFromStart; } } private int[][] dirs = new int[][]{{0, 1}, {0, -1}, {-1, 0}, {1, 0}}; private List\u0026lt;int[]\u0026gt; adj(int[][] matrix, int x, int y) { int m = matrix.length, n = matrix[0].length; List\u0026lt;int[]\u0026gt; neighbors = new ArrayList\u0026lt;\u0026gt;(); for (int[] dir : dirs) { int nx = x + dir[0]; int ny = y + dir[1]; if (nx \u0026lt; 0 || nx \u0026gt;= m || ny \u0026lt; 0 || ny \u0026gt;= n) { continue; } neighbors.add(new int[]{nx, ny}); } return neighbors; } public int minimumEffortPath(int[][] heights) { int m = heights.length, n = heights[0].length; int[][] effortTo = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { Arrays.fill(effortTo[i], Integer.MAX_VALUE); } effortTo[0][0] = 0; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.effortFromStart - b.effortFromStart; }); pq.offer(new State(0, 0, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curX = curState.x; int curY = curState.y; int curEffortFromStart = curState.effortFromStart; if (curX == m -1 \u0026amp;\u0026amp; curY == n - 1) { return curEffortFromStart; } if (curEffortFromStart \u0026gt; effortTo[curX][curY]) { continue; } for (int[] neighbor : adj(heights, curX, curY)) { int nextX = neighbor[0]; int nextY = neighbor[1]; int nextEffort = Math.max(effortTo[curX][curY], Math.abs(heights[nextX][nextY] - heights[curX][curY])); if (nextEffort \u0026lt; effortTo[nextX][nextY]) { effortTo[nextX][nextY] = nextEffort; pq.offer(new State(nextX, nextY, nextEffort)); } } } return -1; } } References 1. 最小体力消耗路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1631/","summary":"思路 利用dijkstra的思想，只不过需要把矩阵里的每个元素当成一个结点，求一个结点的相邻结点与一般的图不同（即adj函数），而且最后求的体","title":"LeetCode 1631"},{"content":"思路 经典dijkstra问题，利用dijkstra模板即可，详见思想章节\n代码 class Solution { class State { int id; int distFromStart; public State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } private int[] dijkstra(List\u0026lt;int[]\u0026gt;[] graph, int start) { int[] distTo = new int[graph.length]; Arrays.fill(distTo, Integer.MAX_VALUE); distTo[start] = 0; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.distFromStart - b.distFromStart; }); pq.offer(new State(start, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeId = curState.id; int curDistFromStart = curState.distFromStart; if (curDistFromStart \u0026gt; distTo[curNodeId]) { continue; } for (int[] neighbor : graph[curNodeId]) { int neighborId = neighbor[0]; int distToNeighbor = distTo[curNodeId] + neighbor[1]; if (distToNeighbor \u0026lt; distTo[neighborId]) { distTo[neighborId] = distToNeighbor; pq.offer(new State(neighborId, distToNeighbor)); } } } return distTo; } public int networkDelayTime(int[][] times, int n, int k) { List\u0026lt;int[]\u0026gt;[] graph = new List[n + 1]; for (int i = 1; i \u0026lt; n + 1; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int[] time : times) { int from = time[0]; int to = time[1]; int weight = time[2]; graph[from].add(new int[]{to, weight}); } int[] distTo = dijkstra(graph, k); int res = 0; for (int i = 1; i \u0026lt; n + 1; i++) { if (distTo[i] == Integer.MAX_VALUE) { return -1; } res = Math.max(res, distTo[i]); } return res; } } References 1. 网络延迟时间 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-743/","summary":"思路 经典dijkstra问题，利用dijkstra模板即可，详见思想章节 代码 class Solution { class State { int id; int distFromStart; public State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } private int[] dijkstra(List\u0026lt;int[]\u0026gt;[] graph, int start) { int[]","title":"LeetCode 743"},{"content":"思路 利用并查集的思想，先将相等的连接起来，然后再判断不相等的是否与并查集里的连通状态冲突\n代码 class Solution { public boolean equationsPossible(String[] equations) { UF uf = new UF(26); for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) { uf.union(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;); } } for (String equation : equations) { if (equation.charAt(1) == \u0026#39;!\u0026#39;) { if (uf.isConnected(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;)) { return false; } } } return true; } class UF { private int[] parent; private int count; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } count = n; } public int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int xRoot = find(x); int yRoot = find(y); if (xRoot == yRoot) { return; } parent[xRoot] = yRoot; count--; } public boolean isConnected(int x, int y) { int xRoot = find(x); int yRoot = find(y); return xRoot == yRoot; } public int getCount() { return count; } } } References 1. 等式方程的可满足性 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-990/","summary":"思路 利用并查集的思想，先将相等的连接起来，然后再判断不相等的是否与并查集里的连通状态冲突 代码 class Solution { public boolean equationsPossible(String[] equations) { UF uf = new UF(26); for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) {","title":"LeetCode 990"},{"content":"思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的\u0026rsquo;O\u0026rsquo;相连的\u0026rsquo;O\u0026rsquo;加入到dummy的集合中，然后遍历一遍二维数组，将不在dummy集合里的\u0026rsquo;O\u0026rsquo;改成\u0026rsquo;X\u0026rsquo;即可\n代码 class Solution { public void solve(char[][] board) { int m = board.length; int n = board[0].length; UF uf = new UF(m * n + 1); int dummy = m * n; for (int i = 0; i \u0026lt; m; i++) { if (board[i][0] == \u0026#39;O\u0026#39;) { uf.union(dummy,i * n); } if (board[i][n - 1] == \u0026#39;O\u0026#39;) { uf.union(dummy,i * n + n - 1); } } for (int i = 0; i \u0026lt; n; i++) { if (board[0][i] == \u0026#39;O\u0026#39;) { uf.union(dummy, i); } if (board[m - 1][i] == \u0026#39;O\u0026#39;) { uf.union(dummy, (m - 1) * n + i); } } int[][] d = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; for (int i = 1; i \u0026lt; m - 1; i++) { for (int j = 1; j \u0026lt; n - 1; j++) { if (board[i][j] == \u0026#39;O\u0026#39;) { for (int k = 0; k \u0026lt; 4; k++) { int x = i + d[k][0]; int y = j + d[k][1]; if (board[x][y] == \u0026#39;O\u0026#39;) { uf.union(i * n + j, x * n + y); } } } } } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (!uf.isConnected(i * n + j, dummy)) { board[i][j] = \u0026#39;X\u0026#39;; } } } } class UF { private int[] parent; private int count; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } count = n; } public int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int xRoot = find(x); int yRoot = find(y); if (xRoot == yRoot) { return; } parent[xRoot] = yRoot; count--; } public boolean isConnected(int x, int y) { int xRoot = find(x); int yRoot = find(y); return xRoot == yRoot; } public int getCount() { return count; } } } References 1. 被围绕的区域 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-130/","summary":"思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的\u0026rsquo;O\u0026rsquo;相连的\u0026rsquo;O\u0026rsquo;加入到dum","title":"LeetCode 130"},{"content":"思路 经典二分图判断，只不过需要先构造一个图，详见思想章节\n代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(n, dislikes); for (int i = 1; i \u0026lt;= n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int n, int[][] dislikes) { List\u0026lt;Integer\u0026gt;[] graph = new List[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] dislike : dislikes) { int s = dislike[0]; int d = dislike[1]; graph[s].add(d); graph[d].add(s); } return graph; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int v) { if (!ok) { return; } visited[v] = true; for (int neighbor : graph[v]) { if (!visited[neighbor]) { color[neighbor] = !color[v]; traverse(graph, neighbor); } else { if (color[v] == color[neighbor]) { ok = false; return; } } } } } References 1. 可能的二分法 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-886/","summary":"思路 经典二分图判断，只不过需要先构造一个图，详见思想章节 代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(n, dislikes); for (int","title":"LeetCode 886"},{"content":"思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节\n代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color = new boolean[n]; visited = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private void traverse(int[][] graph, int v) { if (!ok) { return; } visited[v] = true; for (int neighbor : graph[v]) { if (!visited[neighbor]) { color[neighbor] = !color[v]; traverse(graph, neighbor); } else { if (color[v] == color[neighbor]) { ok = false; return; } } } } } BFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color = new boolean[n]; visited = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private void traverse(int[][] graph, int start) { if (!ok) { return; } Deque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); visited[start] = true; queue.offer(start); while (!queue.isEmpty() \u0026amp;\u0026amp; ok) { int v = queue.poll(); for (int n : graph[v]) { if (!visited[n]) { color[n] = !color[v]; visited[n] = true; queue.offer(n); } else { if (color[n] == color[v]) { ok = false; return; } } } } } } References 1. 判断二分图 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-785/","summary":"思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节 代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color","title":"LeetCode 785"},{"content":"思路 寻找可行的选课顺序其实就是计算拓扑排序\n思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序\n思路二 利用图的BFS，只不过只把入度为零的结点加入队列，队列出队的序列就是该图的拓扑排序\n代码 思路一 class Solution { private boolean[] visited; private boolean[] onPath; private boolean hasCycle = false; private List\u0026lt;Integer\u0026gt; postorder = new LinkedList\u0026lt;\u0026gt;(); public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i]) { traverse(graph, i); } } if (hasCycle) { return new int[0]; } Collections.reverse(postorder); int[] res = new int[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { res[i] = postorder.get(i); } return res; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; return; } if (visited[s]) { return; } visited[s] = true; onPath[s] = true; for (Integer n : graph[s]) { traverse(graph, n); } onPath[s] = false; postorder.add(s); } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } 思路二 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int to = edge[0]; indegree[to]++; } Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int count = 0; int[] res = new int[numCourses]; while (!queue.isEmpty()) { int node = queue.poll(); res[count] = node; count++; for (Integer next : graph[node]) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } if (count != numCourses) { return new int[0]; } return res; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } References 1. 课程表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-210/","summary":"思路 寻找可行的选课顺序其实就是计算拓扑排序 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无","title":"LeetCode 210"},{"content":"思路 这道题其实就是检测图里是否有环\n思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回\n思路二 利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列即可，最后判断访问过的结点个数是否等于总结点个数\n代码 思路一 class Solution { private boolean[] visited; private boolean[] onPath; private boolean hasCycle = false; public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i]) { traverse(graph, i); } } return !hasCycle; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; return; } if (visited[s]) { return; } visited[s] = true; onPath[s] = true; for (Integer n : graph[s]) { traverse(graph, n); } onPath[s] = false; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } 思路二 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int to = edge[0]; indegree[to]++; } Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int count = 0; while (!queue.isEmpty()) { int node = queue.poll(); count++; for (Integer next : graph[node]) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } return count == numCourses; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } References 1. 课程表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-207/","summary":"思路 这道题其实就是检测图里是否有环 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该","title":"LeetCode 207"},{"content":"思路 经典图的遍历，只不过要同时记录路径\n代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList\u0026lt;Integer\u0026gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s == n) { res.add(new LinkedList\u0026lt;\u0026gt;(path)); path.removeLast(); return; } for (int v : graph[s]) { traverse(graph, v, path); } // 离开结点时 path.removeLast(); } } References 1. 所有可能的路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-797/","summary":"思路 经典图的遍历，只不过要同时记录路径 代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList\u0026lt;Integer\u0026gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s","title":"LeetCode 797"},{"content":"思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树\n这种做法时间复杂度是O(logn*logn)，详见：https://labuladong.gitee.io/algo/2/21/48/\n代码 class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } TreeNode left = root, right = root; int lh = 0, rh = 0; while (left != null) { left = left.left; lh++; } while (right != null) { right = right.right; rh++; } if (lh == rh) { return (int) (Math.pow(2, lh) - 1); } return 1 + countNodes(root.left) + countNodes(root.right); } } References 1. 完全二叉树的节点个数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-222/","summary":"思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和","title":"LeetCode 222"},{"content":"思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是LCA\n代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { int val1 = Math.min(p.val, q.val); int val2 = Math.max(p.val, q.val); return find(root, val1, val2); } private TreeNode find(TreeNode root, int val1, int val2) { if (root == null) { return null; } if (root.val \u0026gt; val2) { return find(root.left, val1, val2); } if (root.val \u0026lt; val1) { return find(root.right, val1, val2); } return root; } } References 1. 二叉搜索树的最近公共祖先 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-235/","summary":"思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是","title":"LeetCode 235"},{"content":"思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或q或qp的LCA\n明确函数的定义，这个函数的定义就是如果在root的树中只找到了p就返回p，只找到了q就返回q，两个都找到了就返回公共祖先，都没找到就返回null\n代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null) { return null; } if (root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left != null ? left : right; } } References 1. 二叉树的最近公共祖先 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-236/","summary":"思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或","title":"LeetCode 236"},{"content":"思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码\n思路二 思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代\n代码 思路一 public class NestedIterator implements Iterator\u0026lt;Integer\u0026gt; { private Iterator\u0026lt;Integer\u0026gt; it; public NestedIterator(List\u0026lt;NestedInteger\u0026gt; nestedList) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (NestedInteger nestedInteger : nestedList) { traverse(nestedInteger, result); } it = result.iterator(); } private void traverse(NestedInteger nestedInteger, List\u0026lt;Integer\u0026gt; result) { if (nestedInteger.isInteger()) { result.add(nestedInteger.getInteger()); return; } List\u0026lt;NestedInteger\u0026gt; list = nestedInteger.getList(); for (NestedInteger integer : list) { traverse(integer, result); } } @Override public Integer next() { return it.next(); } @Override public boolean hasNext() { return it.hasNext(); } } 思路二 public class NestedIterator implements Iterator\u0026lt;Integer\u0026gt; { private LinkedList\u0026lt;NestedInteger\u0026gt; nestedList; public NestedIterator(List\u0026lt;NestedInteger\u0026gt; nestedList) { this.nestedList = new LinkedList\u0026lt;\u0026gt;(nestedList); } @Override public Integer next() { return nestedList.remove(0).getInteger(); } @Override public boolean hasNext() { while (!nestedList.isEmpty() \u0026amp;\u0026amp; !nestedList.get(0).isInteger()) { List\u0026lt;NestedInteger\u0026gt; first = nestedList.remove(0).getList(); for (int i = first.size() - 1; i \u0026gt;= 0; i--) { nestedList.addFirst(first.get(i)); } } return !nestedList.isEmpty(); } } References 1. 扁平化嵌套列表迭代器 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-341/","summary":"思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码 思路二 思路一会在","title":"LeetCode 341"},{"content":"思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用\n我的代码 class Solution { private List\u0026lt;TreeNode\u0026gt; generateTrees(int min, int max) { List\u0026lt;TreeNode\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (min \u0026gt; max) { res.add(null); return res; } for (int i = min; i \u0026lt;= max; i++) { List\u0026lt;TreeNode\u0026gt; leftList = generateTrees(min, i - 1); List\u0026lt;TreeNode\u0026gt; rightList = generateTrees(i + 1, max); for (TreeNode leftNode : leftList) { for (TreeNode rightNode : rightList) { TreeNode root = new TreeNode(i); root.left = leftNode; root.right = rightNode; res.add(root); } } } return res; } public List\u0026lt;TreeNode\u0026gt; generateTrees(int n) { return generateTrees(1, n); } } References 1. 不同的二叉搜索树 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-95/","summary":"思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用 我的","title":"LeetCode 95"},{"content":"思路 三种思路：\n递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类\n动态规划 递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划\n数学思路 感觉没必要看\n我的代码 递归 class Solution { public int numTrees(int n) { if (n == 1 || n == 0) { return 1; } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += numTrees(i) * numTrees(n - i - 1); } return sum; } } 动态规划 class Solution { public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; i; j++) { dp[i] += dp[j] * dp[i - 1 - j]; } } return dp[n]; } } References 1. 不同的二叉搜索树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-96/","summary":"思路 三种思路： 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相","title":"LeetCode 96"},{"content":"思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种情况：\nroot左右皆为空，此时直接删除 root左右有一个为空，将不为空的子树替换为当前结点的位置 root左右都不为空，找左子树中最大的或右子树中最小的替换root 我的代码 class Solution { private TreeNode getMin(TreeNode root) { while (root.left != null) { root = root.left; } return root; } public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return null; if (root.val == key) { // 删除该结点 if (root.left == null \u0026amp;\u0026amp; root.right == null) { return null; } if (root.left == null) return root.right; if (root.right == null) return root.left; TreeNode min = getMin(root.right); root.right = deleteNode(root.right, min.val); min.left = root.left; min.right = root.right; root = min; } if (key \u0026gt; root.val) { root.right = deleteNode(root.right, key); } if (key \u0026lt; root.val) { root.left = deleteNode(root.left, key); } return root; } } References 1. 删除二叉搜索树中的节点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-504/","summary":"思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种","title":"LeetCode 504"},{"content":"思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造\n我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } if (val \u0026gt; root.val) { root.right = insertIntoBST(root.right, val); } if (val \u0026lt; root.val) { root.left = insertIntoBST(root.left, val); } return root; } } References 1. 二叉搜索树中的插入操作 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-701/","summary":"思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造 我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) {","title":"LeetCode 701"},{"content":"思路 利用二分查找的思想，不解释了\n我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val \u0026gt; root.val) { return searchBST(root.right, val); } if (val \u0026lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜索 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-700/","summary":"思路 利用二分查找的思想，不解释了 我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val \u0026gt; root.val) { return searchBST(root.right, val); } if (val \u0026lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜","title":"LeetCode 700"},{"content":"思路 两种思路：\n递归 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小+右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，而判断是子树的节点都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去\n中序遍历 先中序遍历，然后看遍历的序列是不是有序的\n我的代码 递归 class Solution { private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) { if (root == null) { return true; } if (min != null \u0026amp;\u0026amp; root.val \u0026lt;= min.val) return false; if (max != null \u0026amp;\u0026amp; root.val \u0026gt;= max.val) return false; return isValidBST(root.left, min, root) \u0026amp; isValidBST(root.right, root, max); } public boolean isValidBST(TreeNode root) { return isValidBST(root, null, null); } } 中序遍历 class Solution { private List\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public boolean isValidBST(TreeNode root) { inorder(root); for (int i = 0; i \u0026lt; track.size() - 1; i++) { if (track.get(i) \u0026gt;= track.get(i + 1)) { return false; } } return true; } private void inorder(TreeNode root) { if (root == null) { return; } inorder(root.left); track.add(root.val); inorder(root.right); } } References 1. 验证二叉搜索树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-98/","summary":"思路 两种思路： 递归 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小+右边的的结点都比root大+左子树是BST+右子","title":"LeetCode 98"},{"content":"思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，这样的话遍历到当前节点的时候，比这个结点大的结点已经遍历完了，用个变量累加一下，然后赋值给当前结点就可以了\n我的代码 class Solution { private int sum = 0; public TreeNode convertBST(TreeNode root) { if (root == null) { return null; } convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root; } } References 1. 把二叉搜索树转换为累加树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-538/","summary":"思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，","title":"LeetCode 538"},{"content":"思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return\n我的代码 class Solution { private int rank = 0; public int kthSmallest(TreeNode root, int k) { if (root == null) { return 0; } int res; if ((res = kthSmallest(root.left, k)) != 0) { return res; } rank++; if (rank == k) { return root.val; } return kthSmallest(root.right, k); } } References 1. 二叉搜索树中第 K 小的元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-230/","summary":"思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return 我的代码 class Solution { private int rank","title":"LeetCode 230"},{"content":"思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（空结点和左右子树都不为null的结点），如果是那就出栈挂在新栈顶的左子树或右子树上，循环往复，直到所有的结点都被加入到栈中，树就被反序列化完成了\n官方思路一 序列化和反序列化均采用分解问题的思想，序列化不用多说，这里把反序列化问题拆分为：新建根节点+反序列化左子树+反序列化右子树（我当时为什么没想到，因为没想到还要写base case）\n官方思路二 使用文法的思想，可以将树用T -\u0026gt; (T) num (T) | X文法来序列化和反序列化，其实本质思路和我的思路一样\n代码 我的代码 public class Codec { private static final char NULL = \u0026#39;#\u0026#39;; private static final char SEP = \u0026#39;,\u0026#39;; private void doSerialize(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(NULL).append(SEP); return; } sb.append(root.val).append(SEP); doSerialize(root.left, sb); doSerialize(root.right, sb); } // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); doSerialize(root, sb); return sb.toString(); } private TreeNode newTreeNode(String val) { if (\u0026#34;#\u0026#34;.equals(val)) { return new TreeNode(-1001); } return new TreeNode(Integer.parseInt(val)); } private TreeNode fixTree(TreeNode root) { if (root == null || root.val == -1001) { return null; } root.left = fixTree(root.left); root.right = fixTree(root.right); return root; } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] nodes = data.split(\u0026#34;,\u0026#34;); Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); TreeNode dummyRoot = new TreeNode(1001); stack.push(dummyRoot); for (int i = 0; i \u0026lt; nodes.length; i++) { stack.push(newTreeNode(nodes[i])); while (stack.peek().val == -1001 || stack.peek().left != null \u0026amp;\u0026amp; stack.peek().right != null) { TreeNode peek = stack.pop(); if (stack.peek().left == null) { stack.peek().left = peek; } else { stack.peek().right = peek; } } } return fixTree(dummyRoot).left; } } 官方思路一 public class Codec { public String serialize(TreeNode root) { return rserialize(root, \u0026#34;\u0026#34;); } public TreeNode deserialize(String data) { String[] dataArray = data.split(\u0026#34;,\u0026#34;); List\u0026lt;String\u0026gt; dataList = new LinkedList\u0026lt;String\u0026gt;(Arrays.asList(dataArray)); return rdeserialize(dataList); } public String rserialize(TreeNode root, String str) { if (root == null) { str += \u0026#34;None,\u0026#34;; } else { str += str.valueOf(root.val) + \u0026#34;,\u0026#34;; str = rserialize(root.left, str); str = rserialize(root.right, str); } return str; } public TreeNode rdeserialize(List\u0026lt;String\u0026gt; dataList) { if (dataList.get(0).equals(\u0026#34;None\u0026#34;)) { dataList.remove(0); return null; } TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0))); dataList.remove(0); root.left = rdeserialize(dataList); root.right = rdeserialize(dataList); return root; } } 官方思路二 public class Codec { public String serialize(TreeNode root) { if (root == null) { return \u0026#34;X\u0026#34;; } String left = \u0026#34;(\u0026#34; + serialize(root.left) + \u0026#34;)\u0026#34;; String right = \u0026#34;(\u0026#34; + serialize(root.right) + \u0026#34;)\u0026#34;; return left + root.val + right; } public TreeNode deserialize(String data) { int[] ptr = {0}; return parse(data, ptr); } public TreeNode parse(String data, int[] ptr) { if (data.charAt(ptr[0]) == \u0026#39;X\u0026#39;) { ++ptr[0]; return null; } TreeNode cur = new TreeNode(0); cur.left = parseSubtree(data, ptr); cur.val = parseInt(data, ptr); cur.right = parseSubtree(data, ptr); return cur; } public TreeNode parseSubtree(String data, int[] ptr) { ++ptr[0]; // 跳过左括号 TreeNode subtree = parse(data, ptr); ++ptr[0]; // 跳过右括号 return subtree; } public int parseInt(String data, int[] ptr) { int x = 0, sgn = 1; if (!Character.isDigit(data.charAt(ptr[0]))) { sgn = -1; ++ptr[0]; } while (Character.isDigit(data.charAt(ptr[0]))) { x = x * 10 + data.charAt(ptr[0]++) - \u0026#39;0\u0026#39;; } return x * sgn; } } References 1. 二叉树的序列化与反序列化 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-297/","summary":"思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（","title":"LeetCode 297"},{"content":"思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树\n详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] preorder, int preStart, int preEnd, int[] postorder, int postStart, int postEnd) { if (preStart \u0026gt; preEnd) { return null; } if (preStart == preEnd) { return new TreeNode(preorder[preStart]); } int val = preorder[preStart]; TreeNode root = new TreeNode(val); int leftIndex = valToIndex.get(preorder[preStart + 1]); int leftSize = leftIndex - postStart + 1; TreeNode left = build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, leftIndex); TreeNode right = build(preorder, preStart + leftSize + 1, preEnd, postorder, leftIndex + 1, postEnd - 1); root.left = left; root.right = right; return root; } public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { for (int i = 0; i \u0026lt; postorder.length; i++) { valToIndex.put(postorder[i], i); } return build(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1); } } References 1. 根据前序和后序遍历构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-889/","summary":"思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树 详见：https://blog.zhangmengya","title":"LeetCode 889"},{"content":"思路 同LeetCode-105，就是改一下递归的参数\n详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] postorder, int postStart, int postEnd, int[] inorder, int inStart, int inEnd) { if (postStart \u0026gt; postEnd) { return null; } int val = postorder[postEnd]; TreeNode root = new TreeNode(val); int index = valToIndex.get(val); int leftSize = index - inStart; TreeNode left = build(postorder, postStart, postStart + leftSize - 1, inorder, inStart, index - 1); TreeNode right = build(postorder, postStart + leftSize, postEnd - 1, inorder, index + 1, inEnd); root.left = left; root.right = right; return root; } public TreeNode buildTree(int[] inorder, int[] postorder) { for (int i = 0; i \u0026lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(postorder, 0, postorder.length - 1, inorder, 0, inorder.length - 1); } } References 1. 从后序和中序遍历序列构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-106/","summary":"思路 同LeetCode-105，就是改一下递归的参数 详见：https://blog.zhangmengyang.tk/posts/leetc","title":"LeetCode 106"},{"content":"思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据root在中序遍历的位置得到左右子树节点的个数，再构造左右子树即可\n注意这里可以用map优化通过元素的值找所在数组的索引，用一个valToIndex的hashmap即可\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { if (preStart \u0026gt; preEnd) { return null; } int val = preorder[preStart]; TreeNode root = new TreeNode(val); int index = valToIndex.get(val); int leftSize = index - inStart; TreeNode left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); TreeNode right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); root.left = left; root.right = right; return root; } public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i \u0026lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } } References 1. 从前序和中序遍历序列构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-105/","summary":"思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据ro","title":"LeetCode 105"},{"content":"思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即可\n代码 class Solution { private TreeNode build(int[] nums, int low, int high) { if (low \u0026gt; high) { return null; } int max = nums[low], index = low; for (int i = low + 1; i \u0026lt;= high; i++) { if (nums[i] \u0026gt; max) { max = nums[i]; index = i; } } TreeNode root = new TreeNode(max); TreeNode left = build(nums, low, index - 1); TreeNode right = build(nums, index + 1, high); root.left = left; root.right = right; return root; } public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0 , nums.length - 1); } } References 1. 最大二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-654/","summary":"思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即","title":"LeetCode 654"},{"content":"思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路\n将该问题分解为：左子树展开+右子树展开+将右子树接到左子树上，即可，不过需要注意左右子树为空的情况\n代码 class Solution { private TreeNode tranToLinkedList(TreeNode root) { if (root == null) { return null; } TreeNode left = root.left; TreeNode right = root.right; TreeNode leftLast = tranToLinkedList(left); TreeNode rightLast = tranToLinkedList(right); if (leftLast == null) { root.left = null; root.right = right; } else if (rightLast == null) { root.left = null; root.right = left; } else { root.left = null; root.right = left; leftLast.right = right; } return rightLast != null ? rightLast : (leftLast != null ? leftLast : root); } public void flatten(TreeNode root) { if (root == null) { return; } tranToLinkedList(root); } } References 1. 二叉树展开为链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-114/","summary":"思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路 将该问题分解为：左子树展开+右子树展开","title":"LeetCode 114"},{"content":"思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历\n思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的\n思路二 把间隙看成结点，那么间隙组成的数据结构就是一颗三叉树，遍历这个三叉树即可解决问题，每个间隙结点需要做的事是把这个间隙的两个结点连接起来，在前中后序位置都可以\n代码 思路一 class Solution { public Node connect(Node root) { if (root == null) { return null; } Deque\u0026lt;Node\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { Node cur = queue.poll(); if (cur.left != null) { queue.offer(cur.left); queue.offer(cur.right); } if (i == size - 1) { cur.next = null; } else { cur.next = queue.peek(); } } } return root; } } 思路二 class Solution { private void traverse(Node left, Node right) { if (left == null) { return; } left.next = right; traverse(left.left, left.right); traverse(left.right, right.left); traverse(right.left, right.right); } public Node connect(Node root) { if (root == null) { return null; } traverse(root.left, root.right); return root; } } References 1. 填充每个节点的下一个右侧节点指针 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-116/","summary":"思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历 思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的 思路二 把间隙看成结点，那","title":"LeetCode 116"},{"content":"思路 遍历方式和分解方式都可以\n遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可\n分解思路 利用二叉树的分解问题思想，将原问题分解为左子树的翻转和右子树的分解，然后翻转左右子树\n代码 遍历思路 class Solution { private void traverse(TreeNode root) { if (root == null) { return; } TreeNode temp = root.right; root.right = root.left; root.left = temp; traverse(root.left); traverse(root.right); } public TreeNode invertTree(TreeNode root) { traverse(root); return root; } } 分解思路 class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; } } References 1. 翻转二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-226/","summary":"思路 遍历方式和分解方式都可以 遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可 分解思路 利用二叉树的分解","title":"LeetCode 226"},{"content":"思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，因为只有后序遍历能获得左右子树的信息。\n代码 class Solution { int maxDiameter = 0; private int maxDeep(TreeNode root) { if (root == null) { return 0; } int leftDeep = maxDeep(root.left); int rightDeep = maxDeep(root.right); maxDiameter = Math.max(maxDiameter, leftDeep + rightDeep); return Math.max(leftDeep, rightDeep) + 1; } public int diameterOfBinaryTree(TreeNode root) { maxDeep(root); return maxDiameter; } } References 1. 二叉树的直径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-543/","summary":"思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，","title":"LeetCode 543"},{"content":"思路 有两种思路，分别是分解问题和遍历二叉树\n思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度\n思路二 把二叉树遍历一遍，同时用一个外部变量记录最大的深度，注意需要在前序位置deep++，后序位置deep\u0026ndash;\n代码 思路一 class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } } 思路二 class Solution { int res = 0, deep = 0; private void traverse(TreeNode root) { if (root == null) { return; } deep++; if (root.left == null \u0026amp;\u0026amp; root.right == null) { res = Math.max(res, deep); } traverse(root.left); traverse(root.right); deep--; } public int maxDepth(TreeNode root) { traverse(root); return res; } } References 1. 二叉树的最大深度 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-104/","summary":"思路 有两种思路，分别是分解问题和遍历二叉树 思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度 思路二 把二叉树","title":"LeetCode 104"},{"content":"思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可\n第二题 考察差分数组和异或的性质\n由a^b=c \u0026mdash;\u0026gt; a^a^b=a^c \u0026mdash;\u0026gt; 0^b=a^c \u0026mdash;\u0026gt; b=a^c，因为相同的数异或为0，任何数异或0都不变\n给你的数组相当于是前缀和数组，前缀和数组的差分既是原数组，知道了异或的结果，求异或前的值，用上述推断，然后遍历数组逐个异或即可\n第三题 考察贪心和栈\n哪里贪心了？答：因为题目要求给出字典序最小的字符串，也就是需要尽量把最小的字母放在前面，那么可以比较栈顶和没入栈的那些字母，看下没入栈的那些字母是否有比栈顶小的字母，如果没有，那直接出栈，如果有，那就入栈直到遇到最小的字符串，这样贪心，最后的结果一定是字典序最小的字符串。\n第四题 考察动态规划\n非常典型的动态规划，唯一要注意的就是动态规划数组里的元素不能是所有路径长度的list，因为逐个遍历list的元素会超时，需要使用map，key为路径长度，value为长度为key的路径的个数，还需要注意value有可能很大，需要取余1000000007，key有可能很多，所以需要取余k，因为最终只需要长度能整除k的路径个数，而不需要具体的路径长度。\n总结 本次周赛难度偏低，但是我刷题太少，做起来不熟练，需要多练习多总结。\n代码 第一题 class Solution { public int hardestWorker(int n, int[][] logs) { int[] time = new int[logs.length]; int id = logs[0][0], maxTime = logs[0][1]; time[0] = logs[0][1]; for (int i = 1; i \u0026lt; time.length; i++) { time[i] = logs[i][1] - logs[i - 1][1]; if (time[i] \u0026gt; maxTime || time[i] == maxTime \u0026amp;\u0026amp; id \u0026gt; logs[i][0]) { maxTime = time[i]; id = logs[i][0]; } } return id; } } 第二题 class Solution { public int[] findArray(int[] pref) { for (int i = pref.length - 1; i \u0026gt; 0; i--) { pref[i] = pref[i] ^ pref[i - 1]; } return pref; } } 第三题 class Solution { private boolean hasSmaller(int[] count, int i) { for (int j = 0; j \u0026lt; i; j++) { if (count[j] != 0) { return true; } } return false; } public String robotWithString(String s) { int[] count = new int[26]; for (int i = 0; i \u0026lt; s.length(); i++) { count[s.charAt(i) - \u0026#39;a\u0026#39;]++; } StringBuilder ans = new StringBuilder(); Deque\u0026lt;Character\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push((char) (\u0026#39;z\u0026#39; + 1)); int index = 0; while (ans.length() != s.length()) { Character peek = stack.peek(); if (hasSmaller(count, peek - \u0026#39;a\u0026#39;)) { stack.push(s.charAt(index)); count[s.charAt(index) - \u0026#39;a\u0026#39;]--; index++; } else { ans.append(peek); stack.pop(); } } return ans.toString(); } } 第四题 class Solution { public int numberOfPaths(int[][] grid, int k) { Map\u0026lt;Integer, Integer\u0026gt;[] path = new HashMap[grid[0].length]; path[0] = new HashMap\u0026lt;\u0026gt;(); path[0].put(grid[0][0] % k, 1); for (int i = 1; i \u0026lt; grid[0].length; i++) { path[i] = new HashMap\u0026lt;\u0026gt;(); for (Integer integer : path[i - 1].keySet()) { path[i].put((integer + grid[0][i]) % k, 1); } } for (int i = 1; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++) { HashMap\u0026lt;Integer, Integer\u0026gt; temp = new HashMap\u0026lt;\u0026gt;(path[j]); path[j].clear(); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : temp.entrySet()) { path[j].put((entry.getKey() + grid[i][j]) % k, entry.getValue()); } if (j != 0) { for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : path[j - 1].entrySet()) { int newKey = (entry.getKey() + grid[i][j]) % k; path[j].put(newKey, (path[j].getOrDefault(newKey, 0) + entry.getValue()) % 1000000007); } } } } return path[path.length - 1].getOrDefault(0, 0); } } References 1. 处理用时最长的那个任务的员工 2. 找出前缀异或的原始数组 3. 使用机器人打印字典序最小的字符串 4. 矩阵中和能被 K 整除的路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-314/","summary":"思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可 第二题 考察差分数组和异或的性质 由a^b=c \u0026mdash;\u0026gt; a^a^b=a^c \u0026mdash;\u0026gt; 0^b=a^c \u0026mdash;\u0026gt; b","title":"LeetCode 周赛 314"},{"content":"思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.length个格子里去，那么就可以把这些格子后面的不是黑名单的数字和前面黑名单的数字交换，这样就可以随机获取数字了\n又由于数组大部分元素的值和下标是一样的，所以可以省略数组，用map记录那些交换的元素\n代码 class Solution { int size; Set\u0026lt;Integer\u0026gt; blackSet = new HashSet\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; blackMap = new HashMap\u0026lt;\u0026gt;(); public Solution(int n, int[] blacklist) { size = n - blacklist.length; for (int num : blacklist) { if (num \u0026gt;= size) { blackSet.add(num); } } int last = n - 1; for (int num : blacklist) { if (num \u0026lt; size) { while (blackSet.contains(last)) { last--; } blackMap.put(num, last); last--; } } } public int pick() { int random = new Random().nextInt(size); if (blackMap.containsKey(random)) { return blackMap.get(random); } return random; } } References 1. 黑名单中的随机数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-710/","summary":"思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.le","title":"LeetCode 710"},{"content":"思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组\n代码 class RandomizedSet { private List\u0026lt;Integer\u0026gt; nums; private Map\u0026lt;Integer, Integer\u0026gt; valToIndex; public RandomizedSet() { nums = new ArrayList\u0026lt;\u0026gt;(); valToIndex = new HashMap\u0026lt;\u0026gt;(); } public boolean insert(int val) { if (valToIndex.containsKey(val)) { return false; } valToIndex.put(val, nums.size()); nums.add(val); return true; } public boolean remove(int val) { if (!valToIndex.containsKey(val)) { return false; } int index = valToIndex.get(val); int lastNum = nums.get(nums.size() - 1); valToIndex.put(lastNum, index); valToIndex.remove(val); nums.set(index, lastNum); nums.remove(nums.size() - 1); return true; } public int getRandom() { return nums.get(new Random().nextInt(nums.size())); } } References 1. O(1) 时间插入、删除和获取随机元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-380/","summary":"思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索","title":"LeetCode 380"},{"content":"思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍\n有两个需要注意的地方：\n”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了 寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见LeetCode-note的思想章节二分查找注意点第10条 代码 class Solution { int[] preSum; public Solution(int[] w) { preSum = new int[w.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + w[i - 1]; } } public int pickIndex() { int random = new Random().nextInt(preSum[preSum.length - 1]) + 1; // 二分法寻找random所在的索引 int left = 0, right = preSum.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (random \u0026lt;= preSum[mid]) { right = mid; } else { left = mid + 1; } } return left - 1; } } References 1. 按权重随机选择 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-528/","summary":"思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值","title":"LeetCode 528"},{"content":"思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/\n代码 class Solution { public int[][] generateMatrix(int n) { int upperBound = 0, lowerBound = n - 1; int leftBound = 0, rightBound = n - 1; int[][] matrix = new int[n][n]; int num = 1; while (num \u0026lt;= n * n){ if (upperBound \u0026lt;= lowerBound) { for (int i = leftBound; i \u0026lt;= rightBound; i++) { matrix[upperBound][i] = num; num++; } upperBound++; } if (leftBound \u0026lt;= rightBound) { for (int i = upperBound; i \u0026lt;= lowerBound; i++) { matrix[i][rightBound] = num; num++; } rightBound--; } if (upperBound \u0026lt;= lowerBound) { for (int i = rightBound; i \u0026gt;= leftBound; i--) { matrix[lowerBound][i] = num; num++; } lowerBound--; } if (leftBound \u0026lt;= rightBound) { for (int i = lowerBound; i \u0026gt;= upperBound; i--) { matrix[i][leftBound] = num; num++; } leftBound++; } } return matrix; } } References 1. 螺旋矩阵 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-59/","summary":"思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leet","title":"LeetCode 59"},{"content":"思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：\n需要注意水平遍历需要判断upperBound\u0026lt;=lowerBound，垂直遍历需要判断leftBound\u0026lt;=rightBound\n代码 class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { int row = matrix.length, col = matrix[0].length; int upperBound = 0, lowerBound = row - 1; int leftBound = 0, rightBound = col - 1; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (ans.size() \u0026lt; row * col) { if (upperBound \u0026lt;= lowerBound) { for (int i = leftBound; i \u0026lt;= rightBound; i++) { ans.add(matrix[upperBound][i]); } upperBound++; } if (leftBound \u0026lt;= rightBound) { for (int i = upperBound; i \u0026lt;= lowerBound; i++) { ans.add(matrix[i][rightBound]); } rightBound--; } if (upperBound \u0026lt;= lowerBound) { for (int i = rightBound; i \u0026gt;= leftBound; i--) { ans.add(matrix[lowerBound][i]); } lowerBound--; } if (leftBound \u0026lt;= rightBound) { for (int i = lowerBound; i \u0026gt;= upperBound; i--) { ans.add(matrix[i][leftBound]); } leftBound++; } } return ans; } } References 1. 螺旋矩阵 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-54/","summary":"思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界： 需要注意水平遍历需要判断upperBound\u0026lt","title":"LeetCode 54"},{"content":"思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可\n为什么这样做？因为旋转90°相当于把行变成列，而对折矩阵刚好可以把行变成列，但是位置不对，那再反转一下就行了\n代码 class Solution { public void rotate(int[][] matrix) { for (int i = 0; i \u0026lt; matrix.length; i++) { // 注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，相当于对折了两次，所以这里要写j = i + 1 for (int j = i + 1; j \u0026lt; matrix[0].length; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } for (int i = 0; i \u0026lt; matrix.length; i++) { reverse(matrix[i]); } } private void reverse(int[] s) { int left = 0, right = s.length - 1; while (left \u0026lt; right) { int temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 旋转图像 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-48/","summary":"思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的","title":"LeetCode 48"},{"content":"思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再reverse各个单词，但要注意一下细节，比如去空格什么的\n代码 class Solution { private void reverse(char[] s, int i, int j) { int left = i, right = j - 1; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } private void translate(char[] s, int i, int j, int step) { for (int k = i; k \u0026lt; j; k++) { s[k - step] = s[k]; } for (int k = j - step; k \u0026lt; j; k++) { s[k] = \u0026#39; \u0026#39;; } } public String reverseWords(String s) { char[] cs = s.toCharArray(); reverse(cs, 0, cs.length); int left = -1, step = 0; for (int i = 0; i \u0026lt; cs.length; i++) { if (cs[i] == \u0026#39; \u0026#39;) { if (left != -1) { reverse(cs, left, i); translate(cs, left, i, step); left = -1; } else { step++; } } else { if (left == -1) { left = i; } } } if (left != -1) { reverse(cs, left, cs.length); translate(cs, left, cs.length, step); } return new String(cs).trim(); } } References 1. 反转字符串中的单词 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-151/","summary":"思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再revers","title":"LeetCode 151"},{"content":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算\n代码 class Solution { public boolean carPooling(int[][] trips, int capacity) { int len = 0; for (int[] trip : trips) { len = len \u0026gt; trip[2] ? len : trip[2]; } int[] nums = new int[len]; Difference df = new Difference(nums); for (int[] trip : trips) { df.increment(trip[1], trip[2] - 1, trip[0]); } for (int num : df.result()) { if (num \u0026gt; capacity) { return false; } } return true; } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 拼车 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1094/","summary":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算 代码 class Solution { public boolean carPooling(int[][] trips, int","title":"LeetCode 1094"},{"content":"思路 标准差分数组，详见LeetCode-note\n代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 航班预订统计 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1109/","summary":"思路 标准差分数组，详见LeetCode-note 代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff;","title":"LeetCode 1109"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n代码 class NumMatrix { int[][] preSum; public NumMatrix(int[][] matrix) { preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { for (int j = 1; j \u0026lt; preSum[0].length; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } public int sumRegion(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } References 1. 二维区域和检索 - 矩阵不可变 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-304/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位 还需要","title":"LeetCode 304"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位\n代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } References 1. 区域和检索 - 数组不可变 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-303/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位 代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum =","title":"LeetCode 303"},{"content":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找出窗口最大时的长度就可以了\n代码 class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), left = 0, right = 0, res = 0; Set\u0026lt;Character\u0026gt; window = new HashSet\u0026lt;\u0026gt;(); while (right \u0026lt; n) { char c = s.charAt(right); right++; while (window.contains(c)) { char d = s.charAt(left); left++; window.remove(d); } window.add(c); res = Math.max(res, window.size()); } return res; } } References 1. 无重复字符的最长子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-3/","summary":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找","title":"LeetCode 3"},{"content":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/\n代码 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; p.length(); i++) { char c = p.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == p.length()) { ans.add(left); char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } } return ans; } } 另一种思路 vector\u0026lt;int\u0026gt; findAnagrams(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; vector\u0026lt;int\u0026gt; res; // 记录结果 while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 当窗口符合条件时，把起始索引加入 res if (valid == need.size()) res.push_back(left); char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } return res; } References 1. 找到字符串中所有字母异位词 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-438/","summary":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengya","title":"LeetCode 438"},{"content":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法的字符，当窗口的长度和s1的长度一样时，就找到了这个子串\nlabuladong的思路：利用滑动窗口的思想，始终保持窗口大小为s1.size()-1，每次移入窗口一个元素，检查一下是否找到子串，如果没有，再让一个元素移出窗口，直到找到这个子串\n代码 class Solution { public boolean checkInclusion(String s1, String s2) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s1.length(); i++) { char c = s1.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; while (right \u0026lt; s2.length()) { char c = s2.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s2.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == s1.length()) { return true; } } return false; } } 另一种思路 // 判断 s 中是否存在 t 的排列 bool checkInclusion(string t, string s) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 在这里判断是否找到了合法的子串 if (valid == need.size()) return true; char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } // 未找到符合条件的子串 return false; } References 1. 字符串的排列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-567/","summary":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法","title":"LeetCode 567"},{"content":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节\n代码 class Solution { public String minWindow(String s, String t) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; t.length(); i++) { char c = t.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, valid = 0, begin = 0, end = Integer.MAX_VALUE; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素 // 所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (need.containsKey(c)) { window.put(c, window.getOrDefault(c, 0) + 1); if (window.get(c).equals(need.get(c))) { valid++; } } while (valid == need.size()) { if (end - begin \u0026gt; right - left) { begin = left; end = right; } c = s.charAt(left); left++; if (need.containsKey(c)) { if (window.get(c).equals(need.get(c))) { valid--; } window.put(c, window.get(c) - 1); } } } return end == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(begin, end); } } References 1. 最小覆盖子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-76/","summary":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节 代码 class Solution {","title":"LeetCode 76"},{"content":"思路 第一题 排序，不解释\n第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了\n第三题 暴力会超时，利用动态规划的思想，从左往右遍历一遍找各元素左边递减的元素个数，从右往左遍历一遍找各元素右边递增的元素个数，然后和k比较就可以了\n代码 第一题 class Solution { public String[] sortPeople(String[] names, int[] heights) { People[] peoples = new People[names.length]; for(int i = 0; i \u0026lt; peoples.length; i++) { peoples[i] = new People(names[i], heights[i]); } Arrays.sort(peoples, (a, b) -\u0026gt; b.height - a.height); for (int i = 0; i \u0026lt; peoples.length; i++) { names[i] = peoples[i].name; } return names; } static class People { String name; int height; public People(String name, int height) { this.name = name; this.height = height; } } } 第二题 class Solution { public int longestSubarray(int[] nums) { int max = Integer.MIN_VALUE, ans = 0, count = 0; for (int num : nums) { if (num != max) { count = 0; if (num \u0026gt; max) { max = num; ans = 0; } } if (num == max) { count++; } if (count \u0026gt; ans) { ans = count; } } return ans; } } 第三题 动态规划：\nclass Solution { public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { int[] decre = new int[nums.length]; decre[0] = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026lt;= nums[i - 1]) { decre[i] = decre[i - 1] + 1; } else { decre[i] = 1; } } int[] incre = new int[nums.length]; incre[nums.length - 1] = 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { if (nums[i] \u0026lt;= nums[i + 1]) { incre[i] = incre[i + 1] + 1; } else { incre[i] = 1; } } ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (decre[i - 1] \u0026gt;= k \u0026amp;\u0026amp; incre[i+1] \u0026gt;= k) { ans.add(i); } } return ans; } } 暴力解法：\nclass Solution { private boolean isGoodIndex(int[] nums, int index, int k) { for (int i = index - 1; i \u0026gt; index - k; i--) { if (nums[i] \u0026gt; nums[i - 1]) { return false; } } for (int i = index + 1; i \u0026lt; index + k; i++) { if (nums[i] \u0026gt; nums[i + 1]) { return false; } } return true; } public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (isGoodIndex(nums, i, k)) { ans.add(i); } } return ans; } } References 1. 按身高排序 2. 按位与最大的最长子数组 3. 找到所有好下标 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-312/","summary":"思路 第一题 排序，不解释 第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了 第三题 暴力会超时，利用","title":"LeetCode 周赛-312"},{"content":"思路 经典进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，分别查找左边界或右边界即可，详见LeetCode-note-1\n代码 class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } return new int[]{searchLeft(nums, target), searchRight(nums, target)}; } private int searchLeft(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026lt;= nums[mid]) { right = mid; } else { left = mid + 1; } } return nums[left] == target ? left : -1; } private int searchRight(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if (target \u0026gt;= nums[mid]) { left = mid; } else { right = mid - 1; } } return nums[left] == target ? left : -1; } } References 1. 在排序数组中查找元素的第一个和最后一个位置 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-34/","summary":"思路 经典进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查","title":"LeetCode 34"},{"content":"思路 经典二分查找，不解释\n详见：https://labuladong.gitee.io/algo/2/20/29/\n代码 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } } References 1. 二分查找 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-704/","summary":"思路 经典二分查找，不解释 详见：https://labuladong.gitee.io/algo/2/20/29/ 代码 class Solution { public int search(int[] nums, int target) { int left","title":"LeetCode 704"},{"content":"思路 两种思路：\n中心扩展法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n动态规划 构建dp数组，数组的元素为[i\u0026hellip;j]是否为回文串，状态转移方程为：\nif (s.charAt(i) == s.charAt(j) \u0026amp;\u0026amp; (j - i \u0026lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; } 同时统计最长回文串即可，base case为j = i + 1和 j = i的情况，可以优化空间复杂度\n马拉车算法 感觉没什么用，没看，就是一个O(n)时间复杂度求最长回文串的一个算法\n代码 中心扩展法 class Solution { public String longestPalindrome(String s) { String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { // 从中心向两边寻找回文串 String s1 = findPalindrome(s, i, i); String s2 = findPalindrome(s, i, i + 1); res = res.length() \u0026gt;= s1.length() ? res : s1; res = res.length() \u0026gt;= s2.length() ? res : s2; } return res; } private String findPalindrome(String s, int left, int right) { while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(left) == s.charAt(right)) { left--; right++; } return s.substring(left + 1, right); } } 动态规划 class Solution { public String longestPalindrome(String s) { int n = s.length(), maxLen = 0, maxLeft = 0, maxRight = 0; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = i; j \u0026lt; n; j++) { if (s.charAt(i) == s.charAt(j) \u0026amp;\u0026amp; (j - i \u0026lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; if (j - i + 1 \u0026gt; maxLen) { maxLeft = i; maxRight = j; maxLen = j - i + 1; } } } } return s.substring(maxLeft, maxRight + 1); } } References 1. 最长回文子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-5/","summary":"思路 两种思路： 中心扩展法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。 动态规划 构建dp数组，数组的元素为[i\u0026hellip;","title":"LeetCode 5"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 反转字符串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-344/","summary":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值 代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1.","title":"LeetCode 344"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n代码 class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; while (left \u0026lt; right) { int sum = numbers[left] + numbers[right]; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { return new int[]{left + 1, right + 1}; } } return new int[]{0, 0}; } } References 1. 两数之和 II - 输入有序数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-167/","summary":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。 代","title":"LeetCode 167"},{"content":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题）\n26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n83 同26，只不过是链表，要注意去重后要把slow后面的链表断开，否则slow后面可能会有和slow重复的。\n27 同26，只不过不是比较slow和fast的元素，而是让fast和确定的值比较。\n283 同27，只不过得把slow后面的改成0。\n代码 26 class Solution { public int removeDuplicates(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow + 1; } } 83 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { slow.next = fast; slow = slow.next; } fast = fast.next; } slow.next = null; return head; } } 27 class Solution { public int removeElement(int[] nums, int val) { if (nums.length == 0) { return 0; } int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } 283 class Solution { public void moveZeroes(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != 0) { nums[slow] = nums[fast]; slow++; } fast++; } while (slow \u0026lt; nums.length) { nums[slow] = 0; slow++; } } } References 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-26+83+27+283/","summary":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题） 26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的","title":"LeetCode 26+83+27+283"},{"content":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找中点 ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } // 如果是奇数个节点，slow需要后移一位 if (fast != null) { slow = slow.next; } // 反转slow之后的 ListNode right = reverse(slow), left = head; // 判断回文 while (right != null) { if (left.val != right.val) { return false; } left = left.next; right = right.next; } return true; } private ListNode reverse(ListNode head) { ListNode pre = null, cur = head; while (cur != null) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88+%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。 代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找","title":"LeetCode 234 快慢指针+反转链表"},{"content":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private boolean traverse(ListNode right) { if (right == null) { return true; } boolean res = traverse(right.next); res = res \u0026amp;\u0026amp; (left.val == right.val); left = left.next; return res; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E9%93%BE%E8%A1%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。 代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private","title":"LeetCode 234 链表后序遍历"},{"content":"思路 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n代码 class Solution { private ListNode reverse(ListNode a, ListNode b) { // 这个做法需要对第一个节点特殊判断 // if (head == null) { // return null; // } // // ListNode pre = head, cur = head.next; // head.next = null; // while (cur != null) { // ListNode temp = cur.next; // cur.next = pre; // cur = temp; // } // // return pre; // 这个做法不需要对第一个节点特殊判断 ListNode pre = null, cur = a; while (cur != b) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } public ListNode reverseKGroup(ListNode head, int k) { ListNode p = head; // 找出前k个节点，不满k个直接return for (int i = 0; i \u0026lt; k; i++) { if (p == null) { return head; } p = p.next; } // 反转前k个 ListNode newHead = reverse(head, p); // 拼接后面反转后的链表 head.next = reverseKGroup(p, k); return newHead; } } References 1. K 个一组翻转链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-25/","summary":"思路 1、先反转以 head 开头的 k 个元素。 2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。 3、将上述两个过程的结果连接起来。 注意base case为最后元素","title":"LeetCode 25"},{"content":"思路 递归法 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n头插法 先找到反转链表的前驱节点，和前驱结点的后一个结点（其实就是反转后的尾结点），然后把尾结点后的结点插到前驱结点后，注意尾结点要连上下一个需要头插的结点。\n代码 递归法 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } public ListNode reverseBetween(ListNode head, int left, int right) { if (left == 1) { return reverseN(head, right); } head.next = reverseBetween(head.next, left - 1, right - 1); return head; } } 头插法 class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { ListNode dummy = new ListNode(), tail = dummy, pre = dummy; dummy.next = head; for (int i = 0; i \u0026lt; left; i++) { pre = tail; tail = tail.next; } for (int i = left; i \u0026lt; right; i++) { ListNode cur = tail.next; tail.next = cur.next; cur.next = pre.next; pre.next = cur; } return dummy.next; } } References 1. 反转链表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-92/","summary":"思路 递归法 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和ri","title":"LeetCode 92"},{"content":"思路 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n代码 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } } ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA%E8%8A%82%E7%82%B9/","summary":"思路 解决思路和反转整个链表差不多，只要稍加修改即可： 1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。 2、刚才我们直接","title":"反转链表前n个节点"},{"content":"思路 两种思路：\n递归 利用递归的思想，先反转head后面的，然后把head也反转即可。\n迭代 利用头插法的思想即可，直接看代码\n代码 递归 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } } 迭代 class Solution { public ListNode reverseList(ListNode head) { ListNode newHead = new ListNode(); while (head != null) { ListNode next = head.next; head.next = newHead.next; newHead.next = head; head = next; } return newHead.next; } } References 1. 反转链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-206/","summary":"思路 两种思路： 递归 利用递归的思想，先反转head后面的，然后把head也反转即可。 迭代 利用头插法的思想即可，直接看代码 代码 递归 class Solution { public ListNode reverseList(ListNode head)","title":"LeetCode 206"},{"content":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n分析过程 难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：\n如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n转载于： https://labuladong.gitee.io/algo/2/19/18/\n代码 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headB; while (p1 != p2) { if (p1 == null) { p1 = headB; } else { p1 = p1.next; } if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } } References 1. 相交链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-160/","summary":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等","title":"LeetCode 160"},{"content":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n分析过程 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：\nfast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。\n假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。\n巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：\n所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。\n转载于：https://labuladong.gitee.io/algo/2/19/18/\n代码 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; // 寻找相遇点 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (slow == fast) { break; } } if (fast == null || fast.next == null) { return null; } // 再次相遇即为环起始点 fast = head; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } References 1. 环形链表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-142/","summary":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次","title":"LeetCode 142"},{"content":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表有环 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } } References 1. 环形链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-141/","summary":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环 代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表","title":"LeetCode 141"},{"content":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n代码 class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; // 经典快慢指针 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } } References 1. 链表的中间结点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-876/","summary":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 需要注意的是，如果链表","title":"LeetCode 876"},{"content":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n代码 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让p1指针走n步 for (int i = 0; i \u0026lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // p1指针走到头，p2指针指向的就是需要找的节点 while (p1 != null) { p1 = p1.next; p2 = p2.next; } return p2; } public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; // 找到倒数第n+1个节点 ListNode node = findFromEnd(dummy, n + 1); node.next = node.next.next; return dummy.next; } } References 1. 删除链表的倒数第 N 个结点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-19/","summary":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指","title":"LeetCode 19"},{"content":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n代码 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.val; }); for (ListNode head : lists) { if (head != null) { pq.add(head); } } // 每次取出来一个最小的 while (!pq.isEmpty()) { ListNode node = pq.poll(); p.next = node; p = p.next; if (node.next != null) { pq.add(node.next); } } return dummy.next; } } References 1.合并K个升序链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-23/","summary":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。 代码 class Solution { public ListNode mergeKLists(ListNode[] lists) {","title":"LeetCode 23"},{"content":"链表 合并两个有序链表 解法 略\n题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-21/\n单链表的分解 解法 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n题目 1. 分隔链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-86/\n合并 k 个有序链表 解法 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n题目 1. 合并K个升序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-23/\n寻找单链表的倒数第 k 个节点 解法 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n题目 1. 删除链表的倒数第 N 个结点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-19/\n单链表的中点 解法 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n题目 1. 链表的中间结点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-876/\n判断链表是否包含环 解法 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n题目 1. 环形链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-141/\n存在环的链表中寻找环起点 解法 利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n题目 1. 环形链表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-142/\n2. 寻找重复数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-287/\n判断两个链表是否相交 解法 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n题目 1. 相交链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-160/\n反转单链表 解法 利用递归的思想，先反转head后面的，然后把head也反转即可。\n思想 反转的过程就是改变指针方向的过程并且最后一个指向null，比如反转第2个\u0026mdash;第5个：\n1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null\n反转后为：\n1 -\u0026gt; 2 \u0026lt;- 3 \u0026lt;- 4 \u0026lt;- 5\n​ null\n题目 1. 反转链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-206/\n反转链表前n个节点 解法 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n题目 无\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/反转链表前n个节点/\n反转链表节点(m, n) 解法 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n题目 1. 反转链表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-92/\nK 个一组翻转链表 解法 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n题目 1. K 个一组翻转链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-25/\n链表的前后序遍历 void traverse(ListNode head) { // 前序遍历代码 traverse(head.next); // 后序遍历代码 } 回文串 寻找回文串 核心思想是从中心向两端扩展\n判断回文串 核心思想是从两端向中间逼近\n判断回文链表 解法 可以将链表全部反转，也可以部分反转\n链表全部反转 链表全部反转的方法共3种：\n将原链表反转，然后与原链表比较 略\n链表后序遍历 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-链表后序遍历/\n利用栈 同链表后序遍历\n链表部分反转 快慢指针+反转链表 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-快慢指针+反转链表/\n题目 1. 回文链表 数组 快慢指针在数组中的应用 数组元素去重 解法 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n具体变种详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-26+83+27+283/\n题目 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 滑动窗口 解法 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n详见思想章节\n题目 1. 最小覆盖子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-76/\n2. 字符串的排列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/\n3. 找到字符串中所有字母异位词 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-438/\n4. 无重复字符的最长子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-3/\n5. 每种字符至少取 K 个 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-6270/\n6. 统计好子数组的数目 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-周赛-328/\n左右指针在数组中的应用 解法 见题解\n题目 1. 颜色分类 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-75/\n二分查找 解法 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度，详见思想章节\n题目 1. 在排序数组中查找元素的第一个和最后一个位置 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-34/\n2. 二分查找 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-704/\n3. 搜索二维矩阵 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-240/\n4. 寻找两个正序数组的中位数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-4/\n5. 搜索旋转排序数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-33/\n6. 正整数和负整数的最大计数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-周赛-327/\n7. 最大化城市的最小供电站数目 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-双周赛-95/\n8. 每个小孩最多能分到多少糖果 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-2226/\n两数之和 解法 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n题目 1. 两数之和 II - 输入有序数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-167/\n三数之和 解法 先排序，然后确定一个数，剩下两个数用双指针确定，同两数之和，详见题解\n题目 1. 三数之和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-15/\n2. 最接近的三数之和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-16/\n反转数组 解法 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n扩展 反转字符数组里的单词 先反转整个数组，然后再反转各个单词即可\n旋转矩阵 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可\n题目 1. 反转字符串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-344/\n2. 反转字符串中的单词 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-151/\n3. 旋转图像 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-48/\n回文串判断 解法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n题目 1. 最长回文子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-5/\n前缀和 一维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的时nums前n个元素的和，整体往后挪一位\n题目 1. 区域和检索 - 数组不可变 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-303/\n2. 和为 K 的子数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-560/\n3. 除自身以外数组的乘积 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-238/\n二维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n题目 1. 二维区域和检索 - 矩阵不可变 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/\n二叉树中的前缀和 解法 我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上所有节点的前缀和，并且将该前缀和加入数据结构中，并且遍历完当前结点记得将前缀和从数据结构中去除，以免影响其他结点的前缀和\n题目 1. 路径总和 III 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-437/\n差分数组 一维差分数组 解法 详见思想章节\n题目 1. 航班预订统计 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1109/\n2. 拼车 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1094/\n二维差分数组 解法 详见题解\n题目 1. 子矩阵元素加 1 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-周赛-328/\n矩阵的螺旋遍历 解法 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：\n需要注意水平遍历需要判断upperBound\u0026lt;=lowerBound，垂直遍历需要判断leftBound\u0026lt;=rightBound\n题目 1. 螺旋矩阵 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/\n2. 螺旋矩阵 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-59/\n带权重的随机选择算法 解法 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍\n有两个需要注意的地方：\n”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了 寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见思想章节二分查找注意点第10条 题目 1. 按权重随机选择 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-528/\n常数时间删除/查找数组中的任意元素 解法 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组\n核心思想就是为了随机选取元素，肯定得用数组存，并且得是紧凑的\n题目 1. O(1) 时间插入、删除和获取随机元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-380/\n2. 黑名单中的随机数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-710/\n原地哈希 解法 将元素和索引一一对应，不对应的交换元素使其对应\n题目 1. 找到所有数组中消失的数字 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-448/\n2. 寻找重复数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-287/\n3. 缺失的第一个正数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-41/\n二叉树 遍历问题 解法 利用前中后序遍历模板（见思想），用一个 traverse 函数配合外部变量来实现。\n搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n题目 1. 二叉树的最大深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/\n2. 二叉树的前序遍历 题解略\n3. 翻转二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/\n4. 填充每个节点的下一个右侧节点指针 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/\n5. 二叉树的中序遍历 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-94/\n分解问题 解法 主要思想就是定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案\n首先写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)。\n搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n题目 1. 二叉树的最大深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/\n2. 二叉树的直径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-543/\n3. 翻转二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/\n4. 二叉树展开为链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-114/\n层序遍历 解法 就是一个BFS，可以计算一些类似结点与root之间的距离的问题。详见思想里的模板\n题目 1. 填充每个节点的下一个右侧节点指针 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/\n构造二叉树 解法 二叉树的构造问题一般都是使用「分解问题」的思想：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。\n题目 1. 最大二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-654/\n2. 从前序和中序遍历序列构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n3. 从后序和中序遍历序列构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-106/\n4. 根据前序和后序遍历构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-889/\n二叉搜索树性质 解法 只需要利用二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列就可以了\n题目 1. 二叉搜索树中第 K 小的元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-230/\n2. 把二叉搜索树转换为累加树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-538/\n二叉搜索树合法性 解法 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去\n题目 1. 验证二叉搜索树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-98/\n二叉搜索树增删改查 解法 见思想\n题目 1. 二叉搜索树中的搜索 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-700/\n2. 二叉搜索树中的插入操作 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-701/\n3. 删除二叉搜索树中的节点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-504/\nn个结点的BST的种类 解法 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类\n动态规划 递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划\n题目 1. 不同的二叉搜索树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-96/\n2. 不同的二叉搜索树 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-95/\n扁平化嵌套列表迭代器 解法 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码\n思路二 思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代\n题目 1. 扁平化嵌套列表迭代器 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-341/\n最近公共祖先 解法 主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA\n题目 1. 二叉树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/\n2. 二叉搜索树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/\n最近公共祖先 解法 主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA\n题目 1. 二叉树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/\n2. 二叉搜索树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/\n完全二叉树的结点个数 解法 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树\n这种做法时间复杂度是O(logn*logn)，详见：https://labuladong.gitee.io/algo/2/21/48/\n题目 1. 完全二叉树的节点个数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-222/\n合并二叉树 解法 详见题解\n题目 1. 合并二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-617/\n图 图的遍历 解法 直接套模板，详见思想章节\n题目 1. 所有可能的路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-797/\n环检测 解法 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回\n思路二 利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列，出队相当于访问该节点，环里的结点不会入队列，最后判断访问过的结点个数是否等于总结点个数即可\n题目 1. 课程表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-207/\n拓扑排序 解法 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序\n思路二 利用图的BFS，只不过只把入度为零的结点加入队列，出队相当于访问该节点，队列出队的序列就是该图的拓扑排序\n题目 1. 课程表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-210/\n二分图的判断 解法 利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节\n题目 1. 判断二分图 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-785/\n2. 可能的二分法 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-886/\n并查集 解法 利用并查集模板即可，详见思想章节\n题目 1. 被围绕的区域 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-130/\n2. 等式方程的可满足性 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-990/\n3. 寻找图中是否存在路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1971/\n4. 除法求值 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-399/\ndijkstra问题 解法 利用dijkstra模板即可，注意dijkstra的变种需要修改adj和weight函数，详见思想章节\n题目 1. 网络延迟时间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-743/\n2. 最小体力消耗路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1631/\n3. 概率最大的路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1514/\nkruskal问题 解法 利用kruskal算法即可，详见思想章节\n题目 1. 连接所有点的最小费用 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/\nprim问题 解法 利用prim算法即可，详见思想章节\n题目 1. 连接所有点的最小费用 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/\n设计数据结构 LRU 解法 直接套LRU模板即可，详见思想篇章\n题目 1. LRU 缓存 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-146/\nLFU 解法 直接套LFU模板即可，详见思想篇章\n题目 1. LFU 缓存 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-460/\nTrieMap和TrieSet 解法 直接套模板即可，详见思想篇章\n题目 1. 实现 Trie (前缀树) 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-208/\n2. 单词替换 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-648/\n3. 添加与搜索单词 - 数据结构设计 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-211/\n4. 键值映射 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-677/\n数据流的中位数 解法 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg\n题目 1. 数据流的中位数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-295/\n单调栈问题 下一个更大元素 解法 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充当下一个更大元素的角色（中间去除的元素是无法充当这种角色的），那么此时栈顶就是当前元素下一个更大元素\n题目 1. 下一个更大元素 I 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-496/\n2. 每日温度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-739/\n3. 下一个更大元素 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-503/\n4. 接雨水 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-42/\n单调队列问题 滑动窗口最大值 解法 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色），详见思想篇章\n题目 1. 滑动窗口最大值 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-239/\n用栈实现队列 解法 直接套栈实现队列模板即可，详见思想篇章\n题目 1. 用栈实现队列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-232/\n用队列实现栈 解法 直接套用队列实现栈的模板即可，详见思想篇章\n题目 1. 用队列实现栈 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-225/\n最小栈 解法 这道题的关键是getMin的实现，可以用一个辅助栈来存储每个元素入栈时的最小值，这样的话当元素出栈时也可以很容易的获取最小值\n题目 1. 最小栈 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-155/\n排序 快速选择 解法 详见题解\n题目 1. 数组中的第K个最大元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-215/\n2. 前 K 个高频元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-347/\n思想 双指针 就是两个指针，分为左右指针和快慢指针，只要数组有序，就应该想到双指针技巧\n左右指针 两个指针一个左一个右\n使用时一定要确定什么时候动左指针，什么时候动右指针，对于已排序的数组一般是相加的和，小了动左指针，大了动右指针\n二分查找 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度\n经典思路 public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } 这种就是一边缩减搜索空间，一边寻找要找的元素。\n但是有时候问题并不是这么简单，比如寻找一个可能在数组里不存在，或者是找边界这样的问题，这时使用进阶思路 ，在循环体内排除一定不存在目标元素的区间会更简单一些。\n经典思路是寻找元素\n进阶思路是排除n-1个不可能的元素\n进阶思路 class Solution { public int search(int[] nums, int target) { // 此思路搜索空间为[left, right]，闭闭空间 int left = 0, right = nums.length - 1; // 循环条件写成left\u0026lt;right，因为循环体内把数组分成两部分，那么一定会达到left和right重合的状态 // 所以循环条件写成left\u0026lt;right，可以保证退出循环时left等于right while (left \u0026lt; right) { // 求中点，left=mid+1时不需要向上取整 int mid = left + (right - left) / 2; // left=mid时需要向上取整，记忆方式：left和mid要有一个+1 // 这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left //int mid = left + (right - left + 1) / 2; // 下面是核心逻辑，分成两个区间是因为这样扩展性更强 // 这块主要就是筛选不可能的区间，然后缩减搜索空间，具体问题具体分析，注意left没加一时mid要加一 // 左边界，记忆方式：左边界是小于等于，下面的语句是...=mid，第二个语句和第一个语句互补，left没加一时mid要加一 /*if (target \u0026lt;= nums[mid]) { right = mid; } else { left = mid + 1; }*/ // 右边界 /*if (target \u0026gt;= nums[mid]) { left = mid; } else { right = mid -1; }*/ } // 此时left一定等于right，所以返回left或者right都一样 // 排除了n-1个不可能的元素，还剩下[left, right]区间的元素，而left=right，就看剩下这个是不是要寻找的元素了 // 如果该题一定存在指定的元素，那么下一步可以省略，直接return left就好了 /* 如果查找与target相等的值 */ if (nums[left] == target) { return -1; } /* 如果查找target的左侧边界 */ if (nums[left] \u0026lt; target) { return -1; } /* 如果查找target的右侧边界 */ if (nums[left] \u0026gt; target) { return -1; } return left; } } 步骤 left和right分别设置为搜索空间的左右端点，注意是闭区间 循环条件写成left\u0026lt;right 求中点，先写成int mid = left + (right - left) / 2; 根据具体问题将搜索空间分成两部分，其中一部分必须是不可能的区域，然后根据这个不可能区域的特征写出第一个if，然后else里写和if互补的区域就好了，注意如果结果是left=mid，上面求中点要改成int mid = left + (right - left + 1) / 2; 如果根据题意不能判断出一定存在寻找的元素，需要判断下nums[left]是不是寻找的元素，是则return left，否则未找到该元素；如果根据题意能判断出一定存在寻找的元素，那直接return left就好了 注意点 可以把这里的nums[i] = x看成一个函数，只要是具有单调性的函数都可以使用二分查找，比如y = func(x)，给定一个y让你找对应的x也可以用二分查找，二分查找的使用很广泛，只要函数有单调性即可 此思路搜索空间为[left, right]，闭闭空间 循环条件写成left\u0026lt;right，因为循环体内把数组分成两部分，并且根据left的取值选择mid是向上或向下取整，那么一定会达到left和right重合的状态（把所有情况都模拟一边就可以得出这个结论），所以循环条件写成left\u0026lt;right，可以保证退出循环时left等于right 求中点时，如果使用(left + right) / 2有可能相加溢出，为了防止溢出使用left + (right - left) / 2 求中点时，left=mid+1时不需要向下取整，left=mid时需要向上取整，记忆方式：left和mid要有一个+1。这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left。right=mid时需要向下取整，原因同理 把搜索空间分成两个区间是因为这样扩展性更强 缩减搜索空间时，将搜索空间分成两部分需要注意分出不可能的区间，然后缩减搜索空间，具体问题具体分析，根据这个不可能区间的特征写出第一个if，然后else里写和if互补的区域 注意left没加一时mid要加一 退出循环后left和right相等，并且是唯一有希望的元素（只是有希望，有可能不是它，还要再判断一下，如果该题一定存在指定的元素，那么直接return left就好了） 对于寻找左右侧边界的二分查找，在缩减搜索空间时一定要考虑\u0026gt;=或\u0026lt;=的情况，因为这样才能使用找左或右侧这个性质，比如target \u0026lt;= nums[mid]，可以寻找左边界，因为这时左边界不可能在mid右边所以直接right=mid就可以找到左边界，右边界同理。为什么找到的是左边界，因为此时，nums[mid]要么大于target，要么等于target，不管那种情况，左边界一定在mid处或mid左边，也可以这么理解：target \u0026lt;= nums[mid]-\u0026gt;right=mid，所以target \u0026gt; nums[mid]-\u0026gt;left=mid + 1，此时left左边全部都小于target，因为退出循环时如果能找到target，left指向的就是target，又因为left左边全部都小于target，所以此时left指向左边界。找右边界同理。 对于寻找左侧边界的二分查找，说是寻找该元素的左侧边界，实际上是寻找大于等于target的所有元素的左侧边界，同理，寻找右侧边界的二分查找实际上是寻找小于等于target的所有元素的右侧边界，也可以理解成左侧边界的左边都小于target右边都大于等于target，右侧边界的右边都大于target左边都小于等于target，并且左右边界不一定等于target，所以如果target不存在时，左边界是比target大的第一个元素，右边界是比target小的第一个元素 详见：leetcode笔记word版和https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/\n其他 见上面各知识点章节\n快慢指针 两个指针一个快一个慢\n滑动窗口 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n模板 /* 滑动窗口算法模板 */ void slidingWindow(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素，所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { // 获取移入窗口的元素，并扩大窗口 char c = s.charAt(right); right++; // 进行扩大窗口时数据的一系列更新 ... // debug位置 // System.out.println(\u0026#34;left:\u0026#34; + left + \u0026#34;\\t\u0026#34; + \u0026#34;right:\u0026#34; + right); // 判断左侧窗口是否要收缩 while (window needs shrink) { // 获取移出窗口的元素，并收缩窗口 char d = s.charAt(left); left++; // 进行收缩窗口时数据的一系列更新，一般与上面扩大窗口时数据更新相反 ... } } } 步骤 设置存储窗口内元素的数据结构，并且设置循环while (right \u0026lt; s.length()) 扩大窗口，并更新相关的数据 判断是否需要收缩窗口，如需要，则收缩窗口，并更新相关的数据 退出循环后，返回相应的数据 注意点 此模板采用闭开区间，循环条件用\u0026lt;而不用\u0026lt;=是因为right当前位置的元素是我们下一个要入窗口的元素 收缩窗口和扩大窗口对数据的更新一般是相反的（更新顺序和加减等都是相反的） 详见：https://labuladong.gitee.io/algo/2/20/27/\n进阶 ==RABIN KARP 字符匹配算法==，详见：https://labuladong.gitee.io/algo/2/20/28/\n其他 见上面各知识点章节\n递归 一个问题 = 规模更小的同类问题 + 扩展成该问题要解决的问题\n这种情况就可以用递归，递归的关键是不要跳进递归，而是明确递归函数的定义\n递归由两部分组成：递归出口和递归公式\n注意递归需要递归出口（也就是base case）\n值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。\n前缀和与差分 前缀和数组的差分是原数组，差分数组的前缀和是原数组，两者互逆。\n前缀和 对于一个数组，求此数组[left, right]区域内的和时，不需要从left\u0026ndash;right逐个相加，直接right+1前的和减去left前的和即可，要想使用这种方式就得有一个前缀和数组，用来存该数组前k个的和。注意也可能是二维数组，稍作修改即可。\n主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。\n详见：https://labuladong.gitee.io/algo/2/20/24/\n标准模板 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } 二维前缀和，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/\n差分数组 差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减\n类似前缀和构造的 preSum 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差，通过这个 diff 差分数组是可以反推出原始数组 nums 的，理解：diff[0]就是原数组的第一个元素，其他元素就是比前一个元素高多少\n这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可\n原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 又意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对 nums[i..j] 中的所有元素都加 3 了\n详见：https://labuladong.gitee.io/algo/2/20/25/\n标准模板 class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[i] - nums[i-1]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } 二维差分数组，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-周赛-328/\n二叉树 前中后序理解 前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点：\n前序位置的代码在刚刚进入一个二叉树节点的时候执行；\n后序位置的代码在将要离开一个二叉树节点的时候执行；\n中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。\n比如快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历\n遍历模板 void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 } 多叉树的遍历模板：\n/* 多叉树遍历框架 */ void traverse(TreeNode root) { if (root == null) return; // 前序位置 for (TreeNode child : root.children) { traverse(child); } // 后序位置 } 做题思路 有两种思路，分别是分解问题和遍历二叉树\n遇到一道二叉树的题目时的通用思考过程是：\n1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。\n2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)，这样的话递归函数就会一直分解这个问题，直到该问题不能再分解，所以我们还需要考虑base case(递归出口)。\n3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n后序位置的特殊之处 因为前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的，所以：\n前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。\n层序遍历 就是一个BFS，可以计算一些类似结点与root之间的距离的问题。\n模板 // 输入一棵二叉树的根节点，层序遍历这棵二叉树 void levelTraverse(TreeNode root) { if (root == null) return; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); // 从上到下遍历二叉树的每一层 while (!q.isEmpty()) { int sz = q.size(); // 从左到右遍历每一层的每个节点 for (int i = 0; i \u0026lt; sz; i++) { TreeNode cur = q.poll(); // 将下一层节点放入队列 if (cur.left != null) { // 注意不要把null放队列里面 q.offer(cur.left); } if (cur.right != null) { // 注意不要把null放队列里面 q.offer(cur.right); } } } } 注意点 前序中序，后序中序可以唯一确定一颗二叉树，或者带空指针的任意一个遍历序列都可以唯一确定一棵二叉树\n前序后序不能唯一确定一颗二叉树，因为：\n当节点左右子树都存在时，可以确定左右子树，但是当其中一个为空时，无法确定不为空的子树是左子树还是右子树\n二叉搜索树 性质 二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列，并且中序遍历到一个结点时，比该结点小的结点全部都遍历过了，这个性质可以用于二叉搜索树的累加上，二叉搜索树最左边是最小的结点，最右边是最大的结点\n合法性 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去，如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。\n增删改查 在二叉树递归框架之上，扩展出一套 BST 代码框架：\nvoid BST(TreeNode root, int target) { if (root.val == target) // 找到目标，做点什么 if (root.val \u0026lt; target) BST(root.right, target); if (root.val \u0026gt; target) BST(root.left, target); } 根据代码框架掌握了 BST 的增删查改操作。\n图 存储方式 邻接表 优点：省空间\n// 邻接表 // graph[x] 存储 x 的所有邻居节点以及对应的权重 List\u0026lt;int[]\u0026gt;[] graph; 邻接矩阵 优点：可以随机访问\n// 邻接矩阵 // matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻 int[][] matrix; 遍历模板 DFS 和多叉树类似，只不过需要记录访问过的结点\n// 记录被遍历过的节点 boolean[] visited; // 记录从起点到当前节点的路径 boolean[] onPath; /* 图遍历框架 */ void traverse(Graph graph, int s) { if (visited[s]) return; // 进入结点时 // 经过节点 s，标记为已遍历 visited[s] = true; // 做选择：标记节点 s 在路径上 onPath[s] = true; for (int neighbor : graph.neighbors(s)) { traverse(graph, neighbor); } // 离开结点时 // 撤销选择：节点 s 离开路径 onPath[s] = false; } BFS // 记录被遍历过的节点 boolean[] visited; void traverse(Graph graph, int s) { Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(s); while (!queue.isEmpty()) { int node = queue.poll(); visited[node] = true; for (int neighbor : graph.neighbors(s)) { if (!visited[neighbor]) { queue.offer(next); } } } } 图的拓扑排序 拓扑排序 直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的\n如果一个图里存在环，是无法进行拓扑排序的，反之，如果图里没有环那么一定可以拓扑排序\n注意有向无环图不一定是树\n如何拓扑排序 将后序遍历的结果进行反转，就是拓扑排序的结果。至于原因由于需要严格的数学证明，就不用看了，可以自己画个图看一看 利用图的BFS，每次只让入度为零的结点入队列，此时遍历的结果就是拓扑排序的结果 二分图 如图所示就是二分图，可以使用染色法判断一个图是否为二分图，如下所示：\n在某些场景下二分图也可以作为存储键值对的数据结构（符号表）\n判断二分图（染色）模板 其实就是图的遍历，只不过一边遍历一边染色\nDFS /* 判断二分图框架(DFS) */ private boolean[] color; private boolean[] visited; void traverse(Graph graph, int v) { visited[v] = true; // 遍历节点 v 的所有相邻节点 neighbor for (int neighbor : graph.neighbors(v)) { if (!visited[neighbor]) { // 相邻节点 neighbor 没有被访问过 // 那么应该给节点 neighbor 涂上和节点 v 不同的颜色 color[neighbor] = !color[v]; traverse(graph, neighbor); } else { // 相邻节点 neighbor 已经被访问过 // 那么应该比较节点 neighbor 和节点 v 的颜色 // 若相同，则此图不是二分图 } } } BFS /* 判断二分图框架(BFS) */ private boolean[] color; private boolean[] visited; void traverse(Graph graph, int start) { Deque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); visited[start] = true; queue.offer(start); while (!queue.isEmpty()) { int v = queue.poll(); // 从节点 v 向所有相邻节点扩散 for (int w : graph[v]) { if (!visited[w]) { // 相邻节点 w 没有被访问过 // 那么应该给节点 w 涂上和节点 v 不同的颜色 color[w] = !color[v]; // 标记 w 节点，并放入队列 visited[w] = true; queue.offer(w); } else { // 相邻节点 w 已经被访问过 // 根据 v 和 w 的颜色判断是否是二分图 if (color[w] == color[v]) { // 若相同，则此图不是二分图 return; } } } } } 并查集 就是可以1、方便的合并两个集合，2、快速的判断两个结点是否处于一个集合中的树状数据结构，长下面这个样子\n模板 class UF { // 连通分量个数 private int count; // 存储每个节点的父节点 private int[] parent; // n 为图中节点的个数 public UF(int n) { this.count = n; parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } // 将节点 p 和节点 q 连通 public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootQ] = rootP; // 两个连通分量合并成一个连通分量 count--; } // 判断节点 p 和节点 q 是否连通 public boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } // 返回图中的连通分量个数 public int count() { return count; } } 这里做了路径压缩的优化，在 find 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 size 数组的平衡优化。\ndijkstra问题 dijkstra是求最短路径的算法，实际上是由图的BFS演化而来，模板如下：\nclass State { // 图节点的 id int id; // 从 start 节点到当前节点的距离 int distFromStart; State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } // 返回节点 from 到节点 to 之间的边的权重 int weight(int from, int to); // 输入节点 s 返回 s 的相邻节点 List\u0026lt;Integer\u0026gt; adj(int s); // 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离 int[] dijkstra(int start, List\u0026lt;Integer\u0026gt;[] graph) { // 图中节点的个数 int V = graph.length; // 记录最短路径的权重，你可以理解为 dp table // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重 int[] distTo = new int[V]; // 求最小值，所以 dp table 初始化为正无穷 Arrays.fill(distTo, Integer.MAX_VALUE); // base case，start 到 start 的最短距离就是 0 distTo[start] = 0; // 优先级队列，distFromStart 较小的排在前面 Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.distFromStart - b.distFromStart; }); // 从起点 start 开始进行 BFS pq.offer(new State(start, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeID = curState.id; int curDistFromStart = curState.distFromStart; // 如果只需要start到end的最短距离加上这句就可以了 // if (curNodeID == end) { // return curDistFromStart; // } if (curDistFromStart \u0026gt; distTo[curNodeID]) { // 已经有一条更短的路径到达 curNode 节点了 continue; } // 将 curNode 的相邻节点装入队列 for (int nextNodeID : adj(curNodeID)) { // 看看从 curNode 达到 nextNode 的距离是否会更短 int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID); if (distTo[nextNodeID] \u0026gt; distToNextNode) { // 更新 dp table distTo[nextNodeID] = distToNextNode; // 将这个节点以及距离放入队列 pq.offer(new State(nextNodeID, distToNextNode)); } } } return distTo; } 解释：同一个结点可能会入队多个State，一定会先遍历到dist较小的那个，结点的第一次遍历，就确定了这个结点的最短距离，然后按照这个最短距离刷新start到其他节点的距离，之后这个结点的任务就算是结束了，以后再碰到这个结点直接continue就可以了。\n注意dijkstra的变种需要修改adj和weight函数\nkruskal问题 用于求解最小生成树问题，主要思路就是先把边按权重排序，从小到大添加边，同时判断边添加后是否有环（这一步可以用并查集做），模板如下：\nint minimumCost(int n, int[][] edges) { UF uf = new UF(n); // 对所有边按照权重从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; (a[2] - b[2])); // 记录最小生成树的权重之和 int mst = 0; for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; // 若这条边会产生环，则不能加入 mst if (uf.connected(u, v)) { continue; } // 若这条边不会产生环，则属于最小生成树 mst += weight; uf.union(u, v); } // 保证所有节点都被连通 // uf.count() == 1 说明所有节点被连通 return uf.count() == 1 ? mst : -1; } class UF { // 见上文并查集模板 } 详见：https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w\nprim问题 用于求解最小生成树问题，原理就是横切边中最小的一定是最小生成树的一条边，可以每次添加一个结点找横切边（这样比较方便），然后把最小生成树的边都找到就可以了，模板如下：\nclass Prim { // 核心数据结构，存储「横切边」的优先级队列 private PriorityQueue\u0026lt;int[]\u0026gt; pq; // 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分 private boolean[] inMST; // 记录最小生成树的权重和 private int weightSum = 0; // graph 是用邻接表表示的一幅图， // graph[s] 记录节点 s 所有相邻的边， // 三元组 int[]{from, to, weight} 表示一条边 private List\u0026lt;int[]\u0026gt;[] graph; public Prim(List\u0026lt;int[]\u0026gt;[] graph) { this.graph = graph; this.pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { // 按照边的权重从小到大排序 return a[2] - b[2]; }); // 图中有 n 个节点 int n = graph.length; this.inMST = new boolean[n]; // 随便从一个点开始切分都可以，我们不妨从节点 0 开始 inMST[0] = true; cut(0); // 不断进行切分，向最小生成树中添加边 while (!pq.isEmpty()) { int[] edge = pq.poll(); int to = edge[1]; int weight = edge[2]; if (inMST[to]) { // 节点 to 已经在最小生成树中，跳过 // 否则这条边会产生环 continue; } // 将边 edge 加入最小生成树 weightSum += weight; inMST[to] = true; // 节点 to 加入后，进行新一轮切分，会产生更多横切边 cut(to); } } // 将 s 的横切边加入优先队列 private void cut(int s) { // 遍历 s 的邻边 for (int[] edge : graph[s]) { int to = edge[1]; if (inMST[to]) { // 相邻接点 to 已经在最小生成树中，跳过 // 否则这条边会产生环 continue; } // 加入横切边队列 pq.offer(edge); } } // 最小生成树的权重和 public int weightSum() { return weightSum; } // 判断最小生成树是否包含图中的所有节点 public boolean allConnected() { for (int i = 0; i \u0026lt; inMST.length; i++) { if (!inMST[i]) { return false; } } return true; } } 详见：https://labuladong.gitee.io/algo/2/22/55/\n回溯 回溯和DFS的区别：\n回溯关注的是树枝，DFS关注的是结点，反映到代码上：\n// DFS 算法，关注点在节点 void traverse(TreeNode root) { if (root == null) return; printf(\u0026#34;进入节点 %s\u0026#34;, root); for (TreeNode child : root.children) { traverse(child); } printf(\u0026#34;离开节点 %s\u0026#34;, root); } // 回溯算法，关注点在树枝 void backtrack(TreeNode root) { if (root == null) return; for (TreeNode child : root.children) { // 做选择 printf(\u0026#34;从 %s 到 %s\u0026#34;, root, child); backtrack(child); // 撤销选择 printf(\u0026#34;从 %s 到 %s\u0026#34;, child, root); } } 设计数据结构 LRU 即Least Recently Used，也就是每次淘汰那些最久没被使用的数据，主要就是利用了哈希链表（在Java中是LinkedHashMap）这种数据结构，如下图所示：\n手写轮子模板：\nclass LRUCache { // key -\u0026gt; Node(key, val) private Map\u0026lt;Integer, Node\u0026gt; map; // Node(k1, v1) \u0026lt;-\u0026gt; Node(k2, v2)... private DoubleList cache; // 最大容量 private int capacity; public LRUCache(int capacity) { this.capacity = capacity; map = new HashMap\u0026lt;\u0026gt;(); cache = new DoubleList(); } public int get(int key) { if (!map.containsKey(key)) { return -1; } // 将该数据提升为最近使用的 makeRecently(key); return map.get(key).val; } public void put(int key, int val) { if (map.containsKey(key)) { // 删除旧的数据 deleteKey(key); // 新插入的数据为最近使用的数据 addRecently(key, val); return; } if (cap == cache.size()) { // 删除最久未使用的元素 removeLeastRecently(); } // 添加为最近使用的元素 addRecently(key, val); } /* 将某个 key 提升为最近使用的 */ private void makeRecently(int key) { Node x = map.get(key); // 先从链表中删除这个节点 cache.remove(x); // 重新插到队尾 cache.addLast(x); } /* 添加最近使用的元素 */ private void addRecently(int key, int val) { Node x = new Node(key, val); // 链表尾部就是最近使用的元素 cache.addLast(x); // 别忘了在 map 中添加 key 的映射 map.put(key, x); } /* 删除某一个 key */ private void deleteKey(int key) { Node x = map.get(key); // 从链表中删除 cache.remove(x); // 从 map 中删除 map.remove(key); } /* 删除最久未使用的元素 */ private void removeLeastRecently() { // 链表头部的第一个元素就是最久未使用的 Node deletedNode = cache.removeFirst(); // 同时别忘了从 map 中删除它的 key int deletedKey = deletedNode.key; map.remove(deletedKey); } class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class DoubleList { // 头尾虚节点 private Node head, tail; // 链表元素数 private int size; public DoubleList() { // 初始化双向链表的数据 head = new Node(0, 0); tail = new Node(0, 0); head.next = tail; tail.prev = head; size = 0; } // 在链表尾部添加节点 x，时间 O(1) public void addLast(Node x) { x.prev = tail.prev; x.next = tail; tail.prev.next = x; tail.prev = x; size++; } // 删除链表中的 x 节点（x 一定存在） // 由于是双链表且给的是目标 Node 节点，时间 O(1) public void remove(Node x) { x.prev.next = x.next; x.next.prev = x.prev; size--; } // 删除链表中第一个节点，并返回该节点，时间 O(1) public Node removeFirst() { if (size == 0) { return null; } Node first = head.next; remove(first); return first; } // 返回链表长度，时间 O(1) public int size() { return size; } } } 使用LinkedHashMap模板：\nclass LRUCache { int cap; LinkedHashMap\u0026lt;Integer, Integer\u0026gt; cache = new LinkedHashMap\u0026lt;\u0026gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() \u0026gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); } } LFU Least Frequently Used，也就是每次淘汰那些使用次数最少的数据，主要利用了keyToVal，keyToFreq，freqToKeys三个数据结构相互配合，详见：https://mp.weixin.qq.com/s/oXv03m1J8TwtHwMJEZ1ApQ，模板如下：\nclass LFUCache { // key 到 val 的映射，我们后文称为 KV 表 HashMap\u0026lt;Integer, Integer\u0026gt; keyToVal; // key 到 freq 的映射，我们后文称为 KF 表 HashMap\u0026lt;Integer, Integer\u0026gt; keyToFreq; // freq 到 key 列表的映射，我们后文称为 FK 表 HashMap\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; // 记录最小的频次 int minFreq; // 记录 LFU 缓存的最大容量 int cap; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.cap = capacity; this.minFreq = 0; } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } // 增加 key 对应的 freq increaseFreq(key); return keyToVal.get(key); } public void put(int key, int val) { if (this.cap \u0026lt;= 0) return; /* 若 key 已存在，修改对应的 val 即可 */ if (keyToVal.containsKey(key)) { keyToVal.put(key, val); // key 对应的 freq 加一 increaseFreq(key); return; } /* key 不存在，需要插入 */ /* 容量已满的话需要淘汰一个 freq 最小的 key */ if (this.cap \u0026lt;= keyToVal.size()) { removeMinFreqKey(); } /* 插入 key 和 val，对应的 freq 为 1 */ // 插入 KV 表 keyToVal.put(key, val); // 插入 KF 表 keyToFreq.put(key, 1); // 插入 FK 表 freqToKeys.putIfAbsent(1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(1).add(key); // 插入新 key 后最小的 freq 肯定是 1 this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); /* 更新 KF 表 */ keyToFreq.put(key, freq + 1); /* 更新 FK 表 */ // 将 key 从 freq 对应的列表中删除 freqToKeys.get(freq).remove(key); // 将 key 加入 freq + 1 对应的列表中 freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(freq + 1).add(key); // 如果 freq 对应的列表空了，移除这个 freq if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); // 如果这个 freq 恰好是 minFreq，更新 minFreq if (freq == this.minFreq) { this.minFreq++; } } } private void removeMinFreqKey() { // freq 最小的 key 列表 LinkedHashSet\u0026lt;Integer\u0026gt; keyList = freqToKeys.get(this.minFreq); // 其中最先被插入的那个 key 就是该被淘汰的 key int deletedKey = keyList.iterator().next(); /* 更新 FK 表 */ keyList.remove(deletedKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 问：这里需要更新 minFreq 的值吗？ // 这里不用修改minFreq因为后面会置为1 } /* 更新 KV 表 */ keyToVal.remove(deletedKey); /* 更新 KF 表 */ keyToFreq.remove(deletedKey); } } TrieMap和TrieSet Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。结构如下所示：\n底层是Trie树的Map就是TrieMap，TrieMap就是key是字符串，value是任何类型的map，TrieSet就是没用到value的TrieMap，详见：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==\u0026amp;mid=2247495471\u0026amp;idx=1\u0026amp;sn=fd180d7e207e92a87a9c9cce69b8cdb9\nTrieMap模板如下：\nclass TrieMap\u0026lt;V\u0026gt; { // ASCII 码个数 private static final int R = 256; // 当前存在 Map 中的键值对个数 private int size = 0; // Trie 树的根节点 private TrieNode\u0026lt;V\u0026gt; root = null; private static class TrieNode\u0026lt;V\u0026gt; { V val = null; TrieNode\u0026lt;V\u0026gt;[] children = new TrieNode[R]; } /***** 增/改 *****/ // 在 map 中添加或修改键值对 public void put(String key, V val) { if (!containsKey(key)) { // 新增键值对 size++; } // 需要一个额外的辅助函数，并接收其返回值 root = put(root, key, val, 0); } // 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点 private TrieNode\u0026lt;V\u0026gt; put(TrieNode\u0026lt;V\u0026gt; node, String key, V val, int i) { if (node == null) { // 如果树枝不存在，新建 node = new TrieNode\u0026lt;\u0026gt;(); } if (i == key.length()) { // key 的路径已插入完成，将值 val 存入节点 node.val = val; return node; } char c = key.charAt(i); // 递归插入子节点，并接收返回值 node.children[c] = put(node.children[c], key, val, i + 1); return node; } /***** 删 *****/ // 在 Map 中删除 key public void remove(String key) { if (!containsKey(key)) { return; } // 递归修改数据结构要接收函数的返回值 root = remove(root, key, 0); size--; } // 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点 private TrieNode\u0026lt;V\u0026gt; remove(TrieNode\u0026lt;V\u0026gt; node, String key, int i) { if (node == null) { return null; } if (i == key.length()) { // 找到了 key 对应的 TrieNode，删除 val node.val = null; } else { char c = key.charAt(i); // 递归去子树进行删除 node.children[c] = remove(node.children[c], key, i + 1); } // 后序位置，递归路径上的节点可能需要被清理 if (node.val != null) { // 如果该 TireNode 存储着 val，不需要被清理 return node; } // 检查该 TrieNode 是否还有后缀 for (int c = 0; c \u0026lt; R; c++) { if (node.children[c] != null) { // 只要存在一个子节点（后缀树枝），就不需要被清理 return node; } } // 既没有存储 val，也没有后缀树枝，则该节点需要被清理 return null; } /***** 查 *****/ // 搜索 key 对应的值，不存在则返回 null public V get(String key) { // 从 root 开始搜索 key TrieNode\u0026lt;V\u0026gt; x = getNode(root, key); if (x == null || x.val == null) { // x 为空或 x 的 val 字段为空都说明 key 没有对应的值 return null; } return x.val; } // 判断 key 是否存在在 Map 中 public boolean containsKey(String key) { return get(key) != null; } // 判断是和否存在前缀为 prefix 的键 public boolean hasKeyWithPrefix(String prefix) { // 只要能找到一个节点，就是存在前缀 return getNode(root, prefix) != null; } // 在所有键中寻找 query 的最短前缀 public String shortestPrefixOf(String query) { TrieNode\u0026lt;V\u0026gt; p = root; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; query.length(); i++) { if (p == null) { // 无法向下搜索 return \u0026#34;\u0026#34;; } if (p.val != null) { // 找到一个键是 query 的前缀 return query.substring(0, i); } // 向下搜索 char c = query.charAt(i); p = p.children[c]; } if (p != null \u0026amp;\u0026amp; p.val != null) { // 如果 query 本身就是一个键 return query; } return \u0026#34;\u0026#34;; } // 在所有键中寻找 query 的最长前缀 public String longestPrefixOf(String query) { TrieNode\u0026lt;V\u0026gt; p = root; // 记录前缀的最大长度 int max_len = 0; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; query.length(); i++) { if (p == null) { // 无法向下搜索 break; } if (p.val != null) { // 找到一个键是 query 的前缀，更新前缀的最大长度 max_len = i; } // 向下搜索 char c = query.charAt(i); p = p.children[c]; } if (p != null \u0026amp;\u0026amp; p.val != null) { // 如果 query 本身就是一个键 return query; } return query.substring(0, max_len); } // 搜索前缀为 prefix 的所有键 public List\u0026lt;String\u0026gt; keysWithPrefix(String prefix) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); // 找到匹配 prefix 在 Trie 树中的那个节点 TrieNode\u0026lt;V\u0026gt; x = getNode(root, prefix); if (x == null) { return res; } // DFS 遍历以 x 为根的这棵 Trie 树 traverse(x, new StringBuilder(prefix), res); return res; } // 遍历以 node 节点为根的 Trie 树，找到所有键 private void traverse(TrieNode\u0026lt;V\u0026gt; node, StringBuilder path, List\u0026lt;String\u0026gt; res) { if (node == null) { // 到达 Trie 树底部叶子结点 return; } if (node.val != null) { // 找到一个 key，添加到结果列表中 res.add(path.toString()); } // 回溯算法遍历框架 for (char c = 0; c \u0026lt; R; c++) { // 做选择 path.append(c); traverse(node.children[c], path, res); // 撤销选择 path.deleteCharAt(path.length() - 1); } } // 通配符 . 匹配任意字符 public List\u0026lt;String\u0026gt; keysWithPattern(String pattern) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); traverse(root, new StringBuilder(), pattern, 0, res); return res; } // 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..] private void traverse(TrieNode\u0026lt;V\u0026gt; node, StringBuilder path, String pattern, int i, List\u0026lt;String\u0026gt; res) { if (node == null) { // 树枝不存在，即匹配失败 return; } if (i == pattern.length()) { // pattern 匹配完成 if (node.val != null) { // 如果这个节点存储着 val，则找到一个匹配的键 res.add(path.toString()); } return; } char c = pattern.charAt(i); if (c == \u0026#39;.\u0026#39;) { // pattern[i] 是通配符，可以变化成任意字符 // 多叉树（回溯算法）遍历框架 for (char j = 0; j \u0026lt; R; j++) { path.append(j); traverse(node.children[j], path, pattern, i + 1, res); path.deleteCharAt(path.length() - 1); } } else { // pattern[i] 是普通字符 c path.append(c); traverse(node.children[c], path, pattern, i + 1, res); path.deleteCharAt(path.length() - 1); } } // 判断是和否存在前缀为 prefix 的键 public boolean hasKeyWithPattern(String pattern) { // 从 root 节点开始匹配 pattern[0..] return hasKeyWithPattern(root, pattern, 0); } // 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配 private boolean hasKeyWithPattern(TrieNode\u0026lt;V\u0026gt; node, String pattern, int i) { if (node == null) { // 树枝不存在，即匹配失败 return false; } if (i == pattern.length()) { // 模式串走到头了，看看匹配到的是否是一个键 return node.val != null; } char c = pattern.charAt(i); // 没有遇到通配符 if (c != \u0026#39;.\u0026#39;) { // 从 node.children[c] 节点开始匹配 pattern[i+1..] return hasKeyWithPattern(node.children[c], pattern, i + 1); } // 遇到通配符 for (int j = 0; j \u0026lt; R; j++) { // pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回 if (hasKeyWithPattern(node.children[j], pattern, i + 1)) { return true; } } // 都没有匹配 return false; } // 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null private TrieNode\u0026lt;V\u0026gt; getNode(TrieNode\u0026lt;V\u0026gt; node, String key) { TrieNode\u0026lt;V\u0026gt; p = node; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; key.length(); i++) { if (p == null) { // 无法向下搜索 return null; } // 向下搜索 char c = key.charAt(i); p = p.children[c]; } return p; } public int size() { return size; } } TrieSet模板如下：\nclass TrieSet { // 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用 // 值的类型可以随便设置，我参考 Java 标准库设置成 Object private final TrieMap\u0026lt;Object\u0026gt; map = new TrieMap\u0026lt;\u0026gt;(); /***** 增 *****/ // 在集合中添加元素 key public void add(String key) { map.put(key, new Object()); } /***** 删 *****/ // 从集合中删除元素 key public void remove(String key) { map.remove(key); } /***** 查 *****/ // 判断元素 key 是否存在集合中 public boolean contains(String key) { return map.containsKey(key); } // 在集合中寻找 query 的最短前缀 public String shortestPrefixOf(String query) { return map.shortestPrefixOf(query); } // 在集合中寻找 query 的最长前缀 public String longestPrefixOf(String query) { return map.longestPrefixOf(query); } // 在集合中搜索前缀为 prefix 的所有元素 public List\u0026lt;String\u0026gt; keysWithPrefix(String prefix) { return map.keysWithPrefix(prefix); } // 判断集合中是否存在前缀为 prefix 的元素 public boolean hasKeyWithPrefix(String prefix) { return map.hasKeyWithPrefix(prefix); } // 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素 public List\u0026lt;String\u0026gt; keysWithPattern(String pattern) { return map.keysWithPattern(pattern); } // 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素 public boolean hasKeyWithPattern(String pattern) { return map.hasKeyWithPattern(pattern); } // 返回集合中元素的个数 public int size() { return map.size(); } } 单调栈 就是元素单调递增或递减的栈，比如单减栈，入栈的时候将小于入栈元素的栈顶出栈，就可以保证栈的单调递减，一般可以用在「下一个更大元素」，「上一个更小元素」等问题上，「下一个更大元素」模板如下：\nint[] nextGreaterElement(int[] nums) { int n = nums.length; // 存放答案的数组 int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); // 倒着往栈里放 for (int i = n - 1; i \u0026gt;= 0; i--) { // 判定个子高矮 while (!s.isEmpty() \u0026amp;\u0026amp; s.peek() \u0026lt;= nums[i]) { // 矮个起开，反正也被挡着了。。。 s.pop(); } // nums[i] 身后的更大元素 res[i] = s.isEmpty() ? -1 : s.peek(); s.push(nums[i]); } return res; } 单调队列 就是元素单调递增或递减的队列，比如单减队列，入队的时候将小于入队元素的队尾出队，就可以保证队的单调递减，一般可以用在「滑动窗口最大值」问题上，模板如下：\n/* 单调队列的实现 */ class MonotonicQueue { LinkedList\u0026lt;Integer\u0026gt; maxq = new LinkedList\u0026lt;\u0026gt;(); public void push(int n) { // 将小于 n 的元素全部删除 while (!maxq.isEmpty() \u0026amp;\u0026amp; maxq.getLast() \u0026lt; n) { maxq.pollLast(); } // 然后将 n 加入尾部 maxq.addLast(n); } public int max() { return maxq.getFirst(); } public void poll(int n) { if (n == maxq.getFirst()) { maxq.pollFirst(); } } } 二叉堆 就是最大堆或最小堆，是一颗完全二叉树，所以可以放在数组里面，用简单的计算就能得到结点的父节点和左右孩子，基于二叉堆开发出了优先队列，优先队列插入时将插入结点放到数组最后面然后对该节点执行上浮操作，删除时将堆顶删除，然后将数组最后面的结点放到堆顶的位置，然后对堆顶做下沉操作。模板如下：\n通用版 public class MaxPQ \u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { // 存储元素的数组 private Key[] pq; // 当前 Priority Queue 中的元素个数 private int size = 0; public MaxPQ(int cap) { // 索引 0 不用，所以多分配一个空间 pq = (Key[]) new Comparable[cap + 1]; } /* 返回当前队列中最大元素 */ public Key max() { return pq[1]; } /* 插入元素 e */ public void insert(Key e) { size++; // 先把新元素加到最后 pq[size] = e; // 然后让它上浮到正确的位置 swim(size); } /* 删除并返回当前队列中最大元素 */ public Key delMax() { // 最大堆的堆顶就是最大元素 Key max = pq[1]; // 把这个最大元素换到最后，删除之 swap(1, size); pq[size] = null; size--; // 让 pq[1] 下沉到正确位置 sink(1); return max; } /* 上浮第 x 个元素，以维护最大堆性质 */ private void swim(int x) { // 如果浮到堆顶，就不能再上浮了 while (x \u0026gt; 1 \u0026amp;\u0026amp; less(parent(x), x)) { // 如果第 x 个元素比上层大 // 将 x 换上去 swap(parent(x), x); x = parent(x); } } /* 下沉第 x 个元素，以维护最大堆性质 */ private void sink(int x) { // 如果沉到堆底，就沉不下去了 while (left(x) \u0026lt;= size) { // 先假设左边节点较大 int max = left(x); // 如果右边节点存在，比一下大小 if (right(x) \u0026lt;= size \u0026amp;\u0026amp; less(max, right(x))) max = right(x); // 结点 x 比俩孩子都大，就不必下沉了 if (less(max, x)) break; // 否则，不符合最大堆的结构，下沉 x 结点 swap(x, max); x = max; } } /* 交换数组的两个元素 */ private void swap(int i, int j) { Key temp = pq[i]; pq[i] = pq[j]; pq[j] = temp; } /* pq[i] 是否比 pq[j] 小？ */ private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) \u0026lt; 0; } // 父节点的索引 private int parent(int root) { return root / 2; } // 左孩子的索引 private int left(int root) { return root * 2; } // 右孩子的索引 private int right(int root) { return root * 2 + 1; } } 整形版 class MaxPQ { private int[] nums; private int size = 0; private int capacity; public MaxPQ(int capacity) { this.capacity = capacity; nums = new int[capacity + 1]; } public boolean isEmpty() { return size == 0; } public boolean isFull() { return size == capacity; } public int max() { return nums[1]; } private int parent(int root) { return root / 2; } private int left(int root) { return root * 2; } private int right(int root) { return root * 2 + 1; } private void swap(int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } public void insert(int num) { size++; nums[size] = num; swim(size); } public int delMax() { int max = nums[1]; nums[1] = nums[size]; size--; sink(1); return max; } private void swim(int x) { while (x \u0026gt; 1 \u0026amp;\u0026amp; nums[x] \u0026gt; nums[parent(x)]) { swap(x, parent(x)); x = parent(x); } } private void sink(int x) { while (left(x) \u0026lt;= size) { int max = left(x); if (right(x) \u0026lt;= size \u0026amp;\u0026amp; nums[right(x)] \u0026gt; nums[max]) { max = right(x); } if (nums[x] \u0026gt; nums[max]) { break; } swap(x, max); x = max; } } } 无类版 private void buildHeap(int[] heap) { int size = heap.length - 1; for (int i = size / 2; i \u0026gt;= 1; i--) { sink(heap, i); } } private void sink(int[] heap, int x) { int size = heap.length - 1; while (x * 2 \u0026lt;= size) { int min = x * 2; if (x * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; heap[x * 2 + 1] \u0026lt; heap[min]) { min = x * 2 + 1; } if (heap[x] \u0026lt; heap[min]) { break; } swap(heap, x, min); x = min; } } private void swap(int[] heap, int i, int j) { int temp = heap[i]; heap[i] = heap[j]; heap[j] = temp; } 队列实现栈以及栈实现队列 栈实现队列用两个栈即可，入栈相当于入队，出栈时先将一个栈里的元素出栈到另一个栈中，栈顶就是队头，模板如下：\nclass MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } /** 添加元素到队尾 */ public void push(int x) { s1.push(x); } /** 返回队头元素 */ public int peek() { if (s2.isEmpty()) // 把 s1 元素压入 s2 while (!s1.isEmpty()) s2.push(s1.pop()); return s2.peek(); } /** 删除队头的元素并返回 */ public int pop() { // 先调用 peek 保证 s2 非空 peek(); return s2.pop(); } /** 判断队列是否为空 */ public boolean empty() { return s1.isEmpty() \u0026amp;\u0026amp; s2.isEmpty(); } } 栈实现队列简单粗暴，pop的时候把除了队尾的其他都出队再加入到队尾即可，模板如下：\nclass MyStack { Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); int top_elem = 0; /** 添加元素到栈顶 */ public void push(int x) { // x 是队列的队尾，是栈的栈顶 q.offer(x); top_elem = x; } /** 返回栈顶元素 */ public int top() { return top_elem; } /** 删除栈顶的元素并返回 */ public int pop() { int size = q.size(); // 留下队尾 2 个元素 while (size \u0026gt; 2) { q.offer(q.poll()); size--; } // 记录新的队尾元素 top_elem = q.peek(); q.offer(q.poll()); // 删除之前的队尾元素 return q.poll(); } /** 判断栈是否为空 */ public boolean empty() { return q.isEmpty(); } } 排序 快速排序 快速排序的确定中枢位置的过程叫做快速选择，可以快速确定一个数在排序以后的位置，模板如下：\n/** * @Description 一趟快速排序：將序列分片，基准元素左边的都是小于它的，右边的都是大于它的 * @Param [arr, left, right] */ public static int partition(int[] arr, int left, int right){ int pivot = arr[left]; // 选取第一个为基准元素 while(left\u0026lt;right){ /* 先从右往左移动，直到遇见小于 pivot 的元素 */ while (left\u0026lt;right \u0026amp;\u0026amp; arr[right]\u0026gt;=pivot){ right--; } arr[left] = arr[right]; // 记录小于 pivot 的值 /* 再从左往右移动，直到遇见大于 pivot 的元素 */ while(left\u0026lt;right \u0026amp;\u0026amp; arr[left]\u0026lt;=pivot){ left++; } arr[right] = arr[left]; // 记录大于 pivot 的值 } arr[left] = pivot; // 记录基准元素到当前指针指向的区域 return left;\t// 返回基准元素的索引 } 快速选择可以解决数组中的第K个最大元素这种问题\n快速排序模板如下：\npublic static void quickSort(int[] arr, int left, int right){ if (left \u0026lt; right){ // 把数组分块 int pivot = partition(arr, left, right); // 基准元素左边递归 quickSort(arr, left, pivot-1); // 基准元素右边递归 quickSort(arr, pivot+1, right); } } public static int partition(int[] arr, int left, int right){ int pivot = arr[left]; // 选取第一个为基准元素 while(left\u0026lt;right){ /* 先从右往移动，直到遇见小于 pivot 的元素 */ while (left\u0026lt;right \u0026amp;\u0026amp; arr[right]\u0026gt;=pivot){ right--; } arr[left] = arr[right]; // 记录小于 pivot 的值 /* 再从左往右移动，直到遇见大于 pivot 的元素 */ while(left\u0026lt;right \u0026amp;\u0026amp; arr[left]\u0026lt;=pivot){ left++; } arr[right] = arr[left]; // 记录大于 pivot 的值 } arr[left] = pivot; // 记录基准元素到当前指针指向的区域 return left;\t// 返回基准元素的索引 } 其他 零碎 从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。\n数据结构的物理存储方式就是链式和顺序两种，基本操作就是增删改查，遍历方式无非迭代和递归。\n计算机算法的本质就是枚举，只不过这里枚举需要做到两个方面：无遗漏和无冗余，有时候还可以利用一些定理进行优化（缩小搜索范围），比如剪枝和数学定理\n难点在无遗漏的问题：\n难点在无冗余的问题：递归类问题（动态规划）\n难点在优化的问题：非递归类问题（并查集，贪心，KMP）\nJava里优先队列就是二叉堆，也就是PriorityQueue\nbase case就是最基本的情况，从递归的角度理解就是递归出口，从分解问题(分治)的角度理解就是最基本的问题（不能再分了）\n如果需要通过值找到其在数组的索引，将数组遍历一遍是一种做法，还可以创建一个valToIndex的hashmap\n序列化就是把结构化的数据（比如树）打平（比如转换为字符串）\n序列化和反序列化的目的：以某种特定格式组织数据，使得数据可以独立于编程语言。\nBoyer-Moore(摩尔) 投票算法详见：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/\n负数取余得到的结果还是负数\n注意二分查找的左边界是第一个大于等于target的数，右边界是从右往左第一个小于等于target的数\npython里自带了二分查找左边界和右边界的函数，Java里有基本版的二分查找\n看到「最大化最小值」或者「最小化最大值」（其实就是那种要求一堆数字尽量平均的题）就要想到二分答案，这是一个固定的套路。为什么？一般来说，二分的值越大，越能/不能满足要求；二分的值越小，越不能/能满足要求，有单调性，可以二分。\n前缀和中preSum[i + 1]是[0\u0026hellip;i]的元素之和\n差分数组的前缀和就是原数组\n待做 https://labuladong.gitee.io/algo/1/3/的那几个算法框架及之后的几个框架文章都没看\nhttps://labuladong.gitee.io/algo/2/21/41/没看\nhttps://labuladong.gitee.io/algo/2/21/45/没看\nhttps://labuladong.gitee.io/algo/2/22/57/没看\nhttps://labuladong.gitee.io/algo/2/23/67/没看\nhttps://labuladong.gitee.io/algo/2/20/29/没看\n技巧 dummy（虚拟头结点)：可以很好的避免第一个节点的特殊性，将第一个节点当作第二个节点，也即是所有节点统一处理\n把 return 语句都放在函数开头，因为一般 return 语句都是 base case，集中放在一起可以让算法结构更清晰。\n将二维坐标映射到一维的常用技巧：将二维坐标 (x,y) 转换成 x * n + y 这个数（m 是棋盘的行数，n 是棋盘的列数）\n方向数组 d 是上下左右搜索的常用手法：int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};\n学习方法 以后做题，先想这道题考察什么知识点。\n","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/","summary":"链表 合并两个有序链表 解法 略 题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetc","title":"LeetCode Note 1"},{"content":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n代码 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.next = p; p2 = p2.next; } ListNode temp = p.next; p.next = null; p = temp; } p1.next = dummy2.next; return dummy1.next; } References 1. 分隔链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-86/","summary":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。 代码 class","title":"LeetCode 86"},{"content":"思路 两种思路：\n迭代 不解释\n递归 不解释\n代码 迭代 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2 != null) { p.next = list2; } return dummy.next; } } 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) { return list2; } else if (list2 == null) { return list1; } if (list1.val \u0026lt; list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } References 1. 合并两个有序链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-21/","summary":"思路 两种思路： 迭代 不解释 递归 不解释 代码 迭代 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p","title":"LeetCode 21"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://blog.zhangmengyang.tk/en/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文","title":"🤝友链"},{"content":"about me\nname: ZMY occupation: Postgraduate student hobby: coding、game、wangshangchonglang ","permalink":"https://blog.zhangmengyang.tk/en/about/","summary":"about me name: ZMY occupation: Postgraduate student hobby: coding、game、wangshangchonglang","title":"🙋🏻‍♂️about"}]