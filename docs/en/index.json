[{"content":"思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的\u0026rsquo;O\u0026rsquo;相连的\u0026rsquo;O\u0026rsquo;加入到dummy的集合中，然后遍历一遍二维数组，将不在dummy集合里的\u0026rsquo;O\u0026rsquo;改成\u0026rsquo;X\u0026rsquo;即可\n代码 class Solution { public void solve(char[][] board) { int m = board.length; int n = board[0].length; UF uf = new UF(m * n + 1); int dummy = m * n; for (int i = 0; i \u0026lt; m; i++) { if (board[i][0] == \u0026#39;O\u0026#39;) { uf.union(dummy,i * n); } if (board[i][n - 1] == \u0026#39;O\u0026#39;) { uf.union(dummy,i * n + n - 1); } } for (int i = 0; i \u0026lt; n; i++) { if (board[0][i] == \u0026#39;O\u0026#39;) { uf.union(dummy, i); } if (board[m - 1][i] == \u0026#39;O\u0026#39;) { uf.union(dummy, (m - 1) * n + i); } } int[][] d = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; for (int i = 1; i \u0026lt; m - 1; i++) { for (int j = 1; j \u0026lt; n - 1; j++) { if (board[i][j] == \u0026#39;O\u0026#39;) { for (int k = 0; k \u0026lt; 4; k++) { int x = i + d[k][0]; int y = j + d[k][1]; if (board[x][y] == \u0026#39;O\u0026#39;) { uf.union(i * n + j, x * n + y); } } } } } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (!uf.isConnected(i * n + j, dummy)) { board[i][j] = \u0026#39;X\u0026#39;; } } } } class UF { private int[] parent; private int count; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } count = n; } public int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int xRoot = find(x); int yRoot = find(y); if (xRoot == yRoot) { return; } parent[xRoot] = yRoot; count--; } public boolean isConnected(int x, int y) { int xRoot = find(x); int yRoot = find(y); return xRoot == yRoot; } public int getCount() { return count; } } } References 1. 被围绕的区域 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-130/","summary":"思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的\u0026rsquo;O\u0026rsquo;相连的\u0026rsquo;O\u0026rsquo;加入到dum","title":"LeetCode 130"},{"content":"思路 经典二分图判断，只不过需要先构造一个图，详见思想章节\n代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(n, dislikes); for (int i = 1; i \u0026lt;= n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int n, int[][] dislikes) { List\u0026lt;Integer\u0026gt;[] graph = new List[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] dislike : dislikes) { int s = dislike[0]; int d = dislike[1]; graph[s].add(d); graph[d].add(s); } return graph; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int v) { if (!ok) { return; } visited[v] = true; for (int neighbor : graph[v]) { if (!visited[neighbor]) { color[neighbor] = !color[v]; traverse(graph, neighbor); } else { if (color[v] == color[neighbor]) { ok = false; return; } } } } } References 1. 可能的二分法 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-886/","summary":"思路 经典二分图判断，只不过需要先构造一个图，详见思想章节 代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(n, dislikes); for (int","title":"LeetCode 886"},{"content":"思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节\n代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color = new boolean[n]; visited = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private void traverse(int[][] graph, int v) { if (!ok) { return; } visited[v] = true; for (int neighbor : graph[v]) { if (!visited[neighbor]) { color[neighbor] = !color[v]; traverse(graph, neighbor); } else { if (color[v] == color[neighbor]) { ok = false; return; } } } } } BFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color = new boolean[n]; visited = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private void traverse(int[][] graph, int start) { if (!ok) { return; } Deque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); visited[start] = true; queue.offer(start); while (!queue.isEmpty() \u0026amp;\u0026amp; ok) { int v = queue.poll(); for (int n : graph[v]) { if (!visited[n]) { color[n] = !color[v]; visited[n] = true; queue.offer(n); } else { if (color[n] == color[v]) { ok = false; return; } } } } } } References 1. 判断二分图 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-785/","summary":"思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节 代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color","title":"LeetCode 785"},{"content":"思路 寻找可行的选课顺序其实就是计算拓扑排序\n思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序\n思路二 利用图的BFS，只不过只把入度为零的结点加入队列，队列出队的序列就是该图的拓扑排序\n代码 思路一 class Solution { private boolean[] visited; private boolean[] onPath; private boolean hasCycle = false; private List\u0026lt;Integer\u0026gt; postorder = new LinkedList\u0026lt;\u0026gt;(); public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i]) { traverse(graph, i); } } if (hasCycle) { return new int[0]; } Collections.reverse(postorder); int[] res = new int[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { res[i] = postorder.get(i); } return res; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; return; } if (visited[s]) { return; } visited[s] = true; onPath[s] = true; for (Integer n : graph[s]) { traverse(graph, n); } onPath[s] = false; postorder.add(s); } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } 思路二 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int to = edge[0]; indegree[to]++; } Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int count = 0; int[] res = new int[numCourses]; while (!queue.isEmpty()) { int node = queue.poll(); res[count] = node; count++; for (Integer next : graph[node]) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } if (count != numCourses) { return new int[0]; } return res; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } References 1. 课程表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-210/","summary":"思路 寻找可行的选课顺序其实就是计算拓扑排序 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无","title":"LeetCode 210"},{"content":"思路 这道题其实就是检测图里是否有环\n思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回\n思路二 利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列即可，最后判断访问过的结点个数是否等于总结点个数\n代码 思路一 class Solution { private boolean[] visited; private boolean[] onPath; private boolean hasCycle = false; public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i]) { traverse(graph, i); } } return !hasCycle; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; return; } if (visited[s]) { return; } visited[s] = true; onPath[s] = true; for (Integer n : graph[s]) { traverse(graph, n); } onPath[s] = false; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } 思路二 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int to = edge[0]; indegree[to]++; } Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int count = 0; while (!queue.isEmpty()) { int node = queue.poll(); count++; for (Integer next : graph[node]) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } return count == numCourses; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } References 1. 课程表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-207/","summary":"思路 这道题其实就是检测图里是否有环 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该","title":"LeetCode 207"},{"content":"思路 经典图的遍历，只不过要同时记录路径\n代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList\u0026lt;Integer\u0026gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s == n) { res.add(new LinkedList\u0026lt;\u0026gt;(path)); path.removeLast(); return; } for (int v : graph[s]) { traverse(graph, v, path); } // 离开结点时 path.removeLast(); } } References 1. 所有可能的路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-797/","summary":"思路 经典图的遍历，只不过要同时记录路径 代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList\u0026lt;Integer\u0026gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s","title":"LeetCode 797"},{"content":"思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树\n这种做法时间复杂度是O(logn*logn)，详见：https://labuladong.gitee.io/algo/2/21/48/\n代码 class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } TreeNode left = root, right = root; int lh = 0, rh = 0; while (left != null) { left = left.left; lh++; } while (right != null) { right = right.right; rh++; } if (lh == rh) { return (int) (Math.pow(2, lh) - 1); } return 1 + countNodes(root.left) + countNodes(root.right); } } References 1. 完全二叉树的节点个数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-222/","summary":"思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和","title":"LeetCode 222"},{"content":"思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是LCA\n代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { int val1 = Math.min(p.val, q.val); int val2 = Math.max(p.val, q.val); return find(root, val1, val2); } private TreeNode find(TreeNode root, int val1, int val2) { if (root == null) { return null; } if (root.val \u0026gt; val2) { return find(root.left, val1, val2); } if (root.val \u0026lt; val1) { return find(root.right, val1, val2); } return root; } } References 1. 二叉搜索树的最近公共祖先 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-235/","summary":"思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是","title":"LeetCode 235"},{"content":"思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或q或qp的LCA\n代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return findLCA(root, p.val, q.val); } private TreeNode findLCA(TreeNode root, int p, int q) { if (root == null) { return null; } if (root.val == p || root.val == q) { return root; } TreeNode left = findLCA(root.left, p, q); TreeNode right = findLCA(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left != null ? left : right; } } References 1. 二叉树的最近公共祖先 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-236/","summary":"思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或","title":"LeetCode 236"},{"content":"思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码\n思路二 思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代\n代码 思路一 public class NestedIterator implements Iterator\u0026lt;Integer\u0026gt; { private Iterator\u0026lt;Integer\u0026gt; it; public NestedIterator(List\u0026lt;NestedInteger\u0026gt; nestedList) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (NestedInteger nestedInteger : nestedList) { traverse(nestedInteger, result); } it = result.iterator(); } private void traverse(NestedInteger nestedInteger, List\u0026lt;Integer\u0026gt; result) { if (nestedInteger.isInteger()) { result.add(nestedInteger.getInteger()); return; } List\u0026lt;NestedInteger\u0026gt; list = nestedInteger.getList(); for (NestedInteger integer : list) { traverse(integer, result); } } @Override public Integer next() { return it.next(); } @Override public boolean hasNext() { return it.hasNext(); } } 思路二 public class NestedIterator implements Iterator\u0026lt;Integer\u0026gt; { private LinkedList\u0026lt;NestedInteger\u0026gt; nestedList; public NestedIterator(List\u0026lt;NestedInteger\u0026gt; nestedList) { this.nestedList = new LinkedList\u0026lt;\u0026gt;(nestedList); } @Override public Integer next() { return nestedList.remove(0).getInteger(); } @Override public boolean hasNext() { while (!nestedList.isEmpty() \u0026amp;\u0026amp; !nestedList.get(0).isInteger()) { List\u0026lt;NestedInteger\u0026gt; first = nestedList.remove(0).getList(); for (int i = first.size() - 1; i \u0026gt;= 0; i--) { nestedList.addFirst(first.get(i)); } } return !nestedList.isEmpty(); } } References 1. 扁平化嵌套列表迭代器 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-341/","summary":"思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码 思路二 思路一会在","title":"LeetCode 341"},{"content":"思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用\n我的代码 class Solution { private List\u0026lt;TreeNode\u0026gt; generateTrees(int min, int max) { List\u0026lt;TreeNode\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (min \u0026gt; max) { res.add(null); return res; } for (int i = min; i \u0026lt;= max; i++) { List\u0026lt;TreeNode\u0026gt; leftList = generateTrees(min, i - 1); List\u0026lt;TreeNode\u0026gt; rightList = generateTrees(i + 1, max); for (TreeNode leftNode : leftList) { for (TreeNode rightNode : rightList) { TreeNode root = new TreeNode(i); root.left = leftNode; root.right = rightNode; res.add(root); } } } return res; } public List\u0026lt;TreeNode\u0026gt; generateTrees(int n) { return generateTrees(1, n); } } References 1. 不同的二叉搜索树 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-95/","summary":"思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用 我的","title":"LeetCode 95"},{"content":"思路 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类\n动态规划 递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划\n我的代码 递归 class Solution { public int numTrees(int n) { if (n == 1 || n == 0) { return 1; } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += numTrees(i) * numTrees(n - i - 1); } return sum; } } 动态规划 class Solution { public int numTrees(int n) { int[] num = new int[n + 1]; num[0] = num[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; i; j++) { num[i] += num[j] * num[i - j - 1]; } } return num[n]; } } References 1. 不同的二叉搜索树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-96/","summary":"思路 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这","title":"LeetCode 96"},{"content":"思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种情况：\nroot左右皆为空，此时直接删除 root左右有一个为空，将不为空的子树替换为当前结点的位置 root左右都不为空，找左子树中最大的或右子树中最小的替换root 我的代码 class Solution { private TreeNode getMin(TreeNode root) { while (root.left != null) { root = root.left; } return root; } public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return null; if (root.val == key) { // 删除该结点 if (root.left == null \u0026amp;\u0026amp; root.right == null) { return null; } if (root.left == null) return root.right; if (root.right == null) return root.left; TreeNode min = getMin(root.right); root.right = deleteNode(root.right, min.val); min.left = root.left; min.right = root.right; root = min; } if (key \u0026gt; root.val) { root.right = deleteNode(root.right, key); } if (key \u0026lt; root.val) { root.left = deleteNode(root.left, key); } return root; } } References 1. 删除二叉搜索树中的节点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-504/","summary":"思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种","title":"LeetCode 504"},{"content":"思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造\n我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } if (val \u0026gt; root.val) { root.right = insertIntoBST(root.right, val); } if (val \u0026lt; root.val) { root.left = insertIntoBST(root.left, val); } return root; } } References 1. 二叉搜索树中的插入操作 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-701/","summary":"思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造 我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) {","title":"LeetCode 701"},{"content":"思路 利用二分查找的思想，不解释了\n我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val \u0026gt; root.val) { return searchBST(root.right, val); } if (val \u0026lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜索 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-700/","summary":"思路 利用二分查找的思想，不解释了 我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val \u0026gt; root.val) { return searchBST(root.right, val); } if (val \u0026lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜","title":"LeetCode 700"},{"content":"思路 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去\n我的代码 class Solution { private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) { if (root == null) { return true; } if (min != null \u0026amp;\u0026amp; root.val \u0026lt;= min.val) return false; if (max != null \u0026amp;\u0026amp; root.val \u0026gt;= max.val) return false; return isValidBST(root.left, min, root) \u0026amp; isValidBST(root.right, root, max); } public boolean isValidBST(TreeNode root) { return isValidBST(root, null, null); } } References 1. 验证二叉搜索树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-98/","summary":"思路 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题","title":"LeetCode 98"},{"content":"思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，这样的话遍历到当前节点的时候，比这个结点大的结点已经遍历完了，用个变量累加一下，然后赋值给当前结点就可以了\n我的代码 class Solution { private int sum = 0; public TreeNode convertBST(TreeNode root) { if (root == null) { return null; } convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root; } } References 1. 把二叉搜索树转换为累加树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-538/","summary":"思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，","title":"LeetCode 538"},{"content":"思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return\n我的代码 class Solution { private int rank = 0; public int kthSmallest(TreeNode root, int k) { if (root == null) { return 0; } int res; if ((res = kthSmallest(root.left, k)) != 0) { return res; } rank++; if (rank == k) { return root.val; } return kthSmallest(root.right, k); } } References 1. 二叉搜索树中第 K 小的元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-230/","summary":"思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return 我的代码 class Solution { private int rank","title":"LeetCode 230"},{"content":"思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（空结点和左右子树都不为null的结点），如果是那就出栈挂在新栈顶的左子树或右子树上，循环往复，直到所有的结点都被加入到栈中，树就被反序列化完成了\n官方思路一 序列化和反序列化均采用分解问题的思想，序列化不用多说，这里把反序列化问题拆分为：新建根节点+反序列化左子树+反序列化右子树（我当时为什么没想到，因为没想到还要写base case）\n官方思路二 使用文法的思想，可以将树用T -\u0026gt; (T) num (T) | X文法来序列化和反序列化，其实本质思路和我的思路一样\n代码 我的代码 public class Codec { private static final char NULL = \u0026#39;#\u0026#39;; private static final char SEP = \u0026#39;,\u0026#39;; private void doSerialize(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(NULL).append(SEP); return; } sb.append(root.val).append(SEP); doSerialize(root.left, sb); doSerialize(root.right, sb); } // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); doSerialize(root, sb); return sb.toString(); } private TreeNode newTreeNode(String val) { if (\u0026#34;#\u0026#34;.equals(val)) { return new TreeNode(-1001); } return new TreeNode(Integer.parseInt(val)); } private TreeNode fixTree(TreeNode root) { if (root == null || root.val == -1001) { return null; } root.left = fixTree(root.left); root.right = fixTree(root.right); return root; } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] nodes = data.split(\u0026#34;,\u0026#34;); Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); TreeNode dummyRoot = new TreeNode(1001); stack.push(dummyRoot); for (int i = 0; i \u0026lt; nodes.length; i++) { stack.push(newTreeNode(nodes[i])); while (stack.peek().val == -1001 || stack.peek().left != null \u0026amp;\u0026amp; stack.peek().right != null) { TreeNode peek = stack.pop(); if (stack.peek().left == null) { stack.peek().left = peek; } else { stack.peek().right = peek; } } } return fixTree(dummyRoot).left; } } 官方思路一 public class Codec { public String serialize(TreeNode root) { return rserialize(root, \u0026#34;\u0026#34;); } public TreeNode deserialize(String data) { String[] dataArray = data.split(\u0026#34;,\u0026#34;); List\u0026lt;String\u0026gt; dataList = new LinkedList\u0026lt;String\u0026gt;(Arrays.asList(dataArray)); return rdeserialize(dataList); } public String rserialize(TreeNode root, String str) { if (root == null) { str += \u0026#34;None,\u0026#34;; } else { str += str.valueOf(root.val) + \u0026#34;,\u0026#34;; str = rserialize(root.left, str); str = rserialize(root.right, str); } return str; } public TreeNode rdeserialize(List\u0026lt;String\u0026gt; dataList) { if (dataList.get(0).equals(\u0026#34;None\u0026#34;)) { dataList.remove(0); return null; } TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0))); dataList.remove(0); root.left = rdeserialize(dataList); root.right = rdeserialize(dataList); return root; } } 官方思路二 public class Codec { public String serialize(TreeNode root) { if (root == null) { return \u0026#34;X\u0026#34;; } String left = \u0026#34;(\u0026#34; + serialize(root.left) + \u0026#34;)\u0026#34;; String right = \u0026#34;(\u0026#34; + serialize(root.right) + \u0026#34;)\u0026#34;; return left + root.val + right; } public TreeNode deserialize(String data) { int[] ptr = {0}; return parse(data, ptr); } public TreeNode parse(String data, int[] ptr) { if (data.charAt(ptr[0]) == \u0026#39;X\u0026#39;) { ++ptr[0]; return null; } TreeNode cur = new TreeNode(0); cur.left = parseSubtree(data, ptr); cur.val = parseInt(data, ptr); cur.right = parseSubtree(data, ptr); return cur; } public TreeNode parseSubtree(String data, int[] ptr) { ++ptr[0]; // 跳过左括号 TreeNode subtree = parse(data, ptr); ++ptr[0]; // 跳过右括号 return subtree; } public int parseInt(String data, int[] ptr) { int x = 0, sgn = 1; if (!Character.isDigit(data.charAt(ptr[0]))) { sgn = -1; ++ptr[0]; } while (Character.isDigit(data.charAt(ptr[0]))) { x = x * 10 + data.charAt(ptr[0]++) - \u0026#39;0\u0026#39;; } return x * sgn; } } References 1. 二叉树的序列化与反序列化 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-297/","summary":"思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（","title":"LeetCode 297"},{"content":"思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树\n详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] preorder, int preStart, int preEnd, int[] postorder, int postStart, int postEnd) { if (preStart \u0026gt; preEnd) { return null; } if (preStart == preEnd) { return new TreeNode(preorder[preStart]); } int val = preorder[preStart]; TreeNode root = new TreeNode(val); int leftIndex = valToIndex.get(preorder[preStart + 1]); int leftSize = leftIndex - postStart + 1; TreeNode left = build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, leftIndex); TreeNode right = build(preorder, preStart + leftSize + 1, preEnd, postorder, leftIndex + 1, postEnd - 1); root.left = left; root.right = right; return root; } public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { for (int i = 0; i \u0026lt; postorder.length; i++) { valToIndex.put(postorder[i], i); } return build(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1); } } References 1. 根据前序和后序遍历构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-889/","summary":"思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树 详见：https://blog.zhangmengya","title":"LeetCode 889"},{"content":"思路 同LeetCode-105，就是改一下递归的参数\n详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] postorder, int postStart, int postEnd, int[] inorder, int inStart, int inEnd) { if (postStart \u0026gt; postEnd) { return null; } int val = postorder[postEnd]; TreeNode root = new TreeNode(val); int index = valToIndex.get(val); int leftSize = index - inStart; TreeNode left = build(postorder, postStart, postStart + leftSize - 1, inorder, inStart, index - 1); TreeNode right = build(postorder, postStart + leftSize, postEnd - 1, inorder, index + 1, inEnd); root.left = left; root.right = right; return root; } public TreeNode buildTree(int[] inorder, int[] postorder) { for (int i = 0; i \u0026lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(postorder, 0, postorder.length - 1, inorder, 0, inorder.length - 1); } } References 1. 从后序和中序遍历序列构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-106/","summary":"思路 同LeetCode-105，就是改一下递归的参数 详见：https://blog.zhangmengyang.tk/posts/leetc","title":"LeetCode 106"},{"content":"思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据root在中序遍历的位置得到左右子树节点的个数，再构造左右子树即可\n注意这里可以用map优化通过元素的值找所在数组的索引，用一个valToIndex的hashmap即可\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { if (preStart \u0026gt; preEnd) { return null; } int val = preorder[preStart]; TreeNode root = new TreeNode(val); int index = valToIndex.get(val); int leftSize = index - inStart; TreeNode left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); TreeNode right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); root.left = left; root.right = right; return root; } public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i \u0026lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } } References 1. 从前序和中序遍历序列构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-105/","summary":"思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据ro","title":"LeetCode 105"},{"content":"思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即可\n代码 class Solution { private TreeNode build(int[] nums, int low, int high) { if (low \u0026gt; high) { return null; } int max = nums[low], index = low; for (int i = low + 1; i \u0026lt;= high; i++) { if (nums[i] \u0026gt; max) { max = nums[i]; index = i; } } TreeNode root = new TreeNode(max); TreeNode left = build(nums, low, index - 1); TreeNode right = build(nums, index + 1, high); root.left = left; root.right = right; return root; } public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0 , nums.length - 1); } } References 1. 最大二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-654/","summary":"思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即","title":"LeetCode 654"},{"content":"思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路\n将该问题分解为：左子树展开+右子树展开+将右子树接到左子树上，即可，不过需要注意左右子树为空的情况\n代码 class Solution { private TreeNode tranToLinkedList(TreeNode root) { if (root == null) { return null; } TreeNode left = root.left; TreeNode right = root.right; TreeNode leftLast = tranToLinkedList(left); TreeNode rightLast = tranToLinkedList(right); if (leftLast == null) { root.left = null; root.right = right; } else if (rightLast == null) { root.left = null; root.right = left; } else { root.left = null; root.right = left; leftLast.right = right; } return rightLast != null ? rightLast : (leftLast != null ? leftLast : root); } public void flatten(TreeNode root) { if (root == null) { return; } tranToLinkedList(root); } } References 1. 二叉树展开为链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-114/","summary":"思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路 将该问题分解为：左子树展开+右子树展开","title":"LeetCode 114"},{"content":"思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历\n思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的\n思路二 把间隙看成结点，那么间隙组成的数据结构就是一颗三叉树，遍历这个三叉树即可解决问题，每个间隙结点需要做的事是把这个间隙的两个结点连接起来，在前中后序位置都可以\n代码 思路一 class Solution { public Node connect(Node root) { if (root == null) { return null; } Deque\u0026lt;Node\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { Node cur = queue.poll(); if (cur.left != null) { queue.offer(cur.left); queue.offer(cur.right); } if (i == size - 1) { cur.next = null; } else { cur.next = queue.peek(); } } } return root; } } 思路二 class Solution { private void traverse(Node left, Node right) { if (left == null) { return; } left.next = right; traverse(left.left, left.right); traverse(left.right, right.left); traverse(right.left, right.right); } public Node connect(Node root) { if (root == null) { return null; } traverse(root.left, root.right); return root; } } References 1. 填充每个节点的下一个右侧节点指针 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-116/","summary":"思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历 思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的 思路二 把间隙看成结点，那","title":"LeetCode 116"},{"content":"思路 遍历方式和分解方式都可以\n遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可\n分解思路 利用二叉树的分解问题思想，将原问题分解为左子树的翻转和右子树的分解，然后翻转左右子树\n代码 遍历思路 class Solution { private void traverse(TreeNode root) { if (root == null) { return; } TreeNode temp = root.right; root.right = root.left; root.left = temp; traverse(root.left); traverse(root.right); } public TreeNode invertTree(TreeNode root) { traverse(root); return root; } } 分解思路 class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; } } References 1. 翻转二叉树 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-226/","summary":"思路 遍历方式和分解方式都可以 遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可 分解思路 利用二叉树的分解","title":"LeetCode 226"},{"content":"思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，因为只有后序遍历能获得左右子树的信息。\n代码 class Solution { int maxDiameter = 0; private int maxDeep(TreeNode root) { if (root == null) { return 0; } int leftDeep = maxDeep(root.left); int rightDeep = maxDeep(root.right); maxDiameter = Math.max(maxDiameter, leftDeep + rightDeep); return Math.max(leftDeep, rightDeep) + 1; } public int diameterOfBinaryTree(TreeNode root) { maxDeep(root); return maxDiameter; } } References 1. 二叉树的直径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-543/","summary":"思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，","title":"LeetCode 543"},{"content":"思路 有两种思路，分别是分解问题和遍历二叉树\n思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度\n思路二 把二叉树遍历一遍，同时用一个外部变量记录最大的深度，注意需要在前序位置deep++，后序位置deep\u0026ndash;\n代码 思路一 class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } } 思路二 class Solution { int res = 0, deep = 0; private void traverse(TreeNode root) { if (root == null) { return; } deep++; if (root.left == null \u0026amp;\u0026amp; root.right == null) { res = Math.max(res, deep); } traverse(root.left); traverse(root.right); deep--; } public int maxDepth(TreeNode root) { traverse(root); return res; } } References 1. 二叉树的最大深度 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-104/","summary":"思路 有两种思路，分别是分解问题和遍历二叉树 思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度 思路二 把二叉树","title":"LeetCode 104"},{"content":"思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可\n第二题 考察差分数组和异或的性质\n由a^b=c \u0026mdash;\u0026gt; a^a^b=a^c \u0026mdash;\u0026gt; 0^b=a^c \u0026mdash;\u0026gt; b=a^c，因为相同的数异或为0，任何数异或0都不变\n给你的数组相当于是前缀和数组，前缀和数组的差分既是原数组，知道了异或的结果，求异或前的值，用上述推断，然后遍历数组逐个异或即可\n第三题 考察贪心和栈\n哪里贪心了？答：因为题目要求给出字典序最小的字符串，也就是需要尽量把最小的字母放在前面，那么可以比较栈顶和没入栈的那些字母，看下没入栈的那些字母是否有比栈顶小的字母，如果没有，那直接出栈，如果有，那就入栈直到遇到最小的字符串，这样贪心，最后的结果一定是字典序最小的字符串。\n第四题 考察动态规划\n非常典型的动态规划，唯一要注意的就是动态规划数组里的元素不能是所有路径长度的list，因为逐个遍历list的元素会超时，需要使用map，key为路径长度，value为长度为key的路径的个数，还需要注意value有可能很大，需要取余1000000007，key有可能很多，所以需要取余k，因为最终只需要长度能整除k的路径个数，而不需要具体的路径长度。\n总结 本次周赛难度偏低，但是我刷题太少，做起来不熟练，需要多练习多总结。\n代码 第一题 class Solution { public int hardestWorker(int n, int[][] logs) { int[] time = new int[logs.length]; int id = logs[0][0], maxTime = logs[0][1]; time[0] = logs[0][1]; for (int i = 1; i \u0026lt; time.length; i++) { time[i] = logs[i][1] - logs[i - 1][1]; if (time[i] \u0026gt; maxTime || time[i] == maxTime \u0026amp;\u0026amp; id \u0026gt; logs[i][0]) { maxTime = time[i]; id = logs[i][0]; } } return id; } } 第二题 class Solution { public int[] findArray(int[] pref) { for (int i = pref.length - 1; i \u0026gt; 0; i--) { pref[i] = pref[i] ^ pref[i - 1]; } return pref; } } 第三题 class Solution { private boolean hasSmaller(int[] count, int i) { for (int j = 0; j \u0026lt; i; j++) { if (count[j] != 0) { return true; } } return false; } public String robotWithString(String s) { int[] count = new int[26]; for (int i = 0; i \u0026lt; s.length(); i++) { count[s.charAt(i) - \u0026#39;a\u0026#39;]++; } StringBuilder ans = new StringBuilder(); Deque\u0026lt;Character\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push((char) (\u0026#39;z\u0026#39; + 1)); int index = 0; while (ans.length() != s.length()) { Character peek = stack.peek(); if (hasSmaller(count, peek - \u0026#39;a\u0026#39;)) { stack.push(s.charAt(index)); count[s.charAt(index) - \u0026#39;a\u0026#39;]--; index++; } else { ans.append(peek); stack.pop(); } } return ans.toString(); } } 第四题 class Solution { public int numberOfPaths(int[][] grid, int k) { Map\u0026lt;Integer, Integer\u0026gt;[] path = new HashMap[grid[0].length]; path[0] = new HashMap\u0026lt;\u0026gt;(); path[0].put(grid[0][0] % k, 1); for (int i = 1; i \u0026lt; grid[0].length; i++) { path[i] = new HashMap\u0026lt;\u0026gt;(); for (Integer integer : path[i - 1].keySet()) { path[i].put((integer + grid[0][i]) % k, 1); } } for (int i = 1; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++) { HashMap\u0026lt;Integer, Integer\u0026gt; temp = new HashMap\u0026lt;\u0026gt;(path[j]); path[j].clear(); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : temp.entrySet()) { path[j].put((entry.getKey() + grid[i][j]) % k, entry.getValue()); } if (j != 0) { for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : path[j - 1].entrySet()) { int newKey = (entry.getKey() + grid[i][j]) % k; path[j].put(newKey, (path[j].getOrDefault(newKey, 0) + entry.getValue()) % 1000000007); } } } } return path[path.length - 1].getOrDefault(0, 0); } } References 1. 处理用时最长的那个任务的员工 2. 找出前缀异或的原始数组 3. 使用机器人打印字典序最小的字符串 4. 矩阵中和能被 K 整除的路径 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-314/","summary":"思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可 第二题 考察差分数组和异或的性质 由a^b=c \u0026mdash;\u0026gt; a^a^b=a^c \u0026mdash;\u0026gt; 0^b=a^c \u0026mdash;\u0026gt; b","title":"LeetCode 周赛 314"},{"content":"思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.length个格子里去，那么就可以把这些格子后面的不是黑名单的数字和前面黑名单的数字交换，这样就可以随机获取数字了\n又由于数组大部分元素的值和下标是一样的，所以可以省略数组，用map记录那些交换的元素\n代码 class Solution { int size; Set\u0026lt;Integer\u0026gt; blackSet = new HashSet\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; blackMap = new HashMap\u0026lt;\u0026gt;(); public Solution(int n, int[] blacklist) { size = n - blacklist.length; for (int num : blacklist) { if (num \u0026gt;= size) { blackSet.add(num); } } int last = n - 1; for (int num : blacklist) { if (num \u0026lt; size) { while (blackSet.contains(last)) { last--; } blackMap.put(num, last); last--; } } } public int pick() { int random = new Random().nextInt(size); if (blackMap.containsKey(random)) { return blackMap.get(random); } return random; } } References 1. 黑名单中的随机数 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-710/","summary":"思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.le","title":"LeetCode 710"},{"content":"思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组\n代码 class RandomizedSet { private List\u0026lt;Integer\u0026gt; nums; private Map\u0026lt;Integer, Integer\u0026gt; valToIndex; public RandomizedSet() { nums = new ArrayList\u0026lt;\u0026gt;(); valToIndex = new HashMap\u0026lt;\u0026gt;(); } public boolean insert(int val) { if (valToIndex.containsKey(val)) { return false; } valToIndex.put(val, nums.size()); nums.add(val); return true; } public boolean remove(int val) { if (!valToIndex.containsKey(val)) { return false; } int index = valToIndex.get(val); int lastNum = nums.get(nums.size() - 1); valToIndex.put(lastNum, index); valToIndex.remove(val); nums.set(index, lastNum); nums.remove(nums.size() - 1); return true; } public int getRandom() { return nums.get(new Random().nextInt(nums.size())); } } References 1. O(1) 时间插入、删除和获取随机元素 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-380/","summary":"思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索","title":"LeetCode 380"},{"content":"思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍\n有两个需要注意的地方：\n”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了 寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见LeetCode-note的思想章节二分查找注意点第10条 代码 class Solution { int[] preSum; public Solution(int[] w) { preSum = new int[w.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + w[i - 1]; } } public int pickIndex() { int random = new Random().nextInt(preSum[preSum.length - 1]) + 1; // 二分法寻找random所在的索引 int left = 0, right = preSum.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (random \u0026lt;= preSum[mid]) { right = mid; } else { left = mid + 1; } } return left - 1; } } References 1. 按权重随机选择 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-528/","summary":"思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值","title":"LeetCode 528"},{"content":"思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/\n代码 class Solution { public int[][] generateMatrix(int n) { int upperBound = 0, lowerBound = n - 1; int leftBound = 0, rightBound = n - 1; int[][] matrix = new int[n][n]; int num = 1; while (num \u0026lt;= n * n){ if (upperBound \u0026lt;= lowerBound) { for (int i = leftBound; i \u0026lt;= rightBound; i++) { matrix[upperBound][i] = num; num++; } upperBound++; } if (leftBound \u0026lt;= rightBound) { for (int i = upperBound; i \u0026lt;= lowerBound; i++) { matrix[i][rightBound] = num; num++; } rightBound--; } if (upperBound \u0026lt;= lowerBound) { for (int i = rightBound; i \u0026gt;= leftBound; i--) { matrix[lowerBound][i] = num; num++; } lowerBound--; } if (leftBound \u0026lt;= rightBound) { for (int i = lowerBound; i \u0026gt;= upperBound; i--) { matrix[i][leftBound] = num; num++; } leftBound++; } } return matrix; } } References 1. 螺旋矩阵 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-59/","summary":"思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leet","title":"LeetCode 59"},{"content":"思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：\n需要注意水平遍历需要判断upperBound\u0026lt;=lowerBound，垂直遍历需要判断leftBound\u0026lt;=rightBound\n代码 class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { int row = matrix.length, col = matrix[0].length; int upperBound = 0, lowerBound = row - 1; int leftBound = 0, rightBound = col - 1; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (ans.size() \u0026lt; row * col) { if (upperBound \u0026lt;= lowerBound) { for (int i = leftBound; i \u0026lt;= rightBound; i++) { ans.add(matrix[upperBound][i]); } upperBound++; } if (leftBound \u0026lt;= rightBound) { for (int i = upperBound; i \u0026lt;= lowerBound; i++) { ans.add(matrix[i][rightBound]); } rightBound--; } if (upperBound \u0026lt;= lowerBound) { for (int i = rightBound; i \u0026gt;= leftBound; i--) { ans.add(matrix[lowerBound][i]); } lowerBound--; } if (leftBound \u0026lt;= rightBound) { for (int i = lowerBound; i \u0026gt;= upperBound; i--) { ans.add(matrix[i][leftBound]); } leftBound++; } } return ans; } } References 1. 螺旋矩阵 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-54/","summary":"思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界： 需要注意水平遍历需要判断upperBound\u0026lt","title":"LeetCode 54"},{"content":"思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可\n为什么这样做？因为旋转90°相当于把行变成列，而对折矩阵刚好可以把行变成列，但是位置不对，那再反转一下就行了\n代码 class Solution { public void rotate(int[][] matrix) { for (int i = 0; i \u0026lt; matrix.length; i++) { // 注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，相当于对折了两次，所以这里要写j = i + 1 for (int j = i + 1; j \u0026lt; matrix[0].length; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } for (int i = 0; i \u0026lt; matrix.length; i++) { reverse(matrix[i]); } } private void reverse(int[] s) { int left = 0, right = s.length - 1; while (left \u0026lt; right) { int temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 旋转图像 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-48/","summary":"思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的","title":"LeetCode 48"},{"content":"思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再reverse各个单词，但要注意一下细节，比如去空格什么的\n代码 class Solution { private void reverse(char[] s, int i, int j) { int left = i, right = j - 1; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } private void translate(char[] s, int i, int j, int step) { for (int k = i; k \u0026lt; j; k++) { s[k - step] = s[k]; } for (int k = j - step; k \u0026lt; j; k++) { s[k] = \u0026#39; \u0026#39;; } } public String reverseWords(String s) { char[] cs = s.toCharArray(); reverse(cs, 0, cs.length); int left = -1, step = 0; for (int i = 0; i \u0026lt; cs.length; i++) { if (cs[i] == \u0026#39; \u0026#39;) { if (left != -1) { reverse(cs, left, i); translate(cs, left, i, step); left = -1; } else { step++; } } else { if (left == -1) { left = i; } } } if (left != -1) { reverse(cs, left, cs.length); translate(cs, left, cs.length, step); } return new String(cs).trim(); } } References 1. 反转字符串中的单词 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-151/","summary":"思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再revers","title":"LeetCode 151"},{"content":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算\n代码 class Solution { public boolean carPooling(int[][] trips, int capacity) { int len = 0; for (int[] trip : trips) { len = len \u0026gt; trip[2] ? len : trip[2]; } int[] nums = new int[len]; Difference df = new Difference(nums); for (int[] trip : trips) { df.increment(trip[1], trip[2] - 1, trip[0]); } for (int num : df.result()) { if (num \u0026gt; capacity) { return false; } } return true; } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 拼车 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1094/","summary":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算 代码 class Solution { public boolean carPooling(int[][] trips, int","title":"LeetCode 1094"},{"content":"思路 标准差分数组，详见LeetCode-note\n代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 航班预订统计 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1109/","summary":"思路 标准差分数组，详见LeetCode-note 代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff;","title":"LeetCode 1109"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n代码 class NumMatrix { int[][] preSum; public NumMatrix(int[][] matrix) { preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { for (int j = 1; j \u0026lt; preSum[0].length; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } public int sumRegion(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } References 1. 二维区域和检索 - 矩阵不可变 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-304/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位 还需要","title":"LeetCode 304"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位\n代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } References 1. 区域和检索 - 数组不可变 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-303/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位 代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum =","title":"LeetCode 303"},{"content":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找出窗口最大时的长度就可以了\n代码 class Solution { public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, ans = 0; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) \u0026gt; 1) { char d = s.charAt(left); left++; window.put(d, window.get(d) - 1); } ans = Integer.max(ans, right - left); } return ans; } } References 1. 无重复字符的最长子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-3/","summary":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找","title":"LeetCode 3"},{"content":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/\n代码 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; p.length(); i++) { char c = p.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == p.length()) { ans.add(left); char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } } return ans; } } 另一种思路 vector\u0026lt;int\u0026gt; findAnagrams(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; vector\u0026lt;int\u0026gt; res; // 记录结果 while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 当窗口符合条件时，把起始索引加入 res if (valid == need.size()) res.push_back(left); char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } return res; } References 1. 找到字符串中所有字母异位词 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-438/","summary":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengya","title":"LeetCode 438"},{"content":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法的字符，当窗口的长度和s1的长度一样时，就找到了这个子串\nlabuladong的思路：利用滑动窗口的思想，始终保持窗口大小为s1.size()-1，每次移入窗口一个元素，检查一下是否找到子串，如果没有，再让一个元素移出窗口，直到找到这个子串\n代码 class Solution { public boolean checkInclusion(String s1, String s2) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s1.length(); i++) { char c = s1.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; while (right \u0026lt; s2.length()) { char c = s2.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s2.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == s1.length()) { return true; } } return false; } } 另一种思路 // 判断 s 中是否存在 t 的排列 bool checkInclusion(string t, string s) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 在这里判断是否找到了合法的子串 if (valid == need.size()) return true; char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } // 未找到符合条件的子串 return false; } References 1. 字符串的排列 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-567/","summary":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法","title":"LeetCode 567"},{"content":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节\n代码 class Solution { public String minWindow(String s, String t) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; t.length(); i++) { char c = t.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, valid = 0, begin = 0, end = Integer.MAX_VALUE; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素 // 所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (need.containsKey(c)) { window.put(c, window.getOrDefault(c, 0) + 1); if (window.get(c).equals(need.get(c))) { valid++; } } while (valid == need.size()) { if (end - begin \u0026gt; right - left) { begin = left; end = right; } c = s.charAt(left); left++; if (need.containsKey(c)) { if (window.get(c).equals(need.get(c))) { valid--; } window.put(c, window.get(c) - 1); } } } return end == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(begin, end); } } References 1. 最小覆盖子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-76/","summary":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节 代码 class Solution {","title":"LeetCode 76"},{"content":"思路 第一题 排序，不解释\n第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了\n第三题 暴力会超时，利用动态规划的思想，从左往右遍历一遍找各元素左边递减的元素个数，从右往左遍历一遍找各元素右边递增的元素个数，然后和k比较就可以了\n代码 第一题 class Solution { public String[] sortPeople(String[] names, int[] heights) { People[] peoples = new People[names.length]; for(int i = 0; i \u0026lt; peoples.length; i++) { peoples[i] = new People(names[i], heights[i]); } Arrays.sort(peoples, (a, b) -\u0026gt; b.height - a.height); for (int i = 0; i \u0026lt; peoples.length; i++) { names[i] = peoples[i].name; } return names; } static class People { String name; int height; public People(String name, int height) { this.name = name; this.height = height; } } } 第二题 class Solution { public int longestSubarray(int[] nums) { int max = Integer.MIN_VALUE, ans = 0, count = 0; for (int num : nums) { if (num != max) { count = 0; if (num \u0026gt; max) { max = num; ans = 0; } } if (num == max) { count++; } if (count \u0026gt; ans) { ans = count; } } return ans; } } 第三题 动态规划：\nclass Solution { public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { int[] decre = new int[nums.length]; decre[0] = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026lt;= nums[i - 1]) { decre[i] = decre[i - 1] + 1; } else { decre[i] = 1; } } int[] incre = new int[nums.length]; incre[nums.length - 1] = 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { if (nums[i] \u0026lt;= nums[i + 1]) { incre[i] = incre[i + 1] + 1; } else { incre[i] = 1; } } ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (decre[i - 1] \u0026gt;= k \u0026amp;\u0026amp; incre[i+1] \u0026gt;= k) { ans.add(i); } } return ans; } } 暴力解法：\nclass Solution { private boolean isGoodIndex(int[] nums, int index, int k) { for (int i = index - 1; i \u0026gt; index - k; i--) { if (nums[i] \u0026gt; nums[i - 1]) { return false; } } for (int i = index + 1; i \u0026lt; index + k; i++) { if (nums[i] \u0026gt; nums[i + 1]) { return false; } } return true; } public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (isGoodIndex(nums, i, k)) { ans.add(i); } } return ans; } } References 1. 按身高排序 2. 按位与最大的最长子数组 3. 找到所有好下标 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-312/","summary":"思路 第一题 排序，不解释 第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了 第三题 暴力会超时，利用","title":"LeetCode 周赛-312"},{"content":"思路 进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，分别查找左边界或右边界即可，详见LeetCode-note\n代码 class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026gt; nums[mid]) { left = mid + 1; } else { right = mid; } } if (nums[left] != target) { return new int[]{-1, -1}; } int[] ans = new int[2]; ans[0] = left; left = 0; right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if (target \u0026lt; nums[mid]) { right = mid - 1; } else { left = mid; } } ans[1] = left; return ans; } } References 1. 在排序数组中查找元素的第一个和最后一个位置 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-34/","summary":"思路 进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，","title":"LeetCode 34"},{"content":"思路 经典二分查找，不解释\n详见：https://labuladong.gitee.io/algo/2/20/29/\n代码 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } } References 1. 二分查找 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-704/","summary":"思路 经典二分查找，不解释 详见：https://labuladong.gitee.io/algo/2/20/29/ 代码 class Solution { public int search(int[] nums, int target) { int left","title":"LeetCode 704"},{"content":"思路 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n代码 class Solution { public String longestPalindrome(String s) { String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { // 从中心向两边寻找回文串 String s1 = findPalindrome(s, i, i); String s2 = findPalindrome(s, i, i + 1); res = res.length() \u0026gt;= s1.length() ? res : s1; res = res.length() \u0026gt;= s2.length() ? res : s2; } return res; } private String findPalindrome(String s, int left, int right) { while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(left) == s.charAt(right)) { left--; right++; } return s.substring(left + 1, right); } } References 1. 最长回文子串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-5/","summary":"思路 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。 代码 class Solution { public String longestPalindrome(String s) { String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { // 从中心向两边寻找回文串 String","title":"LeetCode 5"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 反转字符串 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-344/","summary":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值 代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1.","title":"LeetCode 344"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n代码 class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; while (left \u0026lt; right) { int sum = numbers[left] + numbers[right]; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { return new int[]{left + 1, right + 1}; } } return new int[]{0, 0}; } } References 1. 两数之和 II - 输入有序数组 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-167/","summary":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。 代","title":"LeetCode 167"},{"content":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题）\n26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n83 同26，只不过是链表，要注意去重后要把slow后面的链表断开，否则slow后面可能会有和slow重复的。\n27 同26，只不过不是比较slow和fast的元素，而是让fast和确定的值比较。\n283 同27，只不过得把slow后面的改成0。\n代码 26 class Solution { public int removeDuplicates(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow + 1; } } 83 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { slow.next = fast; slow = slow.next; } fast = fast.next; } slow.next = null; return head; } } 27 class Solution { public int removeElement(int[] nums, int val) { if (nums.length == 0) { return 0; } int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } 283 class Solution { public void moveZeroes(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != 0) { nums[slow] = nums[fast]; slow++; } fast++; } while (slow \u0026lt; nums.length) { nums[slow] = 0; slow++; } } } References 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-26+83+27+283/","summary":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题） 26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的","title":"LeetCode 26+83+27+283"},{"content":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找中点 ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } // 如果是奇数个节点，slow需要后移一位 if (fast != null) { slow = slow.next; } // 反转slow之后的 ListNode right = reverse(slow), left = head; // 判断回文 while (right != null) { if (left.val != right.val) { return false; } left = left.next; right = right.next; } return true; } private ListNode reverse(ListNode head) { ListNode pre = null, cur = head; while (cur != null) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88+%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。 代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找","title":"LeetCode 234 快慢指针+反转链表"},{"content":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private boolean traverse(ListNode right) { if (right == null) { return true; } boolean res = traverse(right.next); res = res \u0026amp;\u0026amp; (left.val == right.val); left = left.next; return res; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E9%93%BE%E8%A1%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。 代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private","title":"LeetCode 234 链表后序遍历"},{"content":"思路 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n代码 class Solution { private ListNode reverse(ListNode a, ListNode b) { // 这个做法需要对第一个节点特殊判断 // if (head == null) { // return null; // } // // ListNode pre = head, cur = head.next; // head.next = null; // while (cur != null) { // ListNode temp = cur.next; // cur.next = pre; // cur = temp; // } // // return pre; // 这个做法不需要对第一个节点特殊判断 ListNode pre = null, cur = a; while (cur != b) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } public ListNode reverseKGroup(ListNode head, int k) { ListNode p = head; // 找出前k个节点，不满k个直接return for (int i = 0; i \u0026lt; k; i++) { if (p == null) { return head; } p = p.next; } // 反转前k个 ListNode newHead = reverse(head, p); // 拼接后面反转后的链表 head.next = reverseKGroup(p, k); return newHead; } } References 1. K 个一组翻转链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-25/","summary":"思路 1、先反转以 head 开头的 k 个元素。 2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。 3、将上述两个过程的结果连接起来。 注意base case为最后元素","title":"LeetCode 25"},{"content":"思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n代码 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } public ListNode reverseBetween(ListNode head, int left, int right) { if (left == 1) { return reverseN(head, right); } head.next = reverseBetween(head.next, left - 1, right - 1); return head; } } References 1. 反转链表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-92/","summary":"思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right","title":"LeetCode 92"},{"content":"思路 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n代码 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } } ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA%E8%8A%82%E7%82%B9/","summary":"思路 解决思路和反转整个链表差不多，只要稍加修改即可： 1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。 2、刚才我们直接","title":"反转链表前n个节点"},{"content":"思路 利用递归的思想，先反转head后面的，然后把head也反转即可。\n代码 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } } References 1. 反转链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-206/","summary":"思路 利用递归的思想，先反转head后面的，然后把head也反转即可。 代码 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next =","title":"LeetCode 206"},{"content":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n分析过程 难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：\n如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n转载于： https://labuladong.gitee.io/algo/2/19/18/\n代码 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headB; while (p1 != p2) { if (p1 == null) { p1 = headB; } else { p1 = p1.next; } if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } } References 1. 相交链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-160/","summary":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等","title":"LeetCode 160"},{"content":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n分析过程 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：\nfast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。\n假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。\n巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：\n所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。\n转载于：https://labuladong.gitee.io/algo/2/19/18/\n代码 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; // 寻找相遇点 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (slow == fast) { break; } } if (fast == null || fast.next == null) { return null; } // 再次相遇即为环起始点 fast = head; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } References 1. 环形链表 II ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-142/","summary":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次","title":"LeetCode 142"},{"content":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表有环 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } } References 1. 环形链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-141/","summary":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环 代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表","title":"LeetCode 141"},{"content":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n代码 class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; // 经典快慢指针 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } } References 1. 链表的中间结点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-876/","summary":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 需要注意的是，如果链表","title":"LeetCode 876"},{"content":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n代码 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让p1指针走n步 for (int i = 0; i \u0026lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // p1指针走到头，p2指针指向的就是需要找的节点 while (p1 != null) { p1 = p1.next; p2 = p2.next; } return p2; } public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; // 找到倒数第n+1个节点 ListNode node = findFromEnd(dummy, n + 1); node.next = node.next.next; return dummy.next; } } References 1. 删除链表的倒数第 N 个结点 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-19/","summary":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指","title":"LeetCode 19"},{"content":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n代码 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.val; }); for (ListNode head : lists) { if (head != null) { pq.add(head); } } // 每次取出来一个最小的 while (!pq.isEmpty()) { ListNode node = pq.poll(); p.next = node; p = p.next; if (node.next != null) { pq.add(node.next); } } return dummy.next; } } References 1.合并K个升序链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-23/","summary":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。 代码 class Solution { public ListNode mergeKLists(ListNode[] lists) {","title":"LeetCode 23"},{"content":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n代码 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.next = p; p2 = p2.next; } ListNode temp = p.next; p.next = null; p = temp; } p1.next = dummy2.next; return dummy1.next; } References 1. 分隔链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-86/","summary":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。 代码 class","title":"LeetCode 86"},{"content":"思路 不解释\n代码 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2 != null) { p.next = list2; } return dummy.next; } } References 1. 合并两个有序链表 ","permalink":"https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-21/","summary":"思路 不解释 代码 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2","title":"LeetCode 21"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://blog.zhangmengyang.tk/en/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文","title":"🤝友链"},{"content":"about me\nname: ZMY occupation: Postgraduate student hobby: coding、game、wangshangchonglang ","permalink":"https://blog.zhangmengyang.tk/en/about/","summary":"about me name: ZMY occupation: Postgraduate student hobby: coding、game、wangshangchonglang","title":"🙋🏻‍♂️about"}]