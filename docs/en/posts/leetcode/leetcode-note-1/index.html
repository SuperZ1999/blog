<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LeetCode Note 1 | ZMY&#39;s Blog</title>
<meta name="keywords" content="leetcode">
<meta name="description" content="链表 合并两个有序链表 解法 略 题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetc">
<meta name="author" content="">
<link rel="canonical" href="https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1b749c6bd9ec5667253a04614f6680eb3ba2574eee08ba967cd6532ab57b7b3c.css" integrity="sha256-G3Sca9nsVmclOgRhT2aA6zuiV07uCLqWfNZTKrV7ezw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://blog.zhangmengyang.tk/static/letter-z.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.zhangmengyang.tk/static/letter-z.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.zhangmengyang.tk/static/letter-z.png">
<link rel="apple-touch-icon" href="https://blog.zhangmengyang.tk/static/letter-z.png">
<link rel="mask-icon" href="https://blog.zhangmengyang.tk/static/letter-z.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-note-1/">
<link rel="alternate" hreflang="en" href="https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="LeetCode Note 1" />
<meta property="og:description" content="链表 合并两个有序链表 解法 略 题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetc" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-23T10:21:48&#43;08:00" />
<meta property="article:modified_time" content="2022-12-19T16:58:22&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode Note 1"/>
<meta name="twitter:description" content="链表 合并两个有序链表 解法 略 题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetc"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 Article",
      "item": "https://blog.zhangmengyang.tk/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📝 LeetCode",
      "item": "https://blog.zhangmengyang.tk/en/posts/leetcode/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "LeetCode Note 1",
      "item": "https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LeetCode Note 1",
  "name": "LeetCode Note 1",
  "description": "链表 合并两个有序链表 解法 略 题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetc",
  "keywords": [
    "leetcode"
  ],
  "articleBody": "链表 合并两个有序链表 解法 略\n题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-21/\n单链表的分解 解法 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n题目 1. 分隔链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-86/\n合并 k 个有序链表 解法 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n题目 1. 合并K个升序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-23/\n寻找单链表的倒数第 k 个节点 解法 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n题目 1. 删除链表的倒数第 N 个结点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-19/\n单链表的中点 解法 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n题目 1. 链表的中间结点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-876/\n判断链表是否包含环 解法 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n题目 1. 环形链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-141/\n存在环的链表中寻找环起点 解法 利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n题目 1. 环形链表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-142/\n判断两个链表是否相交 解法 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u003e null -\u003e l2 -\u003e null\nl2 -\u003e null -\u003e l1 -\u003e null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n题目 1. 相交链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-160/\n反转单链表 解法 利用递归的思想，先反转head后面的，然后把head也反转即可。\n思想 反转的过程就是改变指针方向的过程并且最后一个指向null，比如反转第2个—第5个：\n1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 5 -\u003e null\n反转后为：\n1 -\u003e 2 \u003c- 3 \u003c- 4 \u003c- 5\n​ null\n题目 1. 反转链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-206/\n反转链表前n个节点 解法 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n题目 无\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/反转链表前n个节点/\n反转链表节点(m, n) 解法 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n题目 1. 反转链表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-92/\nK 个一组翻转链表 解法 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n题目 1. K 个一组翻转链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-25/\n链表的前后序遍历 void traverse(ListNode head) { // 前序遍历代码 traverse(head.next); // 后序遍历代码 } 回文串 寻找回文串 核心思想是从中心向两端扩展\n判断回文串 核心思想是从两端向中间逼近\n判断回文链表 解法 可以将链表全部反转，也可以部分反转\n链表全部反转 链表全部反转的方法共3种：\n将原链表反转，然后与原链表比较 略\n链表后序遍历 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-链表后序遍历/\n利用栈 同链表后序遍历\n链表部分反转 快慢指针+反转链表 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-快慢指针+反转链表/\n题目 1. 回文链表 数组 快慢指针在数组中的应用 数组元素去重 解法 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n具体变种详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-26+83+27+283/\n题目 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 滑动窗口 解法 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n详见思想章节\n题目 1. 最小覆盖子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-76/\n2. 字符串的排列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/\n3. 找到字符串中所有字母异位词 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-438/\n4. 无重复字符的最长子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-3/\n左右指针在数组中的应用 二分查找 解法 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度，详见思想章节\n题目 1. 在排序数组中查找元素的第一个和最后一个位置 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-34/\n2. 二分查找 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-704/\n两数之和 解法 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right–，否则left++，直到左右之和等于target。\n题目 1. 两数之和 II - 输入有序数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-167/\n反转数组 解法 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n扩展 反转字符数组里的单词 先反转整个数组，然后再反转各个单词即可\n旋转矩阵 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可\n题目 1. 反转字符串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-344/\n2. 反转字符串中的单词 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-151/\n3. 旋转图像 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-48/\n回文串判断 解法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n题目 1. 最长回文子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-5/\n前缀和在数组里的应用 一维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的时nums前n个元素的和，整体往后挪一位\n题目 1. 区域和检索 - 数组不可变 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-303/\n二维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n题目 1. 二维区域和检索 - 矩阵不可变 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/\n差分数组 解法 详见思想章节\n题目 1. 航班预订统计 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1109/\n2. 拼车 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1094/\n矩阵的螺旋遍历 解法 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：\n需要注意水平遍历需要判断upperBound\u003c=lowerBound，垂直遍历需要判断leftBound\u003c=rightBound\n题目 1. 螺旋矩阵 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/\n2. 螺旋矩阵 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-59/\n带权重的随机选择算法 解法 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍\n有两个需要注意的地方：\n”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了 寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见思想章节二分查找注意点第10条 题目 1. 按权重随机选择 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-528/\n常数时间删除/查找数组中的任意元素 解法 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组\n核心思想就是为了随机选取元素，肯定得用数组存，并且得是紧凑的\n题目 1. O(1) 时间插入、删除和获取随机元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-380/\n2. 黑名单中的随机数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-710/\n二叉树 遍历问题 解法 利用前中后序遍历模板（见思想），用一个 traverse 函数配合外部变量来实现。\n搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n题目 1. 二叉树的最大深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/\n2. 二叉树的前序遍历 题解略\n3. 翻转二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/\n4. 填充每个节点的下一个右侧节点指针 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/\n分解问题 解法 主要思想就是定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案\n首先写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)。\n搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n题目 1. 二叉树的最大深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/\n2. 二叉树的直径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-543/\n3. 翻转二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/\n4. 二叉树展开为链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-114/\n层序遍历 解法 就是一个BFS，可以计算一些类似结点与root之间的距离的问题。详见思想里的模板\n题目 1. 填充每个节点的下一个右侧节点指针 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/\n构造二叉树 解法 二叉树的构造问题一般都是使用「分解问题」的思想：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。\n题目 1. 最大二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-654/\n2. 从前序和中序遍历序列构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n3. 从后序和中序遍历序列构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-106/\n4. 根据前序和后序遍历构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-889/\n二叉搜索树性质 解法 只需要利用二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列就可以了\n题目 1. 二叉搜索树中第 K 小的元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-230/\n2. 把二叉搜索树转换为累加树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-538/\n二叉搜索树合法性 解法 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去\n题目 1. 验证二叉搜索树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-98/\n二叉搜索树增删改查 解法 见思想\n题目 1. 二叉搜索树中的搜索 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-700/\n2. 二叉搜索树中的插入操作 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-701/\n3. 删除二叉搜索树中的节点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-504/\nn个结点的BST的种类 解法 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类\n动态规划 递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划\n题目 1. 不同的二叉搜索树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-96/\n2. 不同的二叉搜索树 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-95/\n扁平化嵌套列表迭代器 解法 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码\n思路二 思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代\n题目 1. 扁平化嵌套列表迭代器 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-341/\n最近公共祖先 解法 主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA\n题目 1. 二叉树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/\n2. 二叉搜索树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/\n最近公共祖先 解法 主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA\n题目 1. 二叉树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/\n2. 二叉搜索树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/\n完全二叉树的结点个数 解法 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树\n这种做法时间复杂度是O(logn*logn)，详见：https://labuladong.gitee.io/algo/2/21/48/\n题目 1. 完全二叉树的节点个数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-222/\n图 图的遍历 解法 直接套模板，详见思想章节\n题目 1. 所有可能的路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-797/\n环检测 解法 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回\n思路二 利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列，出队相当于访问该节点，环里的结点不会入队列，最后判断访问过的结点个数是否等于总结点个数即可\n题目 1. 课程表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-207/\n拓扑排序 解法 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序\n思路二 利用图的BFS，只不过只把入度为零的结点加入队列，出队相当于访问该节点，队列出队的序列就是该图的拓扑排序\n题目 1. 课程表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-210/\n二分图的判断 解法 利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节\n题目 1. 判断二分图 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-785/\n2. 可能的二分法 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-886/\n并查集 解法 利用并查集模板即可，详见思想章节\n题目 1. 被围绕的区域 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-130/\n2. 等式方程的可满足性 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-990/\n3. 寻找图中是否存在路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1971/\ndijkstra问题 解法 利用dijkstra模板即可，注意dijkstra的变种需要修改adj和weight函数，详见思想章节\n题目 1. 网络延迟时间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-743/\n2. 最小体力消耗路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1631/\n3. 概率最大的路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1514/\nkruskal问题 解法 利用kruskal算法即可，详见思想章节\n题目 1. 连接所有点的最小费用 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/\nprim问题 解法 利用prim算法即可，详见思想章节\n题目 1. 连接所有点的最小费用 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/\n设计数据结构 LRU 解法 直接套LRU模板即可，详见思想篇章\n题目 1. LRU 缓存 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-146/\nLFU 解法 直接套LFU模板即可，详见思想篇章\n题目 1. LFU 缓存 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-460/\nTrieMap和TrieSet 解法 直接套模板即可，详见思想篇章\n题目 1. 实现 Trie (前缀树) 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-208/\n2. 单词替换 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-648/\n3. 添加与搜索单词 - 数据结构设计 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-211/\n4. 键值映射 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-677/\n数据流的中位数 解法 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg\n题目 1. 数据流的中位数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-295/\n单调栈问题 下一个更大元素 解法 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充当下一个更大元素的角色（中间去除的元素是无法充当这种角色的），那么此时栈顶就是当前元素下一个更大元素\n题目 1. 下一个更大元素 I 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-496/\n2. 每日温度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-739/\n3. 下一个更大元素 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-503/\n单调队列问题 滑动窗口最大值 解法 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色），详见思想篇章\n题目 1. 滑动窗口最大值 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-239/\n用栈实现队列 解法 直接套栈实现队列模板即可，详见思想篇章\n题目 1. 用栈实现队列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-232/\n用队列实现栈 解法 直接套用队列实现栈的模板即可，详见思想篇章\n题目 1. 用队列实现栈 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-225/\n思想 双指针 就是两个指针，分为左右指针和快慢指针，只要数组有序，就应该想到双指针技巧\n左右指针 两个指针一个左一个右\n二分查找 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度\n经典思路 public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003e target) { right = mid -1; } else if (nums[mid] \u003c target) { left = mid + 1; } } return -1; } 这种就是一边缩减搜索空间，一边寻找要找的元素。\n但是有时候问题并不是这么简单，比如寻找一个可能在数组里不存在，或者是找边界这样的问题，这时使用进阶思路 ，在循环体内排除一定不存在目标元素的区间会更简单一些。\n经典思路是寻找元素\n进阶思路是排除n-1个不可能的元素\n进阶思路 class Solution { public int search(int[] nums, int target) { // 此思路搜索空间为[left, right]，闭闭空间 int left = 0, right = nums.length - 1; // 循环条件写成left",
  "wordCount" : "25501",
  "inLanguage": "en",
  "datePublished": "2022-09-23T10:21:48+08:00",
  "dateModified": "2022-12-19T16:58:22+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ZMY's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.zhangmengyang.tk/static/letter-z.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.zhangmengyang.tk/en/" accesskey="h" title="ZMY&#39;s Blog (Alt + H)">
            <img src="https://blog.zhangmengyang.tk/static/letter-z.png" alt="logo" aria-label="logo"
                 height="35">ZMY&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://blog.zhangmengyang.tk/" title="中文"
                           aria-label="中文">中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.zhangmengyang.tk/en/search/" title="🔍 Search (Alt &#43; /)" accesskey=/>
                <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.zhangmengyang.tk/en/" title="🏠 Home">
                <span>🏠 Home</span>
                </a>
            </li>
            <li>
                <a href="https://blog.zhangmengyang.tk/en/posts/" title="📚 Article">
                <span>📚 Article</span>
                </a>
            </li>
            <li>
                <a href="https://blog.zhangmengyang.tk/en/tags/" title="🏷️ Tags">
                <span>🏷️ Tags</span>
                </a>
            </li>
            <li>
                <a href="https://blog.zhangmengyang.tk/en/archives/" title="⏱ Archive">
                <span>⏱ Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.zhangmengyang.tk/en/about/" title="🙋🏻‍♂️ About">
                <span>🙋🏻‍♂️ About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://blog.zhangmengyang.tk/en/">Home</a>&nbsp;»&nbsp;<a href="https://blog.zhangmengyang.tk/en/posts/">📚 Article</a>&nbsp;»&nbsp;<a href="https://blog.zhangmengyang.tk/en/posts/leetcode/">📝 LeetCode</a></div>
            <h1 class="post-title">
                LeetCode Note 1
            </h1>
            <div class="post-meta">











<span title='Creation Date'><svg xmlns='http://www.w3.org/2000/svg' style='position:relative; top:3px;' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M10.854 7.146a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7.5 9.793l2.646-2.647a.5.5 0 0 1 .708 0z'/><path d='M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z'/></svg></span>&nbsp;<span title='2022-09-23 10:21:48 +0800 CST'>2022-09-23</span>&nbsp;·&nbsp;<span title='Update Date'><svg xmlns='http://www.w3.org/2000/svg' style='position:relative; top:3px;' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M8 7a.5.5 0 0 1 .5.5V9H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V10H6a.5.5 0 0 1 0-1h1.5V7.5A.5.5 0 0 1 8 7z'/><path d='M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z'/></svg></span>&nbsp;<span title='2022-12-19 16:58:22 +0800 CST'>2022-12-19</span>&nbsp;·&nbsp;<svg xmlns='http://www.w3.org/2000/svg' style='position:relative; top:3px;' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z'/></svg>&nbsp;25501 words&nbsp;·&nbsp;<svg xmlns='http://www.w3.org/2000/svg' style='position:relative; top:4px;' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z'/><path d='M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z'/></svg>&nbsp;51 min


·&nbsp;
<span>
    <svg xmlns='http://www.w3.org/2000/svg' style='position:relative; top:4px;' width='16' height='16' fill='currentColor'
        viewBox='0 0 16 16'>
        <path d='M6 4.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-1 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0z' />
        <path
            d='M2 1h4.586a1 1 0 0 1 .707.293l7 7a1 1 0 0 1 0 1.414l-4.586 4.586a1 1 0 0 1-1.414 0l-7-7A1 1 0 0 1 1 6.586V2a1 1 0 0 1 1-1zm0 5.586 7 7L13.586 9l-7-7H2v4.586z' />
    </svg>
    <span>
        <a class="post-tags-meta" href="https://blog.zhangmengyang.tk/en/tags/leetcode/">leetcode</a>
    </span>
</span>

                
                &nbsp;·&nbsp;
                <span>
                    <svg xmlns='http://www.w3.org/2000/svg' style='position:relative; top:3px;' width='16' height='16' fill='currentColor'
                        viewBox='0 0 16 16'>
                        <path
                            d='M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z' />
                        <path d='M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z' />
                    </svg>
                    <span id="busuanzi_value_page_pv"></span>
                </span>

                </span>&nbsp;·&nbsp;
<ul class="i18n_list">

    <span>
        <svg xmlns='http://www.w3.org/2000/svg' style='position:relative; top:4px;' width='16' height='16' fill='currentColor'
             viewBox='0 0 16 16'>
            <path
                    d='M4.545 6.714 4.11 8H3l1.862-5h1.284L8 8H6.833l-.435-1.286H4.545zm1.634-.736L5.5 3.956h-.049l-.679 2.022H6.18z' />
            <path
                    d='M0 2a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v3h3a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-3H2a2 2 0 0 1-2-2V2zm2-1a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H2zm7.138 9.995c.193.301.402.583.63.846-.748.575-1.673 1.001-2.768 1.292.178.217.451.635.555.867 1.125-.359 2.08-.844 2.886-1.494.777.665 1.739 1.165 2.93 1.472.133-.254.414-.673.629-.89-1.125-.253-2.057-.694-2.82-1.284.681-.747 1.222-1.651 1.621-2.757H14V8h-3v1.047h.765c-.318.844-.74 1.546-1.272 2.13a6.066 6.066 0 0 1-.415-.492 1.988 1.988 0 0 1-.94.31z' />
        </svg>
        <li>
            <a class="post-tags-meta" href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-note-1/">中文</a>
        </li>
    </span>
</ul>

</div>
        </header> 
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8" aria-label="链表">链表</a><ul>
                        
                <li>
                    <a href="#%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8" aria-label="合并两个有序链表">合并两个有序链表</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8httpsleetcodecnproblemsmerge-two-sorted-lists" aria-label="1. 合并两个有序链表">1. <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%86%e8%a7%a3" aria-label="单链表的分解">单链表的分解</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-1" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-1" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%88%86%e9%9a%94%e9%93%be%e8%a1%a8httpsleetcodecnproblemspartition-list" aria-label="1. 分隔链表">1. <a href="https://leetcode.cn/problems/partition-list/">分隔链表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%90%88%e5%b9%b6-k-%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8" aria-label="合并 k 个有序链表">合并 k 个有序链表</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-2" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-2" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%90%88%e5%b9%b6k%e4%b8%aa%e5%8d%87%e5%ba%8f%e9%93%be%e8%a1%a8httpsleetcodecnproblemsmerge-k-sorted-lists" aria-label="1. 合并K个升序链表">1. <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%af%bb%e6%89%be%e5%8d%95%e9%93%be%e8%a1%a8%e7%9a%84%e5%80%92%e6%95%b0%e7%ac%ac-k-%e4%b8%aa%e8%8a%82%e7%82%b9" aria-label="寻找单链表的倒数第 k 个节点">寻找单链表的倒数第 k 个节点</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-3" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-3" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%88%a0%e9%99%a4%e9%93%be%e8%a1%a8%e7%9a%84%e5%80%92%e6%95%b0%e7%ac%ac-n-%e4%b8%aa%e7%bb%93%e7%82%b9httpsleetcodecnproblemsremove-nth-node-from-end-of-list" aria-label="1. 删除链表的倒数第 N 个结点">1. <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e9%93%be%e8%a1%a8%e7%9a%84%e4%b8%ad%e7%82%b9" aria-label="单链表的中点">单链表的中点</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-4" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-4" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e9%93%be%e8%a1%a8%e7%9a%84%e4%b8%ad%e9%97%b4%e7%bb%93%e7%82%b9httpsleetcodecnproblemsmiddle-of-the-linked-list" aria-label="1. 链表的中间结点">1. <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">链表的中间结点</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e9%93%be%e8%a1%a8%e6%98%af%e5%90%a6%e5%8c%85%e5%90%ab%e7%8e%af" aria-label="判断链表是否包含环">判断链表是否包含环</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-5" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-5" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8httpsleetcodecnproblemslinked-list-cycle" aria-label="1. 环形链表">1. <a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%98%e5%9c%a8%e7%8e%af%e7%9a%84%e9%93%be%e8%a1%a8%e4%b8%ad%e5%af%bb%e6%89%be%e7%8e%af%e8%b5%b7%e7%82%b9" aria-label="存在环的链表中寻找环起点">存在环的链表中寻找环起点</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-6" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-6" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8-iihttpsleetcodecnproblemslinked-list-cycle-ii" aria-label="1. 环形链表 II">1. <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e4%b8%a4%e4%b8%aa%e9%93%be%e8%a1%a8%e6%98%af%e5%90%a6%e7%9b%b8%e4%ba%a4" aria-label="判断两个链表是否相交">判断两个链表是否相交</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-7" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-7" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e7%9b%b8%e4%ba%a4%e9%93%be%e8%a1%a8httpsleetcodecnproblemsintersection-of-two-linked-lists" aria-label="1. 相交链表">1. <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%8d%e8%bd%ac%e5%8d%95%e9%93%be%e8%a1%a8" aria-label="反转单链表">反转单链表</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-8" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e6%80%9d%e6%83%b3" aria-label="思想">思想</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-8" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8httpsleetcodecnproblemsreverse-linked-list" aria-label="1. 反转链表">1. <a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8%e5%89%8dn%e4%b8%aa%e8%8a%82%e7%82%b9" aria-label="反转链表前n个节点">反转链表前n个节点</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-9" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-9" aria-label="题目">题目</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8%e8%8a%82%e7%82%b9m-n" aria-label="反转链表节点(m, n)">反转链表节点(m, n)</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-10" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-10" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8-iihttpsleetcodecnproblemsreverse-linked-list-ii" aria-label="1. 反转链表 II">1. <a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#k-%e4%b8%aa%e4%b8%80%e7%bb%84%e7%bf%bb%e8%bd%ac%e9%93%be%e8%a1%a8" aria-label="K 个一组翻转链表">K 个一组翻转链表</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-11" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-11" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-k-%e4%b8%aa%e4%b8%80%e7%bb%84%e7%bf%bb%e8%bd%ac%e9%93%be%e8%a1%a8httpsleetcodecnproblemsreverse-nodes-in-k-group" aria-label="1. K 个一组翻转链表">1. <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e7%9a%84%e5%89%8d%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="链表的前后序遍历">链表的前后序遍历</a></li>
                <li>
                    <a href="#%e5%9b%9e%e6%96%87%e4%b8%b2" aria-label="回文串">回文串</a><ul>
                        
                <li>
                    <a href="#%e5%af%bb%e6%89%be%e5%9b%9e%e6%96%87%e4%b8%b2" aria-label="寻找回文串">寻找回文串</a></li>
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e5%9b%9e%e6%96%87%e4%b8%b2" aria-label="判断回文串">判断回文串</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8" aria-label="判断回文链表">判断回文链表</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-12" aria-label="解法">解法</a><ul>
                        
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e5%85%a8%e9%83%a8%e5%8f%8d%e8%bd%ac" aria-label="链表全部反转">链表全部反转</a><ul>
                        
                <li>
                    <a href="#%e5%b0%86%e5%8e%9f%e9%93%be%e8%a1%a8%e5%8f%8d%e8%bd%ac%e7%84%b6%e5%90%8e%e4%b8%8e%e5%8e%9f%e9%93%be%e8%a1%a8%e6%af%94%e8%be%83" aria-label="将原链表反转，然后与原链表比较">将原链表反转，然后与原链表比较</a></li>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="链表后序遍历">链表后序遍历</a></li>
                <li>
                    <a href="#%e5%88%a9%e7%94%a8%e6%a0%88" aria-label="利用栈">利用栈</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e9%83%a8%e5%88%86%e5%8f%8d%e8%bd%ac" aria-label="链表部分反转">链表部分反转</a><ul>
                        
                <li>
                    <a href="#%e5%bf%ab%e6%85%a2%e6%8c%87%e9%92%88%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8" aria-label="快慢指针&#43;反转链表">快慢指针+反转链表</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-12" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8httpsleetcodecnproblemspalindrome-linked-list" aria-label="1. 回文链表">1. <a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84" aria-label="数组">数组</a><ul>
                        
                <li>
                    <a href="#%e5%bf%ab%e6%85%a2%e6%8c%87%e9%92%88%e5%9c%a8%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="快慢指针在数组中的应用">快慢指针在数组中的应用</a><ul>
                        
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e5%85%83%e7%b4%a0%e5%8e%bb%e9%87%8d" aria-label="数组元素去重">数组元素去重</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-13" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-13" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%88%a0%e9%99%a4%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e9%87%8d%e5%a4%8d%e9%a1%b9httpsleetcodecnproblemsremove-duplicates-from-sorted-array" aria-label="1. 删除有序数组中的重复项">1. <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></a></li>
                <li>
                    <a href="#2-%e5%88%a0%e9%99%a4%e6%8e%92%e5%ba%8f%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0httpsleetcodecnproblemsremove-duplicates-from-sorted-list" aria-label="2. 删除排序链表中的重复元素">2. <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></a></li>
                <li>
                    <a href="#3-%e7%a7%bb%e9%99%a4%e5%85%83%e7%b4%a0httpsleetcodecnproblemsremove-element" aria-label="3. 移除元素">3. <a href="https://leetcode.cn/problems/remove-element/">移除元素</a></a></li>
                <li>
                    <a href="#4-%e7%a7%bb%e5%8a%a8%e9%9b%b6httpsleetcodecnproblemsmove-zeroes" aria-label="4. 移动零">4. <a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" aria-label="滑动窗口">滑动窗口</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-14" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-14" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e6%9c%80%e5%b0%8f%e8%a6%86%e7%9b%96%e5%ad%90%e4%b8%b2httpsleetcodecnproblemsminimum-window-substring" aria-label="1. 最小覆盖子串">1. <a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></a></li>
                <li>
                    <a href="#2-%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%8e%92%e5%88%97httpsleetcodecnproblemspermutation-in-string" aria-label="2. 字符串的排列">2. <a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a></a></li>
                <li>
                    <a href="#3-%e6%89%be%e5%88%b0%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e6%89%80%e6%9c%89%e5%ad%97%e6%af%8d%e5%bc%82%e4%bd%8d%e8%af%8dhttpsleetcodecnproblemsfind-all-anagrams-in-a-string" aria-label="3. 找到字符串中所有字母异位词">3. <a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></a></li>
                <li>
                    <a href="#4-%e6%97%a0%e9%87%8d%e5%a4%8d%e5%ad%97%e7%ac%a6%e7%9a%84%e6%9c%80%e9%95%bf%e5%ad%90%e4%b8%b2httpsleetcodecnproblemslongest-substring-without-repeating-characters" aria-label="4. 无重复字符的最长子串">4. <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b7%a6%e5%8f%b3%e6%8c%87%e9%92%88%e5%9c%a8%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="左右指针在数组中的应用">左右指针在数组中的应用</a><ul>
                        
                <li>
                    <a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be" aria-label="二分查找">二分查找</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-15" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-15" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%9c%a8%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e6%9f%a5%e6%89%be%e5%85%83%e7%b4%a0%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%92%8c%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e4%bd%8d%e7%bd%aehttpsleetcodecnproblemsfind-first-and-last-position-of-element-in-sorted-array" aria-label="1. 在排序数组中查找元素的第一个和最后一个位置">1. <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></a></li>
                <li>
                    <a href="#2-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%behttpsleetcodecnproblemsbinary-search" aria-label="2. 二分查找">2. <a href="https://leetcode.cn/problems/binary-search/">二分查找</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%a4%e6%95%b0%e4%b9%8b%e5%92%8c" aria-label="两数之和">两数之和</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-16" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-16" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%b8%a4%e6%95%b0%e4%b9%8b%e5%92%8c-ii---%e8%be%93%e5%85%a5%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84httpsleetcodecnproblemstwo-sum-ii-input-array-is-sorted" aria-label="1. 两数之和 II - 输入有序数组">1. <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%8d%e8%bd%ac%e6%95%b0%e7%bb%84" aria-label="反转数组">反转数组</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-17" aria-label="解法">解法</a><ul>
                        
                <li>
                    <a href="#%e6%89%a9%e5%b1%95" aria-label="扩展">扩展</a><ul>
                        
                <li>
                    <a href="#%e5%8f%8d%e8%bd%ac%e5%ad%97%e7%ac%a6%e6%95%b0%e7%bb%84%e9%87%8c%e7%9a%84%e5%8d%95%e8%af%8d" aria-label="反转字符数组里的单词">反转字符数组里的单词</a></li>
                <li>
                    <a href="#%e6%97%8b%e8%bd%ac%e7%9f%a9%e9%98%b5" aria-label="旋转矩阵">旋转矩阵</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-17" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%8f%8d%e8%bd%ac%e5%ad%97%e7%ac%a6%e4%b8%b2httpsleetcodecnproblemsreverse-string" aria-label="1. 反转字符串">1. <a href="https://leetcode.cn/problems/reverse-string/">反转字符串</a></a></li>
                <li>
                    <a href="#2-%e5%8f%8d%e8%bd%ac%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e7%9a%84%e5%8d%95%e8%af%8dhttpsleetcodecnproblemsreverse-words-in-a-string" aria-label="2. 反转字符串中的单词">2. <a href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串中的单词</a></a></li>
                <li>
                    <a href="#3-%e6%97%8b%e8%bd%ac%e5%9b%be%e5%83%8fhttpsleetcodecnproblemsrotate-image" aria-label="3. 旋转图像">3. <a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9e%e6%96%87%e4%b8%b2%e5%88%a4%e6%96%ad" aria-label="回文串判断">回文串判断</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-18" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-18" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e4%b8%b2httpsleetcodecnproblemslongest-palindromic-substring" aria-label="1. 最长回文子串">1. <a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%89%8d%e7%bc%80%e5%92%8c%e5%9c%a8%e6%95%b0%e7%bb%84%e9%87%8c%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="前缀和在数组里的应用">前缀和在数组里的应用</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e5%89%8d%e7%bc%80%e5%92%8c" aria-label="一维数组中的前缀和">一维数组中的前缀和</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-19" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-19" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%8c%ba%e5%9f%9f%e5%92%8c%e6%a3%80%e7%b4%a2---%e6%95%b0%e7%bb%84%e4%b8%8d%e5%8f%af%e5%8f%98httpsleetcodecnproblemsrange-sum-query-immutable" aria-label="1. 区域和检索 - 数组不可变">1. <a href="https://leetcode.cn/problems/range-sum-query-immutable/">区域和检索 - 数组不可变</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e5%89%8d%e7%bc%80%e5%92%8c" aria-label="二维数组中的前缀和">二维数组中的前缀和</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-20" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-20" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%ba%8c%e7%bb%b4%e5%8c%ba%e5%9f%9f%e5%92%8c%e6%a3%80%e7%b4%a2---%e7%9f%a9%e9%98%b5%e4%b8%8d%e5%8f%af%e5%8f%98httpsleetcodecnproblemsrange-sum-query-2d-immutable" aria-label="1. 二维区域和检索 - 矩阵不可变">1. <a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">二维区域和检索 - 矩阵不可变</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84" aria-label="差分数组">差分数组</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-21" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-21" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e8%88%aa%e7%8f%ad%e9%a2%84%e8%ae%a2%e7%bb%9f%e8%ae%a1httpsleetcodecnproblemscorporate-flight-bookings" aria-label="1. 航班预订统计">1. <a href="https://leetcode.cn/problems/corporate-flight-bookings/">航班预订统计</a></a></li>
                <li>
                    <a href="#2-%e6%8b%bc%e8%bd%a6httpsleetcodecnproblemscar-pooling" aria-label="2. 拼车">2. <a href="https://leetcode.cn/problems/car-pooling/">拼车</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%9f%a9%e9%98%b5%e7%9a%84%e8%9e%ba%e6%97%8b%e9%81%8d%e5%8e%86" aria-label="矩阵的螺旋遍历">矩阵的螺旋遍历</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-22" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-22" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e8%9e%ba%e6%97%8b%e7%9f%a9%e9%98%b5httpsleetcodecnproblemsspiral-matrix" aria-label="1. 螺旋矩阵">1. <a href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a></a></li>
                <li>
                    <a href="#2-%e8%9e%ba%e6%97%8b%e7%9f%a9%e9%98%b5-iihttpsleetcodecnproblemsspiral-matrix-ii" aria-label="2. 螺旋矩阵 II">2. <a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵 II</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%a6%e6%9d%83%e9%87%8d%e7%9a%84%e9%9a%8f%e6%9c%ba%e9%80%89%e6%8b%a9%e7%ae%97%e6%b3%95" aria-label="带权重的随机选择算法">带权重的随机选择算法</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-23" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-23" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e6%8c%89%e6%9d%83%e9%87%8d%e9%9a%8f%e6%9c%ba%e9%80%89%e6%8b%a9httpsleetcodecnproblemsrandom-pick-with-weight" aria-label="1. 按权重随机选择">1. <a href="https://leetcode.cn/problems/random-pick-with-weight/">按权重随机选择</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e6%95%b0%e6%97%b6%e9%97%b4%e5%88%a0%e9%99%a4%e6%9f%a5%e6%89%be%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e4%bb%bb%e6%84%8f%e5%85%83%e7%b4%a0" aria-label="常数时间删除/查找数组中的任意元素">常数时间删除/查找数组中的任意元素</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-24" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-24" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-o1-%e6%97%b6%e9%97%b4%e6%8f%92%e5%85%a5%e5%88%a0%e9%99%a4%e5%92%8c%e8%8e%b7%e5%8f%96%e9%9a%8f%e6%9c%ba%e5%85%83%e7%b4%a0httpsleetcodecnproblemsinsert-delete-getrandom-o1" aria-label="1. O(1) 时间插入、删除和获取随机元素">1. <a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素</a></a></li>
                <li>
                    <a href="#2-%e9%bb%91%e5%90%8d%e5%8d%95%e4%b8%ad%e7%9a%84%e9%9a%8f%e6%9c%ba%e6%95%b0httpsleetcodecnproblemsrandom-pick-with-blacklist" aria-label="2. 黑名单中的随机数">2. <a href="https://leetcode.cn/problems/random-pick-with-blacklist/">黑名单中的随机数</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="二叉树">二叉树</a><ul>
                        
                <li>
                    <a href="#%e9%81%8d%e5%8e%86%e9%97%ae%e9%a2%98" aria-label="遍历问题">遍历问题</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-25" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-25" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6httpsleetcodecnproblemsmaximum-depth-of-binary-tree" aria-label="1. 二叉树的最大深度">1. <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></a></li>
                <li>
                    <a href="#2-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcodecnproblemsbinary-tree-preorder-traversal" aria-label="2. 二叉树的前序遍历">2. <a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></a></li>
                <li>
                    <a href="#3-%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsinvert-binary-tree" aria-label="3. 翻转二叉树">3. <a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></a></li>
                <li>
                    <a href="#4-%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node" aria-label="4. 填充每个节点的下一个右侧节点指针">4. <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e8%a7%a3%e9%97%ae%e9%a2%98" aria-label="分解问题">分解问题</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-26" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-26" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6httpsleetcodecnproblemsmaximum-depth-of-binary-tree-1" aria-label="1. 二叉树的最大深度">1. <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></a></li>
                <li>
                    <a href="#2-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84httpsleetcodecnproblemsdiameter-of-binary-tree" aria-label="2. 二叉树的直径">2. <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a></a></li>
                <li>
                    <a href="#3-%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsinvert-binary-tree-1" aria-label="3. 翻转二叉树">3. <a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></a></li>
                <li>
                    <a href="#4-%e4%ba%8c%e5%8f%89%e6%a0%91%e5%b1%95%e5%bc%80%e4%b8%ba%e9%93%be%e8%a1%a8httpsleetcodecnproblemsflatten-binary-tree-to-linked-list" aria-label="4. 二叉树展开为链表">4. <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="层序遍历">层序遍历</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-27" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-27" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node" aria-label="1. 填充每个节点的下一个右侧节点指针">1. <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="构造二叉树">构造二叉树</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-28" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-28" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e6%9c%80%e5%a4%a7%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsmaximum-binary-tree" aria-label="1. 最大二叉树">1. <a href="https://leetcode.cn/problems/maximum-binary-tree/">最大二叉树</a></a></li>
                <li>
                    <a href="#2-%e4%bb%8e%e5%89%8d%e5%ba%8f%e5%92%8c%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal" aria-label="2. 从前序和中序遍历序列构造二叉树">2. <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序和中序遍历序列构造二叉树</a></a></li>
                <li>
                    <a href="#3-%e4%bb%8e%e5%90%8e%e5%ba%8f%e5%92%8c%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal" aria-label="3. 从后序和中序遍历序列构造二叉树">3. <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从后序和中序遍历序列构造二叉树</a></a></li>
                <li>
                    <a href="#4-%e6%a0%b9%e6%8d%ae%e5%89%8d%e5%ba%8f%e5%92%8c%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-postorder-traversal" aria-label="4. 根据前序和后序遍历构造二叉树">4. <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">根据前序和后序遍历构造二叉树</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e6%80%a7%e8%b4%a8" aria-label="二叉搜索树性质">二叉搜索树性质</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-29" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-29" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%ac%ac-k-%e5%b0%8f%e7%9a%84%e5%85%83%e7%b4%a0httpsleetcodecnproblemskth-smallest-element-in-a-bst" aria-label="1. 二叉搜索树中第 K 小的元素">1. <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第 K 小的元素</a></a></li>
                <li>
                    <a href="#2-%e6%8a%8a%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e8%bd%ac%e6%8d%a2%e4%b8%ba%e7%b4%af%e5%8a%a0%e6%a0%91httpsleetcodecnproblemsconvert-bst-to-greater-tree" aria-label="2. 把二叉搜索树转换为累加树">2. <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e5%90%88%e6%b3%95%e6%80%a7" aria-label="二叉搜索树合法性">二叉搜索树合法性</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-30" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-30" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91httpsleetcodecnproblemsvalidate-binary-search-tree" aria-label="1. 验证二叉搜索树">1. <a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e5%a2%9e%e5%88%a0%e6%94%b9%e6%9f%a5" aria-label="二叉搜索树增删改查">二叉搜索树增删改查</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-31" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-31" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%90%9c%e7%b4%a2httpsleetcodecnproblemssearch-in-a-binary-search-tree" aria-label="1. 二叉搜索树中的搜索">1. <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></a></li>
                <li>
                    <a href="#2-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9chttpsleetcodecnproblemsinsert-into-a-binary-search-tree" aria-label="2. 二叉搜索树中的插入操作">2. <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></a></li>
                <li>
                    <a href="#3-%e5%88%a0%e9%99%a4%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9httpsleetcodecnproblemsdelete-node-in-a-bst" aria-label="3. 删除二叉搜索树中的节点">3. <a href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#n%e4%b8%aa%e7%bb%93%e7%82%b9%e7%9a%84bst%e7%9a%84%e7%a7%8d%e7%b1%bb" aria-label="n个结点的BST的种类">n个结点的BST的种类</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-32" aria-label="解法">解法</a><ul>
                        
                <li>
                    <a href="#%e9%80%92%e5%bd%92%e6%80%9d%e8%b7%af" aria-label="递归思路">递归思路</a></li>
                <li>
                    <a href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" aria-label="动态规划">动态规划</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-32" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%b8%8d%e5%90%8c%e7%9a%84%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91httpsleetcodecnproblemsunique-binary-search-trees" aria-label="1. 不同的二叉搜索树">1. <a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></a></li>
                <li>
                    <a href="#2-%e4%b8%8d%e5%90%8c%e7%9a%84%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91-iihttpsleetcodecnproblemsunique-binary-search-trees-ii" aria-label="2. 不同的二叉搜索树 II">2. <a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%89%81%e5%b9%b3%e5%8c%96%e5%b5%8c%e5%a5%97%e5%88%97%e8%a1%a8%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="扁平化嵌套列表迭代器">扁平化嵌套列表迭代器</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-33" aria-label="解法">解法</a><ul>
                        
                <li>
                    <a href="#%e6%80%9d%e8%b7%af%e4%b8%80" aria-label="思路一">思路一</a></li>
                <li>
                    <a href="#%e6%80%9d%e8%b7%af%e4%ba%8c" aria-label="思路二">思路二</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-33" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e6%89%81%e5%b9%b3%e5%8c%96%e5%b5%8c%e5%a5%97%e5%88%97%e8%a1%a8%e8%bf%ad%e4%bb%a3%e5%99%a8httpsleetcodecnproblemsflatten-nested-list-iterator" aria-label="1. 扁平化嵌套列表迭代器">1. <a href="https://leetcode.cn/problems/flatten-nested-list-iterator/">扁平化嵌套列表迭代器</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88" aria-label="最近公共祖先">最近公共祖先</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-34" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-34" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree" aria-label="1. 二叉树的最近公共祖先">1. <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></a></li>
                <li>
                    <a href="#2-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree" aria-label="2. 二叉搜索树的最近公共祖先">2. <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88-1" aria-label="最近公共祖先">最近公共祖先</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-35" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-35" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree-1" aria-label="1. 二叉树的最近公共祖先">1. <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></a></li>
                <li>
                    <a href="#2-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree-1" aria-label="2. 二叉搜索树的最近公共祖先">2. <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%bb%93%e7%82%b9%e4%b8%aa%e6%95%b0" aria-label="完全二叉树的结点个数">完全二叉树的结点个数</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-36" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-36" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e8%8a%82%e7%82%b9%e4%b8%aa%e6%95%b0httpsleetcodecnproblemscount-complete-tree-nodes" aria-label="1. 完全二叉树的节点个数">1. <a href="https://leetcode.cn/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%be" aria-label="图">图</a><ul>
                        
                <li>
                    <a href="#%e5%9b%be%e7%9a%84%e9%81%8d%e5%8e%86" aria-label="图的遍历">图的遍历</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-37" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-37" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e6%89%80%e6%9c%89%e5%8f%af%e8%83%bd%e7%9a%84%e8%b7%af%e5%be%84httpsleetcodecnproblemsall-paths-from-source-to-target" aria-label="1. 所有可能的路径">1. <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">所有可能的路径</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%8e%af%e6%a3%80%e6%b5%8b" aria-label="环检测">环检测</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-38" aria-label="解法">解法</a><ul>
                        
                <li>
                    <a href="#%e6%80%9d%e8%b7%af%e4%b8%80-1" aria-label="思路一">思路一</a></li>
                <li>
                    <a href="#%e6%80%9d%e8%b7%af%e4%ba%8c-1" aria-label="思路二">思路二</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-38" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e8%af%be%e7%a8%8b%e8%a1%a8httpsleetcodecnproblemscourse-schedule" aria-label="1. 课程表">1. <a href="https://leetcode.cn/problems/course-schedule/">课程表</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" aria-label="拓扑排序">拓扑排序</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-39" aria-label="解法">解法</a><ul>
                        
                <li>
                    <a href="#%e6%80%9d%e8%b7%af%e4%b8%80-2" aria-label="思路一">思路一</a></li>
                <li>
                    <a href="#%e6%80%9d%e8%b7%af%e4%ba%8c-2" aria-label="思路二">思路二</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-39" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e8%af%be%e7%a8%8b%e8%a1%a8-iihttpsleetcodecnproblemscourse-schedule-ii" aria-label="1. 课程表 II">1. <a href="https://leetcode.cn/problems/course-schedule-ii/">课程表 II</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e5%88%86%e5%9b%be%e7%9a%84%e5%88%a4%e6%96%ad" aria-label="二分图的判断">二分图的判断</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-40" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-40" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%88%a4%e6%96%ad%e4%ba%8c%e5%88%86%e5%9b%behttpsleetcodecnproblemsis-graph-bipartite" aria-label="1. 判断二分图">1. <a href="https://leetcode.cn/problems/is-graph-bipartite/">判断二分图</a></a></li>
                <li>
                    <a href="#2-%e5%8f%af%e8%83%bd%e7%9a%84%e4%ba%8c%e5%88%86%e6%b3%95httpsleetcodecnproblemspossible-bipartition" aria-label="2. 可能的二分法">2. <a href="https://leetcode.cn/problems/possible-bipartition/">可能的二分法</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b9%b6%e6%9f%a5%e9%9b%86" aria-label="并查集">并查集</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-41" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-41" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e8%a2%ab%e5%9b%b4%e7%bb%95%e7%9a%84%e5%8c%ba%e5%9f%9fhttpsleetcodecnproblemssurrounded-regions" aria-label="1. 被围绕的区域">1. <a href="https://leetcode.cn/problems/surrounded-regions/">被围绕的区域</a></a></li>
                <li>
                    <a href="#2-%e7%ad%89%e5%bc%8f%e6%96%b9%e7%a8%8b%e7%9a%84%e5%8f%af%e6%bb%a1%e8%b6%b3%e6%80%a7httpsleetcodecnproblemssatisfiability-of-equality-equations" aria-label="2. 等式方程的可满足性">2. <a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">等式方程的可满足性</a></a></li>
                <li>
                    <a href="#3-%e5%af%bb%e6%89%be%e5%9b%be%e4%b8%ad%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e8%b7%af%e5%be%84httpsleetcodecnproblemsfind-if-path-exists-in-graph" aria-label="3. 寻找图中是否存在路径">3. <a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/">寻找图中是否存在路径</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#dijkstra%e9%97%ae%e9%a2%98" aria-label="dijkstra问题">dijkstra问题</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-42" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-42" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e7%bd%91%e7%bb%9c%e5%bb%b6%e8%bf%9f%e6%97%b6%e9%97%b4httpsleetcodecnproblemsnetwork-delay-time" aria-label="1. 网络延迟时间">1. <a href="https://leetcode.cn/problems/network-delay-time/">网络延迟时间</a></a></li>
                <li>
                    <a href="#2-%e6%9c%80%e5%b0%8f%e4%bd%93%e5%8a%9b%e6%b6%88%e8%80%97%e8%b7%af%e5%be%84httpsleetcodecnproblemspath-with-minimum-effort" aria-label="2. 最小体力消耗路径">2. <a href="https://leetcode.cn/problems/path-with-minimum-effort/">最小体力消耗路径</a></a></li>
                <li>
                    <a href="#3-%e6%a6%82%e7%8e%87%e6%9c%80%e5%a4%a7%e7%9a%84%e8%b7%af%e5%be%84httpsleetcodecnproblemspath-with-maximum-probability" aria-label="3. 概率最大的路径">3. <a href="https://leetcode.cn/problems/path-with-maximum-probability/">概率最大的路径</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#kruskal%e9%97%ae%e9%a2%98" aria-label="kruskal问题">kruskal问题</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-43" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-43" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e8%bf%9e%e6%8e%a5%e6%89%80%e6%9c%89%e7%82%b9%e7%9a%84%e6%9c%80%e5%b0%8f%e8%b4%b9%e7%94%a8httpsleetcodecnproblemsmin-cost-to-connect-all-points" aria-label="1. 连接所有点的最小费用">1. <a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">连接所有点的最小费用</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#prim%e9%97%ae%e9%a2%98" aria-label="prim问题">prim问题</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-44" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-44" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e8%bf%9e%e6%8e%a5%e6%89%80%e6%9c%89%e7%82%b9%e7%9a%84%e6%9c%80%e5%b0%8f%e8%b4%b9%e7%94%a8httpsleetcodecnproblemsmin-cost-to-connect-all-points-1" aria-label="1. 连接所有点的最小费用">1. <a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">连接所有点的最小费用</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="设计数据结构">设计数据结构</a><ul>
                        
                <li>
                    <a href="#lru" aria-label="LRU">LRU</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-45" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-45" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-lru-%e7%bc%93%e5%ad%98httpsleetcodecnproblemslru-cache" aria-label="1. LRU 缓存">1. <a href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#lfu" aria-label="LFU">LFU</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-46" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-46" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-lfu-%e7%bc%93%e5%ad%98httpsleetcodecnproblemslfu-cache" aria-label="1. LFU 缓存">1. <a href="https://leetcode.cn/problems/lfu-cache/">LFU 缓存</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#triemap%e5%92%8ctrieset" aria-label="TrieMap和TrieSet">TrieMap和TrieSet</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-47" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-47" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e5%ae%9e%e7%8e%b0-trie-%e5%89%8d%e7%bc%80%e6%a0%91httpsleetcodecnproblemsimplement-trie-prefix-tree" aria-label="1. 实现 Trie (前缀树)">1. <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)</a></a></li>
                <li>
                    <a href="#2-%e5%8d%95%e8%af%8d%e6%9b%bf%e6%8d%a2httpsleetcodecnproblemsreplace-words" aria-label="2. 单词替换">2. <a href="https://leetcode.cn/problems/replace-words/">单词替换</a></a></li>
                <li>
                    <a href="#3-%e6%b7%bb%e5%8a%a0%e4%b8%8e%e6%90%9c%e7%b4%a2%e5%8d%95%e8%af%8d---%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1httpsleetcodecnproblemsdesign-add-and-search-words-data-structure" aria-label="3. 添加与搜索单词 - 数据结构设计">3. <a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">添加与搜索单词 - 数据结构设计</a></a></li>
                <li>
                    <a href="#4-%e9%94%ae%e5%80%bc%e6%98%a0%e5%b0%84httpsleetcodecnproblemsmap-sum-pairs" aria-label="4. 键值映射">4. <a href="https://leetcode.cn/problems/map-sum-pairs/">键值映射</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e6%b5%81%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0" aria-label="数据流的中位数">数据流的中位数</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-48" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-48" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e6%95%b0%e6%8d%ae%e6%b5%81%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0httpsleetcodecnproblemsfind-median-from-data-stream" aria-label="1. 数据流的中位数">1. <a href="https://leetcode.cn/problems/find-median-from-data-stream/">数据流的中位数</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e8%b0%83%e6%a0%88%e9%97%ae%e9%a2%98" aria-label="单调栈问题">单调栈问题</a><ul>
                        
                <li>
                    <a href="#%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%9b%b4%e5%a4%a7%e5%85%83%e7%b4%a0" aria-label="下一个更大元素">下一个更大元素</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-49" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-49" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%9b%b4%e5%a4%a7%e5%85%83%e7%b4%a0-ihttpsleetcodecnproblemsnext-greater-element-i" aria-label="1. 下一个更大元素 I">1. <a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></a></li>
                <li>
                    <a href="#2-%e6%af%8f%e6%97%a5%e6%b8%a9%e5%ba%a6httpsleetcodecnproblemsdaily-temperatures" aria-label="2. 每日温度">2. <a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></a></li>
                <li>
                    <a href="#3-%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%9b%b4%e5%a4%a7%e5%85%83%e7%b4%a0-iihttpsleetcodecnproblemsnext-greater-element-ii" aria-label="3. 下一个更大元素 II">3. <a href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97%e9%97%ae%e9%a2%98" aria-label="单调队列问题">单调队列问题</a><ul>
                        
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%9c%80%e5%a4%a7%e5%80%bc" aria-label="滑动窗口最大值">滑动窗口最大值</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-50" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-50" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%9c%80%e5%a4%a7%e5%80%bchttpsleetcodecnproblemssliding-window-maximum" aria-label="1. 滑动窗口最大值">1. <a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%94%a8%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97" aria-label="用栈实现队列">用栈实现队列</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-51" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-51" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e7%94%a8%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97httpsleetcodecnproblemsimplement-queue-using-stacks" aria-label="1. 用栈实现队列">1. <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%94%a8%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0%e6%a0%88" aria-label="用队列实现栈">用队列实现栈</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95-52" aria-label="解法">解法</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-52" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#1-%e7%94%a8%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0%e6%a0%88httpsleetcodecnproblemsimplement-stack-using-queues" aria-label="1. 用队列实现栈">1. <a href="https://leetcode.cn/problems/implement-stack-using-queues/">用队列实现栈</a></a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%80%9d%e6%83%b3-1" aria-label="思想">思想</a><ul>
                        
                <li>
                    <a href="#%e5%8f%8c%e6%8c%87%e9%92%88" aria-label="双指针">双指针</a><ul>
                        
                <li>
                    <a href="#%e5%b7%a6%e5%8f%b3%e6%8c%87%e9%92%88" aria-label="左右指针">左右指针</a><ul>
                        
                <li>
                    <a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be-1" aria-label="二分查找">二分查找</a><ul>
                        
                <li>
                    <a href="#%e7%bb%8f%e5%85%b8%e6%80%9d%e8%b7%af" aria-label="经典思路">经典思路</a></li>
                <li>
                    <a href="#%e8%bf%9b%e9%98%b6%e6%80%9d%e8%b7%af" aria-label="进阶思路">进阶思路</a><ul>
                        
                <li>
                    <a href="#%e6%ad%a5%e9%aa%a4" aria-label="步骤">步骤</a></li>
                <li>
                    <a href="#%e6%b3%a8%e6%84%8f%e7%82%b9" aria-label="注意点">注意点</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bf%ab%e6%85%a2%e6%8c%87%e9%92%88" aria-label="快慢指针">快慢指针</a><ul>
                        
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3-1" aria-label="滑动窗口">滑动窗口</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e6%9d%bf" aria-label="模板">模板</a></li>
                <li>
                    <a href="#%e6%ad%a5%e9%aa%a4-1" aria-label="步骤">步骤</a></li>
                <li>
                    <a href="#%e6%b3%a8%e6%84%8f%e7%82%b9-1" aria-label="注意点">注意点</a></li>
                <li>
                    <a href="#%e8%bf%9b%e9%98%b6" aria-label="进阶">进阶</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96-1" aria-label="其他">其他</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%80%92%e5%bd%92" aria-label="递归">递归</a></li>
                <li>
                    <a href="#%e5%89%8d%e7%bc%80%e5%92%8c%e4%b8%8e%e5%b7%ae%e5%88%86" aria-label="前缀和与差分">前缀和与差分</a><ul>
                        
                <li>
                    <a href="#%e5%89%8d%e7%bc%80%e5%92%8c" aria-label="前缀和">前缀和</a><ul>
                        
                <li>
                    <a href="#%e6%a0%87%e5%87%86%e6%a8%a1%e6%9d%bf" aria-label="标准模板">标准模板</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84-1" aria-label="差分数组">差分数组</a><ul>
                        
                <li>
                    <a href="#%e6%a0%87%e5%87%86%e6%a8%a1%e6%9d%bf-1" aria-label="标准模板">标准模板</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%a0%91-1" aria-label="二叉树">二叉树</a><ul>
                        
                <li>
                    <a href="#%e5%89%8d%e4%b8%ad%e5%90%8e%e5%ba%8f%e7%90%86%e8%a7%a3" aria-label="前中后序理解">前中后序理解</a></li>
                <li>
                    <a href="#%e9%81%8d%e5%8e%86%e6%a8%a1%e6%9d%bf" aria-label="遍历模板">遍历模板</a></li>
                <li>
                    <a href="#%e5%81%9a%e9%a2%98%e6%80%9d%e8%b7%af" aria-label="做题思路">做题思路</a></li>
                <li>
                    <a href="#%e5%90%8e%e5%ba%8f%e4%bd%8d%e7%bd%ae%e7%9a%84%e7%89%b9%e6%ae%8a%e4%b9%8b%e5%a4%84" aria-label="后序位置的特殊之处">后序位置的特殊之处</a></li>
                <li>
                    <a href="#%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86-1" aria-label="层序遍历">层序遍历</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e6%9d%bf-1" aria-label="模板">模板</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b3%a8%e6%84%8f%e7%82%b9-2" aria-label="注意点">注意点</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" aria-label="二叉搜索树">二叉搜索树</a><ul>
                        
                <li>
                    <a href="#%e6%80%a7%e8%b4%a8" aria-label="性质">性质</a></li>
                <li>
                    <a href="#%e5%90%88%e6%b3%95%e6%80%a7" aria-label="合法性">合法性</a></li>
                <li>
                    <a href="#%e5%a2%9e%e5%88%a0%e6%94%b9%e6%9f%a5" aria-label="增删改查">增删改查</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%be-1" aria-label="图">图</a><ul>
                        
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f" aria-label="存储方式">存储方式</a><ul>
                        
                <li>
                    <a href="#%e9%82%bb%e6%8e%a5%e8%a1%a8" aria-label="邻接表">邻接表</a></li>
                <li>
                    <a href="#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5" aria-label="邻接矩阵">邻接矩阵</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%81%8d%e5%8e%86%e6%a8%a1%e6%9d%bf-1" aria-label="遍历模板">遍历模板</a><ul>
                        
                <li>
                    <a href="#dfs" aria-label="DFS">DFS</a></li>
                <li>
                    <a href="#bfs" aria-label="BFS">BFS</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%be%e7%9a%84%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" aria-label="图的拓扑排序">图的拓扑排序</a><ul>
                        
                <li>
                    <a href="#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f-1" aria-label="拓扑排序">拓扑排序</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" aria-label="如何拓扑排序">如何拓扑排序</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c%e5%88%86%e5%9b%be" aria-label="二分图">二分图</a><ul>
                        
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e4%ba%8c%e5%88%86%e5%9b%be%e6%9f%93%e8%89%b2%e6%a8%a1%e6%9d%bf" aria-label="判断二分图（染色）模板">判断二分图（染色）模板</a><ul>
                        
                <li>
                    <a href="#dfs-1" aria-label="DFS">DFS</a></li>
                <li>
                    <a href="#bfs-1" aria-label="BFS">BFS</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b9%b6%e6%9f%a5%e9%9b%86-1" aria-label="并查集">并查集</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e6%9d%bf-2" aria-label="模板">模板</a></li></ul>
                </li>
                <li>
                    <a href="#dijkstra%e9%97%ae%e9%a2%98-1" aria-label="dijkstra问题">dijkstra问题</a></li>
                <li>
                    <a href="#kruskal%e9%97%ae%e9%a2%98-1" aria-label="kruskal问题">kruskal问题</a></li>
                <li>
                    <a href="#prim%e9%97%ae%e9%a2%98-1" aria-label="prim问题">prim问题</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9e%e6%ba%af" aria-label="回溯">回溯</a></li>
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-1" aria-label="设计数据结构">设计数据结构</a><ul>
                        
                <li>
                    <a href="#lru-1" aria-label="LRU">LRU</a></li>
                <li>
                    <a href="#lfu-1" aria-label="LFU">LFU</a></li>
                <li>
                    <a href="#triemap%e5%92%8ctrieset-1" aria-label="TrieMap和TrieSet">TrieMap和TrieSet</a></li>
                <li>
                    <a href="#%e5%8d%95%e8%b0%83%e6%a0%88" aria-label="单调栈">单调栈</a></li>
                <li>
                    <a href="#%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" aria-label="单调队列">单调队列</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e5%a0%86" aria-label="二叉堆">二叉堆</a></li>
                <li>
                    <a href="#%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0%e6%a0%88%e4%bb%a5%e5%8f%8a%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97" aria-label="队列实现栈以及栈实现队列">队列实现栈以及栈实现队列</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96-2" aria-label="其他">其他</a><ul>
                        
                <li>
                    <a href="#%e9%9b%b6%e7%a2%8e" aria-label="零碎">零碎</a></li>
                <li>
                    <a href="#%e5%be%85%e5%81%9a" aria-label="待做">待做</a></li>
                <li>
                    <a href="#%e6%8a%80%e5%b7%a7" aria-label="技巧">技巧</a></li>
                <li>
                    <a href="#%e5%ad%a6%e4%b9%a0%e6%96%b9%e6%b3%95" aria-label="学习方法">学习方法</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h1 id="链表">链表<a hidden class="anchor" aria-hidden="true" href="#链表">#</a></h1>
<h2 id="合并两个有序链表">合并两个有序链表<a hidden class="anchor" aria-hidden="true" href="#合并两个有序链表">#</a></h2>
<h3 id="解法">解法<a hidden class="anchor" aria-hidden="true" href="#解法">#</a></h3>
<p>略</p>
<h3 id="题目">题目<a hidden class="anchor" aria-hidden="true" href="#题目">#</a></h3>
<h4 id="1-合并两个有序链表httpsleetcodecnproblemsmerge-two-sorted-lists">1. <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a><a hidden class="anchor" aria-hidden="true" href="#1-合并两个有序链表httpsleetcodecnproblemsmerge-two-sorted-lists">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-21/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-21/</a></p>
<h2 id="单链表的分解">单链表的分解<a hidden class="anchor" aria-hidden="true" href="#单链表的分解">#</a></h2>
<h3 id="解法-1">解法<a hidden class="anchor" aria-hidden="true" href="#解法-1">#</a></h3>
<p>从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。</p>
<h3 id="题目-1">题目<a hidden class="anchor" aria-hidden="true" href="#题目-1">#</a></h3>
<h4 id="1-分隔链表httpsleetcodecnproblemspartition-list">1. <a href="https://leetcode.cn/problems/partition-list/">分隔链表</a><a hidden class="anchor" aria-hidden="true" href="#1-分隔链表httpsleetcodecnproblemspartition-list">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-86/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-86/</a></p>
<h2 id="合并-k-个有序链表">合并 k 个有序链表<a hidden class="anchor" aria-hidden="true" href="#合并-k-个有序链表">#</a></h2>
<h3 id="解法-2">解法<a hidden class="anchor" aria-hidden="true" href="#解法-2">#</a></h3>
<p>每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。</p>
<h3 id="题目-2">题目<a hidden class="anchor" aria-hidden="true" href="#题目-2">#</a></h3>
<h4 id="1-合并k个升序链表httpsleetcodecnproblemsmerge-k-sorted-lists">1. <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a><a hidden class="anchor" aria-hidden="true" href="#1-合并k个升序链表httpsleetcodecnproblemsmerge-k-sorted-lists">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-23/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-23/</a></p>
<h2 id="寻找单链表的倒数第-k-个节点">寻找单链表的倒数第 k 个节点<a hidden class="anchor" aria-hidden="true" href="#寻找单链表的倒数第-k-个节点">#</a></h2>
<h3 id="解法-3">解法<a hidden class="anchor" aria-hidden="true" href="#解法-3">#</a></h3>
<p>关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。</p>
<p>注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。</p>
<h3 id="题目-3">题目<a hidden class="anchor" aria-hidden="true" href="#题目-3">#</a></h3>
<h4 id="1-删除链表的倒数第-n-个结点httpsleetcodecnproblemsremove-nth-node-from-end-of-list">1. <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a><a hidden class="anchor" aria-hidden="true" href="#1-删除链表的倒数第-n-个结点httpsleetcodecnproblemsremove-nth-node-from-end-of-list">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-19/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-19/</a></p>
<h2 id="单链表的中点">单链表的中点<a hidden class="anchor" aria-hidden="true" href="#单链表的中点">#</a></h2>
<h3 id="解法-4">解法<a hidden class="anchor" aria-hidden="true" href="#解法-4">#</a></h3>
<p>利用快慢指针的思想，每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点。</p>
<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p>
<h3 id="题目-4">题目<a hidden class="anchor" aria-hidden="true" href="#题目-4">#</a></h3>
<h4 id="1-链表的中间结点httpsleetcodecnproblemsmiddle-of-the-linked-list">1. <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">链表的中间结点</a><a hidden class="anchor" aria-hidden="true" href="#1-链表的中间结点httpsleetcodecnproblemsmiddle-of-the-linked-list">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-876/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-876/</a></p>
<h2 id="判断链表是否包含环">判断链表是否包含环<a hidden class="anchor" aria-hidden="true" href="#判断链表是否包含环">#</a></h2>
<h3 id="解法-5">解法<a hidden class="anchor" aria-hidden="true" href="#解法-5">#</a></h3>
<p>利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环</p>
<h3 id="题目-5">题目<a hidden class="anchor" aria-hidden="true" href="#题目-5">#</a></h3>
<h4 id="1-环形链表httpsleetcodecnproblemslinked-list-cycle">1. <a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a><a hidden class="anchor" aria-hidden="true" href="#1-环形链表httpsleetcodecnproblemslinked-list-cycle">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-141/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-141/</a></p>
<h2 id="存在环的链表中寻找环起点">存在环的链表中寻找环起点<a hidden class="anchor" aria-hidden="true" href="#存在环的链表中寻找环起点">#</a></h2>
<h3 id="解法-6">解法<a hidden class="anchor" aria-hidden="true" href="#解法-6">#</a></h3>
<p>利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
<h3 id="题目-6">题目<a hidden class="anchor" aria-hidden="true" href="#题目-6">#</a></h3>
<h4 id="1-环形链表-iihttpsleetcodecnproblemslinked-list-cycle-ii">1. <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a><a hidden class="anchor" aria-hidden="true" href="#1-环形链表-iihttpsleetcodecnproblemslinked-list-cycle-ii">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-142/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-142/</a></p>
<h2 id="判断两个链表是否相交">判断两个链表是否相交<a hidden class="anchor" aria-hidden="true" href="#判断两个链表是否相交">#</a></h2>
<h3 id="解法-7">解法<a hidden class="anchor" aria-hidden="true" href="#解法-7">#</a></h3>
<p>找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。</p>
<p>代码实现方面，可以考虑四种情况：</p>
<ol>
<li>长度相等，有相交</li>
<li>长度相等，无相交</li>
<li>长度不等，有相交</li>
<li>长度不等，无相交</li>
</ol>
<p>符合这四种情况的链表连接方法如下：</p>
<p>l1 -&gt; null -&gt; l2 -&gt; null</p>
<p>l2 -&gt; null -&gt; l1 -&gt; null</p>
<p>另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。</p>
<h3 id="题目-7">题目<a hidden class="anchor" aria-hidden="true" href="#题目-7">#</a></h3>
<h4 id="1-相交链表httpsleetcodecnproblemsintersection-of-two-linked-lists">1. <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a><a hidden class="anchor" aria-hidden="true" href="#1-相交链表httpsleetcodecnproblemsintersection-of-two-linked-lists">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-160/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-160/</a></p>
<h2 id="反转单链表">反转单链表<a hidden class="anchor" aria-hidden="true" href="#反转单链表">#</a></h2>
<h3 id="解法-8">解法<a hidden class="anchor" aria-hidden="true" href="#解法-8">#</a></h3>
<p>利用递归的思想，先反转head后面的，然后把head也反转即可。</p>
<h3 id="思想">思想<a hidden class="anchor" aria-hidden="true" href="#思想">#</a></h3>
<p>反转的过程就是改变指针方向的过程并且最后一个指向null，比如反转第2个&mdash;第5个：</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</p>
<p>反转后为：</p>
<p>1 -&gt; 2 &lt;- 3 &lt;- 4 &lt;- 5</p>
<p>​     null</p>
<h3 id="题目-8">题目<a hidden class="anchor" aria-hidden="true" href="#题目-8">#</a></h3>
<h4 id="1-反转链表httpsleetcodecnproblemsreverse-linked-list">1. <a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a><a hidden class="anchor" aria-hidden="true" href="#1-反转链表httpsleetcodecnproblemsreverse-linked-list">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-206/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-206/</a></p>
<h2 id="反转链表前n个节点">反转链表前n个节点<a hidden class="anchor" aria-hidden="true" href="#反转链表前n个节点">#</a></h2>
<h3 id="解法-9">解法<a hidden class="anchor" aria-hidden="true" href="#解法-9">#</a></h3>
<p>解决思路和反转整个链表差不多，只要稍加修改即可：</p>
<p>1、base case 变为 <code>n == 1</code>，反转一个元素，就是它本身，同时<strong>要记录后驱节点</strong>。</p>
<p>2、刚才我们直接把 <code>head.next</code> 设置为 null，因为整个链表反转后原来的 <code>head</code> 变成了整个链表的最后一个节点。但现在 <code>head</code> 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 <code>successor</code>（第 <code>n + 1</code> 个节点），反转之后将 <code>head</code> 连接上。</p>
<h3 id="题目-9">题目<a hidden class="anchor" aria-hidden="true" href="#题目-9">#</a></h3>
<p>无</p>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA%E8%8A%82%E7%82%B9/">https://blog.zhangmengyang.tk/posts/leetcode/反转链表前n个节点/</a></p>
<h2 id="反转链表节点m-n">反转链表节点(m, n)<a hidden class="anchor" aria-hidden="true" href="#反转链表节点m-n">#</a></h2>
<h3 id="解法-10">解法<a hidden class="anchor" aria-hidden="true" href="#解法-10">#</a></h3>
<p>与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。</p>
<h3 id="题目-10">题目<a hidden class="anchor" aria-hidden="true" href="#题目-10">#</a></h3>
<h4 id="1-反转链表-iihttpsleetcodecnproblemsreverse-linked-list-ii">1. <a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II</a><a hidden class="anchor" aria-hidden="true" href="#1-反转链表-iihttpsleetcodecnproblemsreverse-linked-list-ii">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-92/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-92/</a></p>
<h2 id="k-个一组翻转链表">K 个一组翻转链表<a hidden class="anchor" aria-hidden="true" href="#k-个一组翻转链表">#</a></h2>
<h3 id="解法-11">解法<a hidden class="anchor" aria-hidden="true" href="#解法-11">#</a></h3>
<p><strong>1、先反转以 <code>head</code> 开头的 <code>k</code> 个元素</strong>。</p>
<p><strong>2、将第 <code>k + 1</code> 个元素作为 <code>head</code> 递归调用 <code>reverseKGroup</code> 函数</strong>。</p>
<p><strong>3、将上述两个过程的结果连接起来</strong>。</p>
<p>注意base case为最后元素不足 k 个时的情况</p>
<h3 id="题目-11">题目<a hidden class="anchor" aria-hidden="true" href="#题目-11">#</a></h3>
<h4 id="1-k-个一组翻转链表httpsleetcodecnproblemsreverse-nodes-in-k-group">1. <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a><a hidden class="anchor" aria-hidden="true" href="#1-k-个一组翻转链表httpsleetcodecnproblemsreverse-nodes-in-k-group">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-25/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-25/</a></p>
<h2 id="链表的前后序遍历">链表的前后序遍历<a hidden class="anchor" aria-hidden="true" href="#链表的前后序遍历">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 前序遍历代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">traverse</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 后序遍历代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><h2 id="回文串">回文串<a hidden class="anchor" aria-hidden="true" href="#回文串">#</a></h2>
<h3 id="寻找回文串">寻找回文串<a hidden class="anchor" aria-hidden="true" href="#寻找回文串">#</a></h3>
<p>核心思想是从中心向两端扩展</p>
<h3 id="判断回文串">判断回文串<a hidden class="anchor" aria-hidden="true" href="#判断回文串">#</a></h3>
<p>核心思想是从两端向中间逼近</p>
<h2 id="判断回文链表">判断回文链表<a hidden class="anchor" aria-hidden="true" href="#判断回文链表">#</a></h2>
<h3 id="解法-12">解法<a hidden class="anchor" aria-hidden="true" href="#解法-12">#</a></h3>
<p>可以将链表全部反转，也可以部分反转</p>
<h4 id="链表全部反转">链表全部反转<a hidden class="anchor" aria-hidden="true" href="#链表全部反转">#</a></h4>
<p>链表全部反转的方法共3种：</p>
<h5 id="将原链表反转然后与原链表比较">将原链表反转，然后与原链表比较<a hidden class="anchor" aria-hidden="true" href="#将原链表反转然后与原链表比较">#</a></h5>
<p>略</p>
<h5 id="链表后序遍历">链表后序遍历<a hidden class="anchor" aria-hidden="true" href="#链表后序遍历">#</a></h5>
<p>链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。</p>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-%E9%93%BE%E8%A1%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-链表后序遍历/</a></p>
<h5 id="利用栈">利用栈<a hidden class="anchor" aria-hidden="true" href="#利用栈">#</a></h5>
<p>同链表后序遍历</p>
<h4 id="链表部分反转">链表部分反转<a hidden class="anchor" aria-hidden="true" href="#链表部分反转">#</a></h4>
<h5 id="快慢指针反转链表">快慢指针+反转链表<a hidden class="anchor" aria-hidden="true" href="#快慢指针反转链表">#</a></h5>
<p>先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。</p>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88+%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-快慢指针+反转链表/</a></p>
<h3 id="题目-12">题目<a hidden class="anchor" aria-hidden="true" href="#题目-12">#</a></h3>
<h4 id="1-回文链表httpsleetcodecnproblemspalindrome-linked-list">1. <a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a><a hidden class="anchor" aria-hidden="true" href="#1-回文链表httpsleetcodecnproblemspalindrome-linked-list">#</a></h4>
<h1 id="数组">数组<a hidden class="anchor" aria-hidden="true" href="#数组">#</a></h1>
<h2 id="快慢指针在数组中的应用">快慢指针在数组中的应用<a hidden class="anchor" aria-hidden="true" href="#快慢指针在数组中的应用">#</a></h2>
<h3 id="数组元素去重">数组元素去重<a hidden class="anchor" aria-hidden="true" href="#数组元素去重">#</a></h3>
<h4 id="解法-13">解法<a hidden class="anchor" aria-hidden="true" href="#解法-13">#</a></h4>
<p>慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。</p>
<p>具体变种详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-26+83+27+283/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-26+83+27+283/</a></p>
<h4 id="题目-13">题目<a hidden class="anchor" aria-hidden="true" href="#题目-13">#</a></h4>
<h5 id="1-删除有序数组中的重复项httpsleetcodecnproblemsremove-duplicates-from-sorted-array">1. <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a><a hidden class="anchor" aria-hidden="true" href="#1-删除有序数组中的重复项httpsleetcodecnproblemsremove-duplicates-from-sorted-array">#</a></h5>
<h5 id="2-删除排序链表中的重复元素httpsleetcodecnproblemsremove-duplicates-from-sorted-list">2. <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a><a hidden class="anchor" aria-hidden="true" href="#2-删除排序链表中的重复元素httpsleetcodecnproblemsremove-duplicates-from-sorted-list">#</a></h5>
<h5 id="3-移除元素httpsleetcodecnproblemsremove-element">3. <a href="https://leetcode.cn/problems/remove-element/">移除元素</a><a hidden class="anchor" aria-hidden="true" href="#3-移除元素httpsleetcodecnproblemsremove-element">#</a></h5>
<h5 id="4-移动零httpsleetcodecnproblemsmove-zeroes">4. <a href="https://leetcode.cn/problems/move-zeroes/">移动零</a><a hidden class="anchor" aria-hidden="true" href="#4-移动零httpsleetcodecnproblemsmove-zeroes">#</a></h5>
<h3 id="滑动窗口">滑动窗口<a hidden class="anchor" aria-hidden="true" href="#滑动窗口">#</a></h3>
<h4 id="解法-14">解法<a hidden class="anchor" aria-hidden="true" href="#解法-14">#</a></h4>
<p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p>
<p>详见思想章节</p>
<h4 id="题目-14">题目<a hidden class="anchor" aria-hidden="true" href="#题目-14">#</a></h4>
<h5 id="1-最小覆盖子串httpsleetcodecnproblemsminimum-window-substring">1. <a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a><a hidden class="anchor" aria-hidden="true" href="#1-最小覆盖子串httpsleetcodecnproblemsminimum-window-substring">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-76/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-76/</a></p>
<h5 id="2-字符串的排列httpsleetcodecnproblemspermutation-in-string">2. <a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a><a hidden class="anchor" aria-hidden="true" href="#2-字符串的排列httpsleetcodecnproblemspermutation-in-string">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/</a></p>
<h5 id="3-找到字符串中所有字母异位词httpsleetcodecnproblemsfind-all-anagrams-in-a-string">3. <a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a><a hidden class="anchor" aria-hidden="true" href="#3-找到字符串中所有字母异位词httpsleetcodecnproblemsfind-all-anagrams-in-a-string">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-438/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-438/</a></p>
<h5 id="4-无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters">4. <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a><a hidden class="anchor" aria-hidden="true" href="#4-无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-3/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-3/</a></p>
<h2 id="左右指针在数组中的应用">左右指针在数组中的应用<a hidden class="anchor" aria-hidden="true" href="#左右指针在数组中的应用">#</a></h2>
<h3 id="二分查找">二分查找<a hidden class="anchor" aria-hidden="true" href="#二分查找">#</a></h3>
<h4 id="解法-15">解法<a hidden class="anchor" aria-hidden="true" href="#解法-15">#</a></h4>
<p>就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度，详见思想章节</p>
<h4 id="题目-15">题目<a hidden class="anchor" aria-hidden="true" href="#题目-15">#</a></h4>
<h5 id="1-在排序数组中查找元素的第一个和最后一个位置httpsleetcodecnproblemsfind-first-and-last-position-of-element-in-sorted-array">1. <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a><a hidden class="anchor" aria-hidden="true" href="#1-在排序数组中查找元素的第一个和最后一个位置httpsleetcodecnproblemsfind-first-and-last-position-of-element-in-sorted-array">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-34/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-34/</a></p>
<h5 id="2-二分查找httpsleetcodecnproblemsbinary-search">2. <a href="https://leetcode.cn/problems/binary-search/">二分查找</a><a hidden class="anchor" aria-hidden="true" href="#2-二分查找httpsleetcodecnproblemsbinary-search">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-704/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-704/</a></p>
<h3 id="两数之和">两数之和<a hidden class="anchor" aria-hidden="true" href="#两数之和">#</a></h3>
<h4 id="解法-16">解法<a hidden class="anchor" aria-hidden="true" href="#解法-16">#</a></h4>
<p>利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right&ndash;，否则left++，直到左右之和等于target。</p>
<h4 id="题目-16">题目<a hidden class="anchor" aria-hidden="true" href="#题目-16">#</a></h4>
<h5 id="1-两数之和-ii---输入有序数组httpsleetcodecnproblemstwo-sum-ii-input-array-is-sorted">1. <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a><a hidden class="anchor" aria-hidden="true" href="#1-两数之和-ii---输入有序数组httpsleetcodecnproblemstwo-sum-ii-input-array-is-sorted">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-167/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-167/</a></p>
<h3 id="反转数组">反转数组<a hidden class="anchor" aria-hidden="true" href="#反转数组">#</a></h3>
<h4 id="解法-17">解法<a hidden class="anchor" aria-hidden="true" href="#解法-17">#</a></h4>
<p>利用左右指针的思想，从两边向中间逼近，同时交换左右的值</p>
<h5 id="扩展">扩展<a hidden class="anchor" aria-hidden="true" href="#扩展">#</a></h5>
<h6 id="反转字符数组里的单词">反转字符数组里的单词<a hidden class="anchor" aria-hidden="true" href="#反转字符数组里的单词">#</a></h6>
<p>先反转整个数组，然后再反转各个单词即可</p>
<h6 id="旋转矩阵">旋转矩阵<a hidden class="anchor" aria-hidden="true" href="#旋转矩阵">#</a></h6>
<p>先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可</p>
<h4 id="题目-17">题目<a hidden class="anchor" aria-hidden="true" href="#题目-17">#</a></h4>
<h5 id="1-反转字符串httpsleetcodecnproblemsreverse-string">1. <a href="https://leetcode.cn/problems/reverse-string/">反转字符串</a><a hidden class="anchor" aria-hidden="true" href="#1-反转字符串httpsleetcodecnproblemsreverse-string">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-344/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-344/</a></p>
<h5 id="2-反转字符串中的单词httpsleetcodecnproblemsreverse-words-in-a-string">2. <a href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串中的单词</a><a hidden class="anchor" aria-hidden="true" href="#2-反转字符串中的单词httpsleetcodecnproblemsreverse-words-in-a-string">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-151/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-151/</a></p>
<h5 id="3-旋转图像httpsleetcodecnproblemsrotate-image">3. <a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a><a hidden class="anchor" aria-hidden="true" href="#3-旋转图像httpsleetcodecnproblemsrotate-image">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-48/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-48/</a></p>
<h3 id="回文串判断">回文串判断<a hidden class="anchor" aria-hidden="true" href="#回文串判断">#</a></h3>
<h4 id="解法-18">解法<a hidden class="anchor" aria-hidden="true" href="#解法-18">#</a></h4>
<p>遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。</p>
<h4 id="题目-18">题目<a hidden class="anchor" aria-hidden="true" href="#题目-18">#</a></h4>
<h5 id="1-最长回文子串httpsleetcodecnproblemslongest-palindromic-substring">1. <a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a><a hidden class="anchor" aria-hidden="true" href="#1-最长回文子串httpsleetcodecnproblemslongest-palindromic-substring">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-5/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-5/</a></p>
<h2 id="前缀和在数组里的应用">前缀和在数组里的应用<a hidden class="anchor" aria-hidden="true" href="#前缀和在数组里的应用">#</a></h2>
<h3 id="一维数组中的前缀和">一维数组中的前缀和<a hidden class="anchor" aria-hidden="true" href="#一维数组中的前缀和">#</a></h3>
<h4 id="解法-19">解法<a hidden class="anchor" aria-hidden="true" href="#解法-19">#</a></h4>
<p>利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的时nums前n个元素的和，整体往后挪一位</p>
<h4 id="题目-19">题目<a hidden class="anchor" aria-hidden="true" href="#题目-19">#</a></h4>
<h5 id="1-区域和检索---数组不可变httpsleetcodecnproblemsrange-sum-query-immutable">1. <a href="https://leetcode.cn/problems/range-sum-query-immutable/">区域和检索 - 数组不可变</a><a hidden class="anchor" aria-hidden="true" href="#1-区域和检索---数组不可变httpsleetcodecnproblemsrange-sum-query-immutable">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-303/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-303/</a></p>
<h3 id="二维数组中的前缀和">二维数组中的前缀和<a hidden class="anchor" aria-hidden="true" href="#二维数组中的前缀和">#</a></h3>
<h4 id="解法-20">解法<a hidden class="anchor" aria-hidden="true" href="#解法-20">#</a></h4>
<p>利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位</p>
<p>还需要注意做减法时，会多减一块区域，需要加回来</p>
<h4 id="题目-20">题目<a hidden class="anchor" aria-hidden="true" href="#题目-20">#</a></h4>
<h5 id="1-二维区域和检索---矩阵不可变httpsleetcodecnproblemsrange-sum-query-2d-immutable">1. <a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">二维区域和检索 - 矩阵不可变</a><a hidden class="anchor" aria-hidden="true" href="#1-二维区域和检索---矩阵不可变httpsleetcodecnproblemsrange-sum-query-2d-immutable">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/</a></p>
<h2 id="差分数组">差分数组<a hidden class="anchor" aria-hidden="true" href="#差分数组">#</a></h2>
<h3 id="解法-21">解法<a hidden class="anchor" aria-hidden="true" href="#解法-21">#</a></h3>
<p>详见思想章节</p>
<h3 id="题目-21">题目<a hidden class="anchor" aria-hidden="true" href="#题目-21">#</a></h3>
<h4 id="1-航班预订统计httpsleetcodecnproblemscorporate-flight-bookings">1. <a href="https://leetcode.cn/problems/corporate-flight-bookings/">航班预订统计</a><a hidden class="anchor" aria-hidden="true" href="#1-航班预订统计httpsleetcodecnproblemscorporate-flight-bookings">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1109/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1109/</a></p>
<h4 id="2-拼车httpsleetcodecnproblemscar-pooling">2. <a href="https://leetcode.cn/problems/car-pooling/">拼车</a><a hidden class="anchor" aria-hidden="true" href="#2-拼车httpsleetcodecnproblemscar-pooling">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1094/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1094/</a></p>
<h2 id="矩阵的螺旋遍历">矩阵的螺旋遍历<a hidden class="anchor" aria-hidden="true" href="#矩阵的螺旋遍历">#</a></h2>
<h3 id="解法-22">解法<a hidden class="anchor" aria-hidden="true" href="#解法-22">#</a></h3>
<p><strong>解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界</strong>：</p>
<p><img loading="lazy" src="https://labuladong.gitee.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/6.png" alt="img"  />
</p>
<p>需要注意水平遍历需要判断upperBound&lt;=lowerBound，垂直遍历需要判断leftBound&lt;=rightBound</p>
<h3 id="题目-22">题目<a hidden class="anchor" aria-hidden="true" href="#题目-22">#</a></h3>
<h4 id="1-螺旋矩阵httpsleetcodecnproblemsspiral-matrix">1. <a href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a><a hidden class="anchor" aria-hidden="true" href="#1-螺旋矩阵httpsleetcodecnproblemsspiral-matrix">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/</a></p>
<h4 id="2-螺旋矩阵-iihttpsleetcodecnproblemsspiral-matrix-ii">2. <a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵 II</a><a hidden class="anchor" aria-hidden="true" href="#2-螺旋矩阵-iihttpsleetcodecnproblemsspiral-matrix-ii">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-59/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-59/</a></p>
<h2 id="带权重的随机选择算法">带权重的随机选择算法<a hidden class="anchor" aria-hidden="true" href="#带权重的随机选择算法">#</a></h2>
<h3 id="解法-23">解法<a hidden class="anchor" aria-hidden="true" href="#解法-23">#</a></h3>
<p>可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍</p>
<p>有两个需要注意的地方：</p>
<ol>
<li>”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了</li>
<li>寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见思想章节二分查找注意点第10条</li>
</ol>
<h3 id="题目-23">题目<a hidden class="anchor" aria-hidden="true" href="#题目-23">#</a></h3>
<h4 id="1-按权重随机选择httpsleetcodecnproblemsrandom-pick-with-weight">1. <a href="https://leetcode.cn/problems/random-pick-with-weight/">按权重随机选择</a><a hidden class="anchor" aria-hidden="true" href="#1-按权重随机选择httpsleetcodecnproblemsrandom-pick-with-weight">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-528/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-528/</a></p>
<h2 id="常数时间删除查找数组中的任意元素">常数时间删除/查找数组中的任意元素<a hidden class="anchor" aria-hidden="true" href="#常数时间删除查找数组中的任意元素">#</a></h2>
<h3 id="解法-24">解法<a hidden class="anchor" aria-hidden="true" href="#解法-24">#</a></h3>
<p>为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组</p>
<p>核心思想就是为了随机选取元素，肯定得用<strong>数组</strong>存，并且得是<strong>紧凑</strong>的</p>
<h3 id="题目-24">题目<a hidden class="anchor" aria-hidden="true" href="#题目-24">#</a></h3>
<h4 id="1-o1-时间插入删除和获取随机元素httpsleetcodecnproblemsinsert-delete-getrandom-o1">1. <a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素</a><a hidden class="anchor" aria-hidden="true" href="#1-o1-时间插入删除和获取随机元素httpsleetcodecnproblemsinsert-delete-getrandom-o1">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-380/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-380/</a></p>
<h4 id="2-黑名单中的随机数httpsleetcodecnproblemsrandom-pick-with-blacklist">2. <a href="https://leetcode.cn/problems/random-pick-with-blacklist/">黑名单中的随机数</a><a hidden class="anchor" aria-hidden="true" href="#2-黑名单中的随机数httpsleetcodecnproblemsrandom-pick-with-blacklist">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-710/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-710/</a></p>
<h1 id="二叉树">二叉树<a hidden class="anchor" aria-hidden="true" href="#二叉树">#</a></h1>
<h2 id="遍历问题">遍历问题<a hidden class="anchor" aria-hidden="true" href="#遍历问题">#</a></h2>
<h3 id="解法-25">解法<a hidden class="anchor" aria-hidden="true" href="#解法-25">#</a></h3>
<p>利用前中后序遍历模板（见思想），用一个 traverse 函数配合外部变量来实现。</p>
<p>搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。</p>
<h3 id="题目-25">题目<a hidden class="anchor" aria-hidden="true" href="#题目-25">#</a></h3>
<h4 id="1-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree">1. <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a><a hidden class="anchor" aria-hidden="true" href="#1-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/</a></p>
<h4 id="2-二叉树的前序遍历httpsleetcodecnproblemsbinary-tree-preorder-traversal">2. <a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a><a hidden class="anchor" aria-hidden="true" href="#2-二叉树的前序遍历httpsleetcodecnproblemsbinary-tree-preorder-traversal">#</a></h4>
<p>题解略</p>
<h4 id="3-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree">3. <a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a><a hidden class="anchor" aria-hidden="true" href="#3-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/</a></p>
<h4 id="4-填充每个节点的下一个右侧节点指针httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node">4. <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a><a hidden class="anchor" aria-hidden="true" href="#4-填充每个节点的下一个右侧节点指针httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/</a></p>
<h2 id="分解问题">分解问题<a hidden class="anchor" aria-hidden="true" href="#分解问题">#</a></h2>
<h3 id="解法-26">解法<a hidden class="anchor" aria-hidden="true" href="#解法-26">#</a></h3>
<p>主要思想就是定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</p>
<p>首先写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)。</p>
<p>搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。</p>
<h3 id="题目-26">题目<a hidden class="anchor" aria-hidden="true" href="#题目-26">#</a></h3>
<h4 id="1-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree-1">1. <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a><a hidden class="anchor" aria-hidden="true" href="#1-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree-1">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/</a></p>
<h4 id="2-二叉树的直径httpsleetcodecnproblemsdiameter-of-binary-tree">2. <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a><a hidden class="anchor" aria-hidden="true" href="#2-二叉树的直径httpsleetcodecnproblemsdiameter-of-binary-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-543/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-543/</a></p>
<h4 id="3-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree-1">3. <a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a><a hidden class="anchor" aria-hidden="true" href="#3-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree-1">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/</a></p>
<h4 id="4-二叉树展开为链表httpsleetcodecnproblemsflatten-binary-tree-to-linked-list">4. <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a><a hidden class="anchor" aria-hidden="true" href="#4-二叉树展开为链表httpsleetcodecnproblemsflatten-binary-tree-to-linked-list">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-114/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-114/</a></p>
<h2 id="层序遍历">层序遍历<a hidden class="anchor" aria-hidden="true" href="#层序遍历">#</a></h2>
<h3 id="解法-27">解法<a hidden class="anchor" aria-hidden="true" href="#解法-27">#</a></h3>
<p>就是一个BFS，可以计算一些类似结点与root之间的距离的问题。详见思想里的模板</p>
<h3 id="题目-27">题目<a hidden class="anchor" aria-hidden="true" href="#题目-27">#</a></h3>
<h4 id="1-填充每个节点的下一个右侧节点指针httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node">1. <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a><a hidden class="anchor" aria-hidden="true" href="#1-填充每个节点的下一个右侧节点指针httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/</a></p>
<h2 id="构造二叉树">构造二叉树<a hidden class="anchor" aria-hidden="true" href="#构造二叉树">#</a></h2>
<h3 id="解法-28">解法<a hidden class="anchor" aria-hidden="true" href="#解法-28">#</a></h3>
<p>二叉树的构造问题一般都是使用「分解问题」的思想：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。</p>
<h3 id="题目-28">题目<a hidden class="anchor" aria-hidden="true" href="#题目-28">#</a></h3>
<h4 id="1-最大二叉树httpsleetcodecnproblemsmaximum-binary-tree">1. <a href="https://leetcode.cn/problems/maximum-binary-tree/">最大二叉树</a><a hidden class="anchor" aria-hidden="true" href="#1-最大二叉树httpsleetcodecnproblemsmaximum-binary-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-654/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-654/</a></p>
<h4 id="2-从前序和中序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal">2. <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序和中序遍历序列构造二叉树</a><a hidden class="anchor" aria-hidden="true" href="#2-从前序和中序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/</a></p>
<h4 id="3-从后序和中序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal">3. <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从后序和中序遍历序列构造二叉树</a><a hidden class="anchor" aria-hidden="true" href="#3-从后序和中序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-106/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-106/</a></p>
<h4 id="4-根据前序和后序遍历构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-postorder-traversal">4. <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">根据前序和后序遍历构造二叉树</a><a hidden class="anchor" aria-hidden="true" href="#4-根据前序和后序遍历构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-postorder-traversal">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-889/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-889/</a></p>
<h2 id="二叉搜索树性质">二叉搜索树性质<a hidden class="anchor" aria-hidden="true" href="#二叉搜索树性质">#</a></h2>
<h3 id="解法-29">解法<a hidden class="anchor" aria-hidden="true" href="#解法-29">#</a></h3>
<p>只需要利用二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列就可以了</p>
<h3 id="题目-29">题目<a hidden class="anchor" aria-hidden="true" href="#题目-29">#</a></h3>
<h4 id="1-二叉搜索树中第-k-小的元素httpsleetcodecnproblemskth-smallest-element-in-a-bst">1. <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第 K 小的元素</a><a hidden class="anchor" aria-hidden="true" href="#1-二叉搜索树中第-k-小的元素httpsleetcodecnproblemskth-smallest-element-in-a-bst">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-230/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-230/</a></p>
<h4 id="2-把二叉搜索树转换为累加树httpsleetcodecnproblemsconvert-bst-to-greater-tree">2. <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a><a hidden class="anchor" aria-hidden="true" href="#2-把二叉搜索树转换为累加树httpsleetcodecnproblemsconvert-bst-to-greater-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-538/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-538/</a></p>
<h2 id="二叉搜索树合法性">二叉搜索树合法性<a hidden class="anchor" aria-hidden="true" href="#二叉搜索树合法性">#</a></h2>
<h3 id="解法-30">解法<a hidden class="anchor" aria-hidden="true" href="#解法-30">#</a></h3>
<p>利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去</p>
<h3 id="题目-30">题目<a hidden class="anchor" aria-hidden="true" href="#题目-30">#</a></h3>
<h4 id="1-验证二叉搜索树httpsleetcodecnproblemsvalidate-binary-search-tree">1. <a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a><a hidden class="anchor" aria-hidden="true" href="#1-验证二叉搜索树httpsleetcodecnproblemsvalidate-binary-search-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-98/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-98/</a></p>
<h2 id="二叉搜索树增删改查">二叉搜索树增删改查<a hidden class="anchor" aria-hidden="true" href="#二叉搜索树增删改查">#</a></h2>
<h3 id="解法-31">解法<a hidden class="anchor" aria-hidden="true" href="#解法-31">#</a></h3>
<p>见思想</p>
<h3 id="题目-31">题目<a hidden class="anchor" aria-hidden="true" href="#题目-31">#</a></h3>
<h4 id="1-二叉搜索树中的搜索httpsleetcodecnproblemssearch-in-a-binary-search-tree">1. <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a><a hidden class="anchor" aria-hidden="true" href="#1-二叉搜索树中的搜索httpsleetcodecnproblemssearch-in-a-binary-search-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-700/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-700/</a></p>
<h4 id="2-二叉搜索树中的插入操作httpsleetcodecnproblemsinsert-into-a-binary-search-tree">2. <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a><a hidden class="anchor" aria-hidden="true" href="#2-二叉搜索树中的插入操作httpsleetcodecnproblemsinsert-into-a-binary-search-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-701/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-701/</a></p>
<h4 id="3-删除二叉搜索树中的节点httpsleetcodecnproblemsdelete-node-in-a-bst">3. <a href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a><a hidden class="anchor" aria-hidden="true" href="#3-删除二叉搜索树中的节点httpsleetcodecnproblemsdelete-node-in-a-bst">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-504/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-504/</a></p>
<h2 id="n个结点的bst的种类">n个结点的BST的种类<a hidden class="anchor" aria-hidden="true" href="#n个结点的bst的种类">#</a></h2>
<h3 id="解法-32">解法<a hidden class="anchor" aria-hidden="true" href="#解法-32">#</a></h3>
<h4 id="递归思路">递归思路<a hidden class="anchor" aria-hidden="true" href="#递归思路">#</a></h4>
<p>递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类</p>
<h4 id="动态规划">动态规划<a hidden class="anchor" aria-hidden="true" href="#动态规划">#</a></h4>
<p>递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划</p>
<h3 id="题目-32">题目<a hidden class="anchor" aria-hidden="true" href="#题目-32">#</a></h3>
<h4 id="1-不同的二叉搜索树httpsleetcodecnproblemsunique-binary-search-trees">1. <a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a><a hidden class="anchor" aria-hidden="true" href="#1-不同的二叉搜索树httpsleetcodecnproblemsunique-binary-search-trees">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-96/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-96/</a></p>
<h4 id="2-不同的二叉搜索树-iihttpsleetcodecnproblemsunique-binary-search-trees-ii">2. <a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a><a hidden class="anchor" aria-hidden="true" href="#2-不同的二叉搜索树-iihttpsleetcodecnproblemsunique-binary-search-trees-ii">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-95/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-95/</a></p>
<h2 id="扁平化嵌套列表迭代器">扁平化嵌套列表迭代器<a hidden class="anchor" aria-hidden="true" href="#扁平化嵌套列表迭代器">#</a></h2>
<h3 id="解法-33">解法<a hidden class="anchor" aria-hidden="true" href="#解法-33">#</a></h3>
<h4 id="思路一">思路一<a hidden class="anchor" aria-hidden="true" href="#思路一">#</a></h4>
<p>将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码</p>
<h4 id="思路二">思路二<a hidden class="anchor" aria-hidden="true" href="#思路二">#</a></h4>
<p>思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代</p>
<h3 id="题目-33">题目<a hidden class="anchor" aria-hidden="true" href="#题目-33">#</a></h3>
<h4 id="1-扁平化嵌套列表迭代器httpsleetcodecnproblemsflatten-nested-list-iterator">1. <a href="https://leetcode.cn/problems/flatten-nested-list-iterator/">扁平化嵌套列表迭代器</a><a hidden class="anchor" aria-hidden="true" href="#1-扁平化嵌套列表迭代器httpsleetcodecnproblemsflatten-nested-list-iterator">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-341/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-341/</a></p>
<h2 id="最近公共祖先">最近公共祖先<a hidden class="anchor" aria-hidden="true" href="#最近公共祖先">#</a></h2>
<h3 id="解法-34">解法<a hidden class="anchor" aria-hidden="true" href="#解法-34">#</a></h3>
<p>主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA</p>
<h3 id="题目-34">题目<a hidden class="anchor" aria-hidden="true" href="#题目-34">#</a></h3>
<h4 id="1-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree">1. <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a><a hidden class="anchor" aria-hidden="true" href="#1-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/</a></p>
<h4 id="2-二叉搜索树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree">2. <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a><a hidden class="anchor" aria-hidden="true" href="#2-二叉搜索树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/</a></p>
<h2 id="最近公共祖先-1">最近公共祖先<a hidden class="anchor" aria-hidden="true" href="#最近公共祖先-1">#</a></h2>
<h3 id="解法-35">解法<a hidden class="anchor" aria-hidden="true" href="#解法-35">#</a></h3>
<p>主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA</p>
<h3 id="题目-35">题目<a hidden class="anchor" aria-hidden="true" href="#题目-35">#</a></h3>
<h4 id="1-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree-1">1. <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a><a hidden class="anchor" aria-hidden="true" href="#1-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree-1">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/</a></p>
<h4 id="2-二叉搜索树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree-1">2. <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a><a hidden class="anchor" aria-hidden="true" href="#2-二叉搜索树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree-1">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/</a></p>
<h2 id="完全二叉树的结点个数">完全二叉树的结点个数<a hidden class="anchor" aria-hidden="true" href="#完全二叉树的结点个数">#</a></h2>
<h3 id="解法-36">解法<a hidden class="anchor" aria-hidden="true" href="#解法-36">#</a></h3>
<p>普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树</p>
<p>这种做法时间复杂度是O(logn*logn)，详见：<a href="https://labuladong.gitee.io/algo/2/21/48/">https://labuladong.gitee.io/algo/2/21/48/</a></p>
<h3 id="题目-36">题目<a hidden class="anchor" aria-hidden="true" href="#题目-36">#</a></h3>
<h4 id="1-完全二叉树的节点个数httpsleetcodecnproblemscount-complete-tree-nodes">1. <a href="https://leetcode.cn/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a><a hidden class="anchor" aria-hidden="true" href="#1-完全二叉树的节点个数httpsleetcodecnproblemscount-complete-tree-nodes">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-222/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-222/</a></p>
<h1 id="图">图<a hidden class="anchor" aria-hidden="true" href="#图">#</a></h1>
<h2 id="图的遍历">图的遍历<a hidden class="anchor" aria-hidden="true" href="#图的遍历">#</a></h2>
<h3 id="解法-37">解法<a hidden class="anchor" aria-hidden="true" href="#解法-37">#</a></h3>
<p>直接套模板，详见思想章节</p>
<h3 id="题目-37">题目<a hidden class="anchor" aria-hidden="true" href="#题目-37">#</a></h3>
<h4 id="1-所有可能的路径httpsleetcodecnproblemsall-paths-from-source-to-target">1. <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">所有可能的路径</a><a hidden class="anchor" aria-hidden="true" href="#1-所有可能的路径httpsleetcodecnproblemsall-paths-from-source-to-target">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-797/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-797/</a></p>
<h2 id="环检测">环检测<a hidden class="anchor" aria-hidden="true" href="#环检测">#</a></h2>
<h3 id="解法-38">解法<a hidden class="anchor" aria-hidden="true" href="#解法-38">#</a></h3>
<h4 id="思路一-1">思路一<a hidden class="anchor" aria-hidden="true" href="#思路一-1">#</a></h4>
<p>利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回</p>
<h4 id="思路二-1">思路二<a hidden class="anchor" aria-hidden="true" href="#思路二-1">#</a></h4>
<p>利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列，出队相当于访问该节点，环里的结点不会入队列，最后判断访问过的结点个数是否等于总结点个数即可</p>
<h3 id="题目-38">题目<a hidden class="anchor" aria-hidden="true" href="#题目-38">#</a></h3>
<h4 id="1-课程表httpsleetcodecnproblemscourse-schedule">1. <a href="https://leetcode.cn/problems/course-schedule/">课程表</a><a hidden class="anchor" aria-hidden="true" href="#1-课程表httpsleetcodecnproblemscourse-schedule">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-207/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-207/</a></p>
<h2 id="拓扑排序">拓扑排序<a hidden class="anchor" aria-hidden="true" href="#拓扑排序">#</a></h2>
<h3 id="解法-39">解法<a hidden class="anchor" aria-hidden="true" href="#解法-39">#</a></h3>
<h4 id="思路一-2">思路一<a hidden class="anchor" aria-hidden="true" href="#思路一-2">#</a></h4>
<p>利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序</p>
<h4 id="思路二-2">思路二<a hidden class="anchor" aria-hidden="true" href="#思路二-2">#</a></h4>
<p>利用图的BFS，只不过只把入度为零的结点加入队列，出队相当于访问该节点，队列出队的序列就是该图的拓扑排序</p>
<h3 id="题目-39">题目<a hidden class="anchor" aria-hidden="true" href="#题目-39">#</a></h3>
<h4 id="1-课程表-iihttpsleetcodecnproblemscourse-schedule-ii">1. <a href="https://leetcode.cn/problems/course-schedule-ii/">课程表 II</a><a hidden class="anchor" aria-hidden="true" href="#1-课程表-iihttpsleetcodecnproblemscourse-schedule-ii">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-210/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-210/</a></p>
<h2 id="二分图的判断">二分图的判断<a hidden class="anchor" aria-hidden="true" href="#二分图的判断">#</a></h2>
<h3 id="解法-40">解法<a hidden class="anchor" aria-hidden="true" href="#解法-40">#</a></h3>
<p>利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节</p>
<h3 id="题目-40">题目<a hidden class="anchor" aria-hidden="true" href="#题目-40">#</a></h3>
<h4 id="1-判断二分图httpsleetcodecnproblemsis-graph-bipartite">1. <a href="https://leetcode.cn/problems/is-graph-bipartite/">判断二分图</a><a hidden class="anchor" aria-hidden="true" href="#1-判断二分图httpsleetcodecnproblemsis-graph-bipartite">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-785/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-785/</a></p>
<h4 id="2-可能的二分法httpsleetcodecnproblemspossible-bipartition">2. <a href="https://leetcode.cn/problems/possible-bipartition/">可能的二分法</a><a hidden class="anchor" aria-hidden="true" href="#2-可能的二分法httpsleetcodecnproblemspossible-bipartition">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-886/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-886/</a></p>
<h2 id="并查集">并查集<a hidden class="anchor" aria-hidden="true" href="#并查集">#</a></h2>
<h3 id="解法-41">解法<a hidden class="anchor" aria-hidden="true" href="#解法-41">#</a></h3>
<p>利用并查集模板即可，详见思想章节</p>
<h3 id="题目-41">题目<a hidden class="anchor" aria-hidden="true" href="#题目-41">#</a></h3>
<h4 id="1-被围绕的区域httpsleetcodecnproblemssurrounded-regions">1. <a href="https://leetcode.cn/problems/surrounded-regions/">被围绕的区域</a><a hidden class="anchor" aria-hidden="true" href="#1-被围绕的区域httpsleetcodecnproblemssurrounded-regions">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-130/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-130/</a></p>
<h4 id="2-等式方程的可满足性httpsleetcodecnproblemssatisfiability-of-equality-equations">2. <a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">等式方程的可满足性</a><a hidden class="anchor" aria-hidden="true" href="#2-等式方程的可满足性httpsleetcodecnproblemssatisfiability-of-equality-equations">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-990/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-990/</a></p>
<h4 id="3-寻找图中是否存在路径httpsleetcodecnproblemsfind-if-path-exists-in-graph">3. <a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/">寻找图中是否存在路径</a><a hidden class="anchor" aria-hidden="true" href="#3-寻找图中是否存在路径httpsleetcodecnproblemsfind-if-path-exists-in-graph">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1971/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1971/</a></p>
<h2 id="dijkstra问题">dijkstra问题<a hidden class="anchor" aria-hidden="true" href="#dijkstra问题">#</a></h2>
<h3 id="解法-42">解法<a hidden class="anchor" aria-hidden="true" href="#解法-42">#</a></h3>
<p>利用dijkstra模板即可，注意dijkstra的变种需要修改adj和weight函数，详见思想章节</p>
<h3 id="题目-42">题目<a hidden class="anchor" aria-hidden="true" href="#题目-42">#</a></h3>
<h4 id="1-网络延迟时间httpsleetcodecnproblemsnetwork-delay-time">1. <a href="https://leetcode.cn/problems/network-delay-time/">网络延迟时间</a><a hidden class="anchor" aria-hidden="true" href="#1-网络延迟时间httpsleetcodecnproblemsnetwork-delay-time">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-743/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-743/</a></p>
<h4 id="2-最小体力消耗路径httpsleetcodecnproblemspath-with-minimum-effort">2. <a href="https://leetcode.cn/problems/path-with-minimum-effort/">最小体力消耗路径</a><a hidden class="anchor" aria-hidden="true" href="#2-最小体力消耗路径httpsleetcodecnproblemspath-with-minimum-effort">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1631/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1631/</a></p>
<h4 id="3-概率最大的路径httpsleetcodecnproblemspath-with-maximum-probability">3. <a href="https://leetcode.cn/problems/path-with-maximum-probability/">概率最大的路径</a><a hidden class="anchor" aria-hidden="true" href="#3-概率最大的路径httpsleetcodecnproblemspath-with-maximum-probability">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1514/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1514/</a></p>
<h2 id="kruskal问题">kruskal问题<a hidden class="anchor" aria-hidden="true" href="#kruskal问题">#</a></h2>
<h3 id="解法-43">解法<a hidden class="anchor" aria-hidden="true" href="#解法-43">#</a></h3>
<p>利用kruskal算法即可，详见思想章节</p>
<h3 id="题目-43">题目<a hidden class="anchor" aria-hidden="true" href="#题目-43">#</a></h3>
<h4 id="1-连接所有点的最小费用httpsleetcodecnproblemsmin-cost-to-connect-all-points">1. <a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">连接所有点的最小费用</a><a hidden class="anchor" aria-hidden="true" href="#1-连接所有点的最小费用httpsleetcodecnproblemsmin-cost-to-connect-all-points">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/</a></p>
<h2 id="prim问题">prim问题<a hidden class="anchor" aria-hidden="true" href="#prim问题">#</a></h2>
<h3 id="解法-44">解法<a hidden class="anchor" aria-hidden="true" href="#解法-44">#</a></h3>
<p>利用prim算法即可，详见思想章节</p>
<h3 id="题目-44">题目<a hidden class="anchor" aria-hidden="true" href="#题目-44">#</a></h3>
<h4 id="1-连接所有点的最小费用httpsleetcodecnproblemsmin-cost-to-connect-all-points-1">1. <a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">连接所有点的最小费用</a><a hidden class="anchor" aria-hidden="true" href="#1-连接所有点的最小费用httpsleetcodecnproblemsmin-cost-to-connect-all-points-1">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/</a></p>
<h1 id="设计数据结构">设计数据结构<a hidden class="anchor" aria-hidden="true" href="#设计数据结构">#</a></h1>
<h2 id="lru">LRU<a hidden class="anchor" aria-hidden="true" href="#lru">#</a></h2>
<h3 id="解法-45">解法<a hidden class="anchor" aria-hidden="true" href="#解法-45">#</a></h3>
<p>直接套LRU模板即可，详见思想篇章</p>
<h3 id="题目-45">题目<a hidden class="anchor" aria-hidden="true" href="#题目-45">#</a></h3>
<h4 id="1-lru-缓存httpsleetcodecnproblemslru-cache">1. <a href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a><a hidden class="anchor" aria-hidden="true" href="#1-lru-缓存httpsleetcodecnproblemslru-cache">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-146/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-146/</a></p>
<h2 id="lfu">LFU<a hidden class="anchor" aria-hidden="true" href="#lfu">#</a></h2>
<h3 id="解法-46">解法<a hidden class="anchor" aria-hidden="true" href="#解法-46">#</a></h3>
<p>直接套LFU模板即可，详见思想篇章</p>
<h3 id="题目-46">题目<a hidden class="anchor" aria-hidden="true" href="#题目-46">#</a></h3>
<h4 id="1-lfu-缓存httpsleetcodecnproblemslfu-cache">1. <a href="https://leetcode.cn/problems/lfu-cache/">LFU 缓存</a><a hidden class="anchor" aria-hidden="true" href="#1-lfu-缓存httpsleetcodecnproblemslfu-cache">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-460/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-460/</a></p>
<h2 id="triemap和trieset">TrieMap和TrieSet<a hidden class="anchor" aria-hidden="true" href="#triemap和trieset">#</a></h2>
<h3 id="解法-47">解法<a hidden class="anchor" aria-hidden="true" href="#解法-47">#</a></h3>
<p>直接套模板即可，详见思想篇章</p>
<h3 id="题目-47">题目<a hidden class="anchor" aria-hidden="true" href="#题目-47">#</a></h3>
<h4 id="1-实现-trie-前缀树httpsleetcodecnproblemsimplement-trie-prefix-tree">1. <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)</a><a hidden class="anchor" aria-hidden="true" href="#1-实现-trie-前缀树httpsleetcodecnproblemsimplement-trie-prefix-tree">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-208/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-208/</a></p>
<h4 id="2-单词替换httpsleetcodecnproblemsreplace-words">2. <a href="https://leetcode.cn/problems/replace-words/">单词替换</a><a hidden class="anchor" aria-hidden="true" href="#2-单词替换httpsleetcodecnproblemsreplace-words">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-648/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-648/</a></p>
<h4 id="3-添加与搜索单词---数据结构设计httpsleetcodecnproblemsdesign-add-and-search-words-data-structure">3. <a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">添加与搜索单词 - 数据结构设计</a><a hidden class="anchor" aria-hidden="true" href="#3-添加与搜索单词---数据结构设计httpsleetcodecnproblemsdesign-add-and-search-words-data-structure">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-211/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-211/</a></p>
<h4 id="4-键值映射httpsleetcodecnproblemsmap-sum-pairs">4. <a href="https://leetcode.cn/problems/map-sum-pairs/">键值映射</a><a hidden class="anchor" aria-hidden="true" href="#4-键值映射httpsleetcodecnproblemsmap-sum-pairs">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-677/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-677/</a></p>
<h2 id="数据流的中位数">数据流的中位数<a hidden class="anchor" aria-hidden="true" href="#数据流的中位数">#</a></h2>
<h3 id="解法-48">解法<a hidden class="anchor" aria-hidden="true" href="#解法-48">#</a></h3>
<p>用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：<a href="https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg">https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg</a></p>
<h3 id="题目-48">题目<a hidden class="anchor" aria-hidden="true" href="#题目-48">#</a></h3>
<h4 id="1-数据流的中位数httpsleetcodecnproblemsfind-median-from-data-stream">1. <a href="https://leetcode.cn/problems/find-median-from-data-stream/">数据流的中位数</a><a hidden class="anchor" aria-hidden="true" href="#1-数据流的中位数httpsleetcodecnproblemsfind-median-from-data-stream">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-295/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-295/</a></p>
<h2 id="单调栈问题">单调栈问题<a hidden class="anchor" aria-hidden="true" href="#单调栈问题">#</a></h2>
<h3 id="下一个更大元素">下一个更大元素<a hidden class="anchor" aria-hidden="true" href="#下一个更大元素">#</a></h3>
<h4 id="解法-49">解法<a hidden class="anchor" aria-hidden="true" href="#解法-49">#</a></h4>
<p>利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充当下一个更大元素的角色（中间去除的元素是无法充当这种角色的），那么此时栈顶就是当前元素下一个更大元素</p>
<h4 id="题目-49">题目<a hidden class="anchor" aria-hidden="true" href="#题目-49">#</a></h4>
<h5 id="1-下一个更大元素-ihttpsleetcodecnproblemsnext-greater-element-i">1. <a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a><a hidden class="anchor" aria-hidden="true" href="#1-下一个更大元素-ihttpsleetcodecnproblemsnext-greater-element-i">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-496/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-496/</a></p>
<h5 id="2-每日温度httpsleetcodecnproblemsdaily-temperatures">2. <a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a><a hidden class="anchor" aria-hidden="true" href="#2-每日温度httpsleetcodecnproblemsdaily-temperatures">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-739/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-739/</a></p>
<h5 id="3-下一个更大元素-iihttpsleetcodecnproblemsnext-greater-element-ii">3. <a href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a><a hidden class="anchor" aria-hidden="true" href="#3-下一个更大元素-iihttpsleetcodecnproblemsnext-greater-element-ii">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-503/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-503/</a></p>
<h2 id="单调队列问题">单调队列问题<a hidden class="anchor" aria-hidden="true" href="#单调队列问题">#</a></h2>
<h3 id="滑动窗口最大值">滑动窗口最大值<a hidden class="anchor" aria-hidden="true" href="#滑动窗口最大值">#</a></h3>
<h4 id="解法-50">解法<a hidden class="anchor" aria-hidden="true" href="#解法-50">#</a></h4>
<p>利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色），详见思想篇章</p>
<h4 id="题目-50">题目<a hidden class="anchor" aria-hidden="true" href="#题目-50">#</a></h4>
<h5 id="1-滑动窗口最大值httpsleetcodecnproblemssliding-window-maximum">1. <a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a><a hidden class="anchor" aria-hidden="true" href="#1-滑动窗口最大值httpsleetcodecnproblemssliding-window-maximum">#</a></h5>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-239/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-239/</a></p>
<h2 id="用栈实现队列">用栈实现队列<a hidden class="anchor" aria-hidden="true" href="#用栈实现队列">#</a></h2>
<h3 id="解法-51">解法<a hidden class="anchor" aria-hidden="true" href="#解法-51">#</a></h3>
<p>直接套栈实现队列模板即可，详见思想篇章</p>
<h3 id="题目-51">题目<a hidden class="anchor" aria-hidden="true" href="#题目-51">#</a></h3>
<h4 id="1-用栈实现队列httpsleetcodecnproblemsimplement-queue-using-stacks">1. <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a><a hidden class="anchor" aria-hidden="true" href="#1-用栈实现队列httpsleetcodecnproblemsimplement-queue-using-stacks">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-232/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-232/</a></p>
<h2 id="用队列实现栈">用队列实现栈<a hidden class="anchor" aria-hidden="true" href="#用队列实现栈">#</a></h2>
<h3 id="解法-52">解法<a hidden class="anchor" aria-hidden="true" href="#解法-52">#</a></h3>
<p>直接套用队列实现栈的模板即可，详见思想篇章</p>
<h3 id="题目-52">题目<a hidden class="anchor" aria-hidden="true" href="#题目-52">#</a></h3>
<h4 id="1-用队列实现栈httpsleetcodecnproblemsimplement-stack-using-queues">1. <a href="https://leetcode.cn/problems/implement-stack-using-queues/">用队列实现栈</a><a hidden class="anchor" aria-hidden="true" href="#1-用队列实现栈httpsleetcodecnproblemsimplement-stack-using-queues">#</a></h4>
<p>题解详见：<a href="https://blog.zhangmengyang.tk/posts/leetcode/leetcode-225/">https://blog.zhangmengyang.tk/posts/leetcode/leetcode-225/</a></p>
<h1 id="思想-1">思想<a hidden class="anchor" aria-hidden="true" href="#思想-1">#</a></h1>
<h2 id="双指针">双指针<a hidden class="anchor" aria-hidden="true" href="#双指针">#</a></h2>
<p>就是两个指针，分为左右指针和快慢指针，只要数组有序，就应该想到双指针技巧</p>
<h3 id="左右指针">左右指针<a hidden class="anchor" aria-hidden="true" href="#左右指针">#</a></h3>
<p>两个指针一个左一个右</p>
<h4 id="二分查找-1">二分查找<a hidden class="anchor" aria-hidden="true" href="#二分查找-1">#</a></h4>
<p>就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度</p>
<h5 id="经典思路">经典思路<a hidden class="anchor" aria-hidden="true" href="#经典思路">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这种就是一边缩减搜索空间，一边寻找要找的元素。</p>
<p>但是有时候问题并不是这么简单，比如寻找一个可能在数组里不存在，或者是找边界这样的问题，这时使用进阶思路 ，在循环体内排除一定不存在目标元素的区间会更简单一些。</p>
<p>经典思路是寻找元素</p>
<p>进阶思路是排除n-1个不可能的元素</p>
<h5 id="进阶思路">进阶思路<a hidden class="anchor" aria-hidden="true" href="#进阶思路">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 此思路搜索空间为[left, right]，闭闭空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 循环条件写成left&lt;right，因为循环体内把数组分成两部分，那么一定会达到left和right重合的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 所以循环条件写成left&lt;right，可以保证退出循环时left等于right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 求中点，left=mid+1时不需要向上取整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// left=mid时需要向上取整，记忆方式：left和mid要有一个+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//int mid = left + (right - left + 1) / 2;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 下面是核心逻辑，分成两个区间是因为这样扩展性更强
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这块主要就是筛选不可能的区间，然后缩减搜索空间，具体问题具体分析，注意left没加一时mid要加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 左边界，记忆方式：左边界是小于等于，下面的语句是...=mid，第二个语句和第一个语句互补，left没加一时mid要加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="cm">/*if (target &lt;= nums[mid]) {
</span></span></span><span class="line"><span class="cl"><span class="cm">                right = mid;
</span></span></span><span class="line"><span class="cl"><span class="cm">            } else {
</span></span></span><span class="line"><span class="cl"><span class="cm">                left = mid + 1;
</span></span></span><span class="line"><span class="cl"><span class="cm">            }*/</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 右边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="cm">/*if (target &gt;= nums[mid]) {
</span></span></span><span class="line"><span class="cl"><span class="cm">                left = mid;
</span></span></span><span class="line"><span class="cl"><span class="cm">            } else {
</span></span></span><span class="line"><span class="cl"><span class="cm">                right = mid -1;
</span></span></span><span class="line"><span class="cl"><span class="cm">            }*/</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 此时left一定等于right，所以返回left或者right都一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 排除了n-1个不可能的元素，还剩下[left, right]区间的元素，而left=right，就看剩下这个是不是要寻找的元素了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果该题一定存在指定的元素，那么下一步可以省略，直接return left就好了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h6 id="步骤">步骤<a hidden class="anchor" aria-hidden="true" href="#步骤">#</a></h6>
<ol>
<li>left和right分别设置为搜索空间的左右端点，注意是闭区间</li>
<li>循环条件写成left&lt;right</li>
<li>求中点，先写成<code>int mid = left + (right - left) / 2;</code></li>
<li>根据具体问题将搜索空间分成两部分，其中一部分必须是不可能的区域，然后根据这个不可能区域的特征写出第一个if，然后else里写和if互补的区域就好了，注意如果结果是left=mid，上面求中点要改成<code>int mid = left + (right - left + 1) / 2;</code></li>
<li>如果根据题意不能判断出一定存在寻找的元素，需要判断下<code>nums[left]</code>是不是寻找的元素，是则<code>return left</code>，否则未找到该元素；如果根据题意能判断出一定存在寻找的元素，那直接<code>return left</code>就好了</li>
</ol>
<h6 id="注意点">注意点<a hidden class="anchor" aria-hidden="true" href="#注意点">#</a></h6>
<ol>
<li>可以把这里的nums[i] = x看成一个函数，只要是具有单调性的函数都可以使用二分查找，比如y = func(x)，给定一个y让你找对应的x也可以用二分查找，二分查找的使用很广泛，只要函数有单调性即可</li>
<li>此思路搜索空间为[left, right]，闭闭空间</li>
<li>循环条件写成left&lt;right，因为循环体内把数组分成两部分，并且根据left的取值选择mid是向上或向下取整，那么一定会达到left和right重合的状态（把所有情况都模拟一边就可以得出这个结论），所以循环条件写成left&lt;right，可以保证退出循环时left等于right</li>
<li>求中点时，如果使用<code>(left + right) / 2</code>有可能相加溢出，为了防止溢出使用<code>left + (right - left) / 2</code></li>
<li>求中点时，left=mid+1时不需要向下取整，left=mid时需要向上取整，记忆方式：left和mid要有一个+1。这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left。right=mid时需要向下取整，原因同理</li>
<li>把搜索空间分成两个区间是因为这样扩展性更强</li>
<li>缩减搜索空间时，将搜索空间分成两部分需要注意分出不可能的区间，然后缩减搜索空间，具体问题具体分析，根据这个不可能区间的特征写出第一个if，然后else里写和if互补的区域</li>
<li>注意left没加一时mid要加一</li>
<li>退出循环后left和right相等，并且是唯一有希望的元素（只是有希望，有可能不是它，还要再判断一下，如果该题一定存在指定的元素，那么直接<code>return left</code>就好了）</li>
<li>对于寻找左右侧边界的二分查找，在缩减搜索空间时一定要考虑&gt;=或&lt;=的情况，因为这样才能使用找左或右侧这个性质，比如<code>target &lt;= nums[mid]</code>，可以寻找左边界，因为这时左边界不可能在mid右边所以直接<code>right=mid</code>就可以找到左边界，右边界同理。为什么找到的是左边界，也可以这么理解：<code>target &lt;= nums[mid]</code>-&gt;<code>right=mid</code>，所以<code>target &gt; nums[mid]</code>-&gt;<code>left=mid + 1</code>，此时left左边全部都小于target，因为退出循环时如果能找到target，left指向的就是target，又因为left左边全部都小于target，所以此时left指向左边界。找右边界同理。</li>
<li>对于寻找左侧边界的二分查找，说是寻找该元素的左侧边界，实际上是寻找大于等于target的所有元素的左侧边界，同理，寻找右侧边界的二分查找实际上是寻找小于等于target的所有元素的右侧边界，也可以理解成左侧边界的左边都小于target，右侧边界的右边都大于target，并且左右边界不一定等于target，所以如果target不存在时，左边界是比target大的第一个元素，右边界是比target小的第一个元素</li>
</ol>
<p>详见：leetcode笔记word版和<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/</a></p>
<h4 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h4>
<p>见上面各知识点章节</p>
<h3 id="快慢指针">快慢指针<a hidden class="anchor" aria-hidden="true" href="#快慢指针">#</a></h3>
<p>两个指针一个快一个慢</p>
<h4 id="滑动窗口-1">滑动窗口<a hidden class="anchor" aria-hidden="true" href="#滑动窗口-1">#</a></h4>
<p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p>
<h5 id="模板">模板<a hidden class="anchor" aria-hidden="true" href="#模板">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/* 滑动窗口算法模板 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">slidingWindow</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">Map</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">window</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里用&lt;而不用&lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素，所以这里其实是闭开窗口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取移入窗口的元素，并扩大窗口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">right</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 进行扩大窗口时数据的一系列更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// debug位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// System.out.println(&#34;left:&#34; + left + &#34;\t&#34; + &#34;right:&#34; + right);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 判断左侧窗口是否要收缩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">window</span> <span class="n">needs</span> <span class="n">shrink</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 获取移出窗口的元素，并收缩窗口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 进行收缩窗口时数据的一系列更新，一般与上面扩大窗口时数据更新相反
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">...</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h5 id="步骤-1">步骤<a hidden class="anchor" aria-hidden="true" href="#步骤-1">#</a></h5>
<ol>
<li>设置存储窗口内元素的数据结构，并且设置循环<code>while (right &lt; s.length())</code></li>
<li>扩大窗口，并更新相关的数据</li>
<li>判断是否需要收缩窗口，如需要，则收缩窗口，并更新相关的数据</li>
<li>退出循环后，返回相应的数据</li>
</ol>
<h5 id="注意点-1">注意点<a hidden class="anchor" aria-hidden="true" href="#注意点-1">#</a></h5>
<ol>
<li>此模板采用闭开区间，循环条件用&lt;而不用&lt;=是因为right当前位置的元素是我们下一个要入窗口的元素</li>
<li>收缩窗口和扩大窗口对数据的更新一般是相反的（更新顺序和加减等都是相反的）</li>
</ol>
<p>详见：<a href="https://labuladong.gitee.io/algo/2/20/27/">https://labuladong.gitee.io/algo/2/20/27/</a></p>
<h5 id="进阶">进阶<a hidden class="anchor" aria-hidden="true" href="#进阶">#</a></h5>
<p>==RABIN KARP 字符匹配算法==，详见：<a href="https://labuladong.gitee.io/algo/2/20/28/">https://labuladong.gitee.io/algo/2/20/28/</a></p>
<h4 id="其他-1">其他<a hidden class="anchor" aria-hidden="true" href="#其他-1">#</a></h4>
<p>见上面各知识点章节</p>
<h2 id="递归">递归<a hidden class="anchor" aria-hidden="true" href="#递归">#</a></h2>
<p>一个问题 = 规模更小的同类问题 + 扩展成该问题要解决的问题</p>
<p>这种情况就可以用递归，递归的关键是不要跳进递归，而是明确递归函数的定义</p>
<p>递归由两部分组成：递归出口和递归公式</p>
<p>注意递归需要递归出口（也就是base case）</p>
<p>值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。</p>
<h2 id="前缀和与差分">前缀和与差分<a hidden class="anchor" aria-hidden="true" href="#前缀和与差分">#</a></h2>
<p>前缀和数组的差分是原数组，差分数组的前缀和是原数组，两者互逆。</p>
<h3 id="前缀和">前缀和<a hidden class="anchor" aria-hidden="true" href="#前缀和">#</a></h3>
<p>对于一个数组，求此数组[left, right]区域内的和时，不需要从left&ndash;right逐个相加，直接right+1前的和减去left前的和即可，要想使用这种方式就得有一个前缀和数组，用来存该数组前k个的和。注意也可能是二维数组，稍作修改即可。</p>
<p><strong>主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p>
<p>详见：<a href="https://labuladong.gitee.io/algo/2/20/24/">https://labuladong.gitee.io/algo/2/20/24/</a></p>
<h4 id="标准模板">标准模板<a hidden class="anchor" aria-hidden="true" href="#标准模板">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JAVA" data-lang="JAVA"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">NumArray</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">[]</span> <span class="n">preSum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">preSum</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">preSum</span><span class="o">[</span><span class="n">right</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="差分数组-1">差分数组<a hidden class="anchor" aria-hidden="true" href="#差分数组-1">#</a></h3>
<p><strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong></p>
<p>类似前缀和构造的 <code>preSum</code> 数组，我们先对 <code>nums</code> 数组构造一个 <code>diff</code> 差分数组，<strong><code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 之差</strong>，通过这个 <code>diff</code> 差分数组是可以反推出原始数组 <code>nums</code> 的，理解：diff[0]就是原数组的第一个元素，其他元素就是比前一个元素高多少</p>
<p><strong>这样构造差分数组 <code>diff</code>，就可以快速进行区间增减的操作</strong>，如果你想对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code> 即可</p>
<p><strong>原理很简单，回想 <code>diff</code> 数组反推 <code>nums</code> 数组的过程，<code>diff[i] += 3</code> 意味着给 <code>nums[i..]</code> 所有的元素都加了 3，然后 <code>diff[j+1] -= 3</code> 又意味着对于 <code>nums[j+1..]</code> 所有元素再减 3，那综合起来，就是对 <code>nums[i..j]</code> 中的所有元素都加 3 了</strong></p>
<p>详见：<a href="https://labuladong.gitee.io/algo/2/20/25/">https://labuladong.gitee.io/algo/2/20/25/</a></p>
<h4 id="标准模板-1">标准模板<a hidden class="anchor" aria-hidden="true" href="#标准模板-1">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Difference</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Difference</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">assert</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">diff</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span> <span class="o">&lt;</span> <span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">diff</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">-=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">result</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="二叉树-1">二叉树<a hidden class="anchor" aria-hidden="true" href="#二叉树-1">#</a></h2>
<h3 id="前中后序理解">前中后序理解<a hidden class="anchor" aria-hidden="true" href="#前中后序理解">#</a></h3>
<p>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点：</p>
<p>前序位置的代码在刚刚进入一个二叉树节点的时候执行；</p>
<p>后序位置的代码在将要离开一个二叉树节点的时候执行；</p>
<p>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</p>
<p><img loading="lazy" src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/2.jpeg" alt="img"  />
</p>
<p>比如快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历</p>
<h3 id="遍历模板">遍历模板<a hidden class="anchor" aria-hidden="true" href="#遍历模板">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 前序位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 中序位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 后序位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>多叉树的遍历模板：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/* 多叉树遍历框架 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 前序位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">traverse</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 后序位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><h3 id="做题思路">做题思路<a hidden class="anchor" aria-hidden="true" href="#做题思路">#</a></h3>
<p>有两种思路，分别是<strong>分解问题</strong>和<strong>遍历二叉树</strong></p>
<p>遇到一道二叉树的题目时的通用思考过程是：</p>
<p>1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。</p>
<p>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)，这样的话递归函数就会一直分解这个问题，直到该问题不能再分解，所以我们还需要考虑base case(递归出口)。</p>
<p>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。</p>
<h3 id="后序位置的特殊之处">后序位置的特殊之处<a hidden class="anchor" aria-hidden="true" href="#后序位置的特殊之处">#</a></h3>
<p>因为前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的，所以：</p>
<p>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。</p>
<h3 id="层序遍历-1">层序遍历<a hidden class="anchor" aria-hidden="true" href="#层序遍历-1">#</a></h3>
<p>就是一个BFS，可以计算一些类似结点与root之间的距离的问题。</p>
<h4 id="模板-1">模板<a hidden class="anchor" aria-hidden="true" href="#模板-1">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 输入一棵二叉树的根节点，层序遍历这棵二叉树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">levelTraverse</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从上到下遍历二叉树的每一层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从左到右遍历每一层的每个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将下一层节点放入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>            <span class="c1">// 注意不要把null放队列里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>        <span class="c1">// 注意不要把null放队列里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="注意点-2">注意点<a hidden class="anchor" aria-hidden="true" href="#注意点-2">#</a></h3>
<p>前序中序，后序中序可以唯一确定一颗二叉树，或者带空指针的任意一个遍历序列都可以唯一确定一棵二叉树</p>
<p>前序后序不能唯一确定一颗二叉树，因为：</p>
<p>当节点左右子树都存在时，可以确定左右子树，但是当其中一个为空时，无法确定不为空的子树是左子树还是右子树</p>
<h3 id="二叉搜索树">二叉搜索树<a hidden class="anchor" aria-hidden="true" href="#二叉搜索树">#</a></h3>
<h4 id="性质">性质<a hidden class="anchor" aria-hidden="true" href="#性质">#</a></h4>
<p>二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列，并且中序遍历到一个结点时，比该结点小的结点全部都遍历过了，这个性质可以用于二叉搜索树的累加上，二叉搜索树最左边是最小的结点，最右边是最大的结点</p>
<h4 id="合法性">合法性<a hidden class="anchor" aria-hidden="true" href="#合法性">#</a></h4>
<p>利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去，如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p>
<h4 id="增删改查">增删改查<a hidden class="anchor" aria-hidden="true" href="#增删改查">#</a></h4>
<p>在二叉树递归框架之上，扩展出一套 BST 代码框架：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">BST</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 找到目标，做点什么
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">BST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">BST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>根据代码框架掌握了 BST 的增删查改操作。</p>
<h2 id="图-1">图<a hidden class="anchor" aria-hidden="true" href="#图-1">#</a></h2>
<h3 id="存储方式">存储方式<a hidden class="anchor" aria-hidden="true" href="#存储方式">#</a></h3>
<h4 id="邻接表">邻接表<a hidden class="anchor" aria-hidden="true" href="#邻接表">#</a></h4>
<p>优点：省空间</p>
<h4 id="邻接矩阵">邻接矩阵<a hidden class="anchor" aria-hidden="true" href="#邻接矩阵">#</a></h4>
<p>优点：可以随机访问</p>
<h3 id="遍历模板-1">遍历模板<a hidden class="anchor" aria-hidden="true" href="#遍历模板-1">#</a></h3>
<h4 id="dfs">DFS<a hidden class="anchor" aria-hidden="true" href="#dfs">#</a></h4>
<p>和多叉树类似，只不过需要记录访问过的结点</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 记录被遍历过的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 记录从起点到当前节点的路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">onPath</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 图遍历框架 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">Graph</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 进入结点时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 经过节点 s，标记为已遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 做选择：标记节点 s 在路径上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">neighbors</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">neighbor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 离开结点时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 撤销选择：节点 s 离开路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="bfs">BFS<a hidden class="anchor" aria-hidden="true" href="#bfs">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 记录被遍历过的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">Graph</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">neighbors</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">neighbor</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="图的拓扑排序">图的拓扑排序<a hidden class="anchor" aria-hidden="true" href="#图的拓扑排序">#</a></h3>
<h4 id="拓扑排序-1">拓扑排序<a hidden class="anchor" aria-hidden="true" href="#拓扑排序-1">#</a></h4>
<p>直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的</p>
<p>如果一个图里存在环，是无法进行拓扑排序的，反之，如果图里没有环那么一定可以拓扑排序</p>
<p>注意有向无环图不一定是树</p>
<h4 id="如何拓扑排序">如何拓扑排序<a hidden class="anchor" aria-hidden="true" href="#如何拓扑排序">#</a></h4>
<ol>
<li>将后序遍历的结果进行反转，就是拓扑排序的结果。至于原因由于需要严格的数学证明，就不用看了，可以自己画个图看一看</li>
<li>利用图的BFS，每次只让入度为零的结点入队列，此时遍历的结果就是拓扑排序的结果</li>
</ol>
<h3 id="二分图">二分图<a hidden class="anchor" aria-hidden="true" href="#二分图">#</a></h3>
<p><img loading="lazy" src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e5%9b%be/0.png" alt="img"  />
</p>
<p>如图所示就是二分图，可以使用染色法判断一个图是否为二分图，如下所示：</p>
<p><img loading="lazy" src="https://labuladong.gitee.io/algo/images/algo4/1.jpg" alt="img"  />
</p>
<p>在某些场景下二分图也可以作为存储键值对的数据结构（符号表）</p>
<h4 id="判断二分图染色模板">判断二分图（染色）模板<a hidden class="anchor" aria-hidden="true" href="#判断二分图染色模板">#</a></h4>
<p>其实就是图的遍历，只不过一边遍历一边染色</p>
<h5 id="dfs-1">DFS<a hidden class="anchor" aria-hidden="true" href="#dfs-1">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/* 判断二分图框架(DFS) */</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">color</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">Graph</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">visited</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历节点 v 的所有相邻节点 neighbor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">neighbors</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">neighbor</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 相邻节点 neighbor 没有被访问过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 那么应该给节点 neighbor 涂上和节点 v 不同的颜色
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">color</span><span class="o">[</span><span class="n">neighbor</span><span class="o">]</span> <span class="o">=</span> <span class="n">color</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">neighbor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 相邻节点 neighbor 已经被访问过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 那么应该比较节点 neighbor 和节点 v 的颜色
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 若相同，则此图不是二分图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h5 id="bfs-1">BFS<a hidden class="anchor" aria-hidden="true" href="#bfs-1">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/* 判断二分图框架(BFS) */</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">color</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">Graph</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Deque</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="n">visited</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从节点 v 向所有相邻节点扩散
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 相邻节点 w 没有被访问过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 那么应该给节点 w 涂上和节点 v 不同的颜色
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">color</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">color</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 标记 w 节点，并放入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">visited</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 相邻节点 w 已经被访问过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 根据 v 和 w 的颜色判断是否是二分图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">color</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">==</span> <span class="n">color</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 若相同，则此图不是二分图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="并查集-1">并查集<a hidden class="anchor" aria-hidden="true" href="#并查集-1">#</a></h3>
<p>就是可以1、方便的合并两个集合，2、快速的判断两个结点是否处于一个集合中的树状数据结构，长下面这个样子</p>
<p><img loading="lazy" src="https://labuladong.gitee.io/algo/images/unionfind/4.jpg" alt="img"  />
</p>
<h4 id="模板-2">模板<a hidden class="anchor" aria-hidden="true" href="#模板-2">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">UF</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 连通分量个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 存储每个节点的父节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// n 为图中节点的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="nf">UF</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将节点 p 和节点 q 连通
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">parent</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootP</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 两个连通分量合并成一个连通分量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">count</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断节点 p 和节点 q 是否连通
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回图中的连通分量个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这里做了路径压缩的优化，在 <code>find</code> 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 <code>size</code> 数组的平衡优化。</p>
<h3 id="dijkstra问题-1">dijkstra问题<a hidden class="anchor" aria-hidden="true" href="#dijkstra问题-1">#</a></h3>
<p>dijkstra是求最短路径的算法，实际上是由图的BFS演化而来，模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">State</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 图节点的 id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从 start 节点到当前节点的距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">distFromStart</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">State</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distFromStart</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">distFromStart</span> <span class="o">=</span> <span class="n">distFromStart</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 返回节点 from 到节点 to 之间的边的权重
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">weight</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 输入节点 s 返回 s 的相邻节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 图中节点的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">V</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录最短路径的权重，你可以理解为 dp table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">[]</span> <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">V</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 求最小值，所以 dp table 初始化为正无穷
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">distTo</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// base case，start 到 start 的最短距离就是 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">distTo</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 优先级队列，distFromStart 较小的排在前面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">distFromStart</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">distFromStart</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从起点 start 开始进行 BFS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">State</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">0</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">State</span> <span class="n">curState</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">curNodeID</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">curDistFromStart</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">distFromStart</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果只需要start到end的最短距离加上这句就可以了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// if (curNodeID == end) {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// return curDistFromStart;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">curDistFromStart</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 已经有一条更短的路径到达 curNode 节点了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">continue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 curNode 的相邻节点装入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">nextNodeID</span> <span class="o">:</span> <span class="n">adj</span><span class="o">(</span><span class="n">curNodeID</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 看看从 curNode 达到 nextNode 的距离是否会更短
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">distToNextNode</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">]</span> <span class="o">+</span> <span class="n">weight</span><span class="o">(</span><span class="n">curNodeID</span><span class="o">,</span> <span class="n">nextNodeID</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distToNextNode</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 更新 dp table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">distTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">=</span> <span class="n">distToNextNode</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 将这个节点以及距离放入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">State</span><span class="o">(</span><span class="n">nextNodeID</span><span class="o">,</span> <span class="n">distToNextNode</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">distTo</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>解释：同一个结点可能会入队多个State，一定会先遍历到dist较小的那个，结点的第一次遍历，就确定了这个结点的最短距离，然后按照这个最短距离刷新start到其他节点的距离，之后这个结点的任务就算是结束了，以后再碰到这个结点直接continue就可以了。</p>
<p>注意dijkstra的变种需要修改adj和weight函数</p>
<h3 id="kruskal问题-1">kruskal问题<a hidden class="anchor" aria-hidden="true" href="#kruskal问题-1">#</a></h3>
<p>用于求解最小生成树问题，主要思路就是先把边按权重排序，从小到大添加边，同时判断边添加后是否有环（这一步可以用并查集做），模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">minimumCost</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">UF</span> <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UF</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对所有边按照权重从小到大排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">edges</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">2</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="n">2</span><span class="o">]));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录最小生成树的权重之和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">mst</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="n">2</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 若这条边会产生环，则不能加入 mst
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">connected</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 若这条边不会产生环，则属于最小生成树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">mst</span> <span class="o">+=</span> <span class="n">weight</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 保证所有节点都被连通
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// uf.count() == 1 说明所有节点被连通
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">uf</span><span class="o">.</span><span class="na">count</span><span class="o">()</span> <span class="o">==</span> <span class="n">1</span> <span class="o">?</span> <span class="n">mst</span> <span class="o">:</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">UF</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 见上文并查集模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>详见：<a href="https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w">https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w</a></p>
<h3 id="prim问题-1">prim问题<a hidden class="anchor" aria-hidden="true" href="#prim问题-1">#</a></h3>
<p>用于求解最小生成树问题，原理就是横切边中最小的一定是最小生成树的一条边，可以每次添加一个结点找横切边（这样比较方便），然后把最小生成树的边都找到就可以了，模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Prim</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 核心数据结构，存储「横切边」的优先级队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">pq</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">inMST</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录最小生成树的权重和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">weightSum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// graph 是用邻接表表示的一幅图，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// graph[s] 记录节点 s 所有相邻的边，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 三元组 int[]{from, to, weight} 表示一条边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;[]</span> <span class="n">graph</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Prim</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;[]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 按照边的权重从小到大排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">2</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="n">2</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="o">});</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 图中有 n 个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">inMST</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 随便从一个点开始切分都可以，我们不妨从节点 0 开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">inMST</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cut</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 不断进行切分，向最小生成树中添加边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="n">2</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">inMST</span><span class="o">[</span><span class="n">to</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 节点 to 已经在最小生成树中，跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 否则这条边会产生环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">continue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将边 edge 加入最小生成树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">weightSum</span> <span class="o">+=</span> <span class="n">weight</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">inMST</span><span class="o">[</span><span class="n">to</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 节点 to 加入后，进行新一轮切分，会产生更多横切边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cut</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 s 的横切边加入优先队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">cut</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 遍历 s 的邻边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">inMST</span><span class="o">[</span><span class="n">to</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 相邻接点 to 已经在最小生成树中，跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 否则这条边会产生环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">continue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 加入横切边队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">edge</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最小生成树的权重和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">weightSum</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">weightSum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断最小生成树是否包含图中的所有节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">allConnected</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inMST</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(!</span><span class="n">inMST</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>详见：<a href="https://labuladong.gitee.io/algo/2/22/55/">https://labuladong.gitee.io/algo/2/22/55/</a></p>
<h2 id="回溯">回溯<a hidden class="anchor" aria-hidden="true" href="#回溯">#</a></h2>
<p>回溯和DFS的区别：</p>
<p>回溯关注的是树枝，DFS关注的是结点，反映到代码上：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// DFS 算法，关注点在节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="o">(</span><span class="s">&#34;进入节点 %s&#34;</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">traverse</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="o">(</span><span class="s">&#34;离开节点 %s&#34;</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 回溯算法，关注点在树枝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 做选择
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">printf</span><span class="o">(</span><span class="s">&#34;从 %s 到 %s&#34;</span><span class="o">,</span> <span class="n">root</span><span class="o">,</span> <span class="n">child</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">backtrack</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 撤销选择
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">printf</span><span class="o">(</span><span class="s">&#34;从 %s 到 %s&#34;</span><span class="o">,</span> <span class="n">child</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="设计数据结构-1">设计数据结构<a hidden class="anchor" aria-hidden="true" href="#设计数据结构-1">#</a></h2>
<h3 id="lru-1">LRU<a hidden class="anchor" aria-hidden="true" href="#lru-1">#</a></h3>
<p>即Least Recently Used，也就是每次淘汰那些最久没被使用的数据，主要就是利用了哈希链表（在Java中是<code>LinkedHashMap</code>）这种数据结构，如下图所示：</p>
<p><img loading="lazy" src="https://labuladong.gitee.io/algo/images/LRU%e7%ae%97%e6%b3%95/4.jpg" alt="img"  />
</p>
<p>手写轮子模板：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// key -&gt; Node(key, val)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">DoubleList</span> <span class="n">cache</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最大容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DoubleList</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将该数据提升为最近使用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">makeRecently</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="na">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 删除旧的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">deleteKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 新插入的数据为最近使用的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">addRecently</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 删除最久未使用的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">removeLeastRecently</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 添加为最近使用的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">addRecently</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 将某个 key 提升为最近使用的 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">makeRecently</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 先从链表中删除这个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 重新插到队尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cache</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 添加最近使用的元素 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addRecently</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 链表尾部就是最近使用的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cache</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 别忘了在 map 中添加 key 的映射
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 删除某一个 key */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">deleteKey</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从链表中删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从 map 中删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 删除最久未使用的元素 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeLeastRecently</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 链表头部的第一个元素就是最久未使用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Node</span> <span class="n">deletedNode</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 同时别忘了从 map 中删除它的 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">deletedKey</span> <span class="o">=</span> <span class="n">deletedNode</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">deletedKey</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="n">prev</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">class</span> <span class="nc">DoubleList</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 头尾虚节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">;</span>  
</span></span><span class="line"><span class="cl">        <span class="c1">// 链表元素数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="nf">DoubleList</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 初始化双向链表的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 在链表尾部添加节点 x，时间 O(1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLast</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">size</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 删除链表中的 x 节点（x 一定存在）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 由于是双链表且给的是目标 Node 节点，时间 O(1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">size</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 删除链表中第一个节点，并返回该节点，时间 O(1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">public</span> <span class="n">Node</span> <span class="nf">removeFirst</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">Node</span> <span class="n">first</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">remove</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回链表长度，时间 O(1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用<code>LinkedHashMap</code>模板：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(!</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 key 变为最近使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">makeRecently</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 修改 key 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将 key 变为最近使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">makeRecently</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">cap</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 链表头部就是最久未使用的 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">oldestKey</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">oldestKey</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将新的 key 添加链表尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">makeRecently</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 删除 key，重新插入到队尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="lfu-1">LFU<a hidden class="anchor" aria-hidden="true" href="#lfu-1">#</a></h3>
<p>Least Frequently Used，也就是每次淘汰那些使用次数最少的数据，主要利用了keyToVal，keyToFreq，freqToKeys三个数据结构相互配合，详见：<a href="https://mp.weixin.qq.com/s/oXv03m1J8TwtHwMJEZ1ApQ">https://mp.weixin.qq.com/s/oXv03m1J8TwtHwMJEZ1ApQ</a>，模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">LFUCache</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// key 到 val 的映射，我们后文称为 KV 表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">keyToVal</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// key 到 freq 的映射，我们后文称为 KF 表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">keyToFreq</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// freq 到 key 列表的映射，我们后文称为 FK 表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">LinkedHashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">freqToKeys</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录最小的频次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">minFreq</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录 LFU 缓存的最大容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">LFUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">keyToVal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">keyToFreq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">freqToKeys</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(!</span><span class="n">keyToVal</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 增加 key 对应的 freq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">increaseFreq</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">keyToVal</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 若 key 已存在，修改对应的 val 即可 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">keyToVal</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">keyToVal</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// key 对应的 freq 加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">increaseFreq</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* key 不存在，需要插入 */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 容量已满的话需要淘汰一个 freq 最小的 key */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">&lt;=</span> <span class="n">keyToVal</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">removeMinFreqKey</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 插入 key 和 val，对应的 freq 为 1 */</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 插入 KV 表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">keyToVal</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 插入 KF 表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">keyToFreq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 插入 FK 表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">&lt;&gt;());</span>
</span></span><span class="line"><span class="cl">        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 插入新 key 后最小的 freq 肯定是 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">increaseFreq</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">keyToFreq</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 更新 KF 表 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">keyToFreq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">freq</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 更新 FK 表 */</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 key 从 freq 对应的列表中删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 key 加入 freq + 1 对应的列表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">freq</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">&lt;&gt;());</span>
</span></span><span class="line"><span class="cl">        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span> <span class="o">+</span> <span class="n">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果 freq 对应的列表空了，移除这个 freq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">freqToKeys</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">freq</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果这个 freq 恰好是 minFreq，更新 minFreq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">freq</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeMinFreqKey</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// freq 最小的 key 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">LinkedHashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">keyList</span> <span class="o">=</span> <span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 其中最先被插入的那个 key 就是该被淘汰的 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">deletedKey</span> <span class="o">=</span> <span class="n">keyList</span><span class="o">.</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 更新 FK 表 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">keyList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">deletedKey</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">keyList</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">freqToKeys</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 问：这里需要更新 minFreq 的值吗？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这里不用修改minFreq因为后面会置为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 更新 KV 表 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">keyToVal</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">deletedKey</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 更新 KF 表 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">keyToFreq</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">deletedKey</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="triemap和trieset-1">TrieMap和TrieSet<a hidden class="anchor" aria-hidden="true" href="#triemap和trieset-1">#</a></h3>
<p>Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。结构如下所示：</p>
<p><img loading="lazy" src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdHbPt3iaYMdmqUMxEpq0F5AMuKFmpJEB0gM7FJuVjAicfIoWB7HtdISJ18bcqKfwlnibeth3ZibVD35Sg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"  />
</p>
<p>底层是Trie树的Map就是TrieMap，TrieMap就是key是字符串，value是任何类型的map，TrieSet就是没用到value的TrieMap，详见：<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247495471&amp;idx=1&amp;sn=fd180d7e207e92a87a9c9cce69b8cdb9">https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247495471&amp;idx=1&amp;sn=fd180d7e207e92a87a9c9cce69b8cdb9</a></p>
<p>TrieMap模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">TrieMap</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ASCII 码个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">256</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前存在 Map 中的键值对个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Trie 树的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">V</span> <span class="n">val</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">[</span><span class="n">R</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/***** 增/改 *****/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在 map 中添加或修改键值对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(!</span><span class="n">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 新增键值对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">size</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 需要一个额外的辅助函数，并接收其返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">put</span><span class="o">(</span><span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果树枝不存在，新建
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// key 的路径已插入完成，将值 val 存入节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 递归插入子节点，并接收返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/***** 删 *****/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在 Map 中删除 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(!</span><span class="n">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 递归修改数据结构要接收函数的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root</span> <span class="o">=</span> <span class="n">remove</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">size</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">remove</span><span class="o">(</span><span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 找到了 key 对应的 TrieNode，删除 val
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 递归去子树进行删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">remove</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 后序位置，递归路径上的节点可能需要被清理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果该 TireNode 存储着 val，不需要被清理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查该 TrieNode 是否还有后缀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 只要存在一个子节点（后缀树枝），就不需要被清理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 既没有存储 val，也没有后缀树枝，则该节点需要被清理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/***** 查 *****/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 搜索 key 对应的值，不存在则返回 null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从 root 开始搜索 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// x 为空或 x 的 val 字段为空都说明 key 没有对应的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断 key 是否存在在 Map 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsKey</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断是和否存在前缀为 prefix 的键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasKeyWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 只要能找到一个节点，就是存在前缀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">getNode</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在所有键中寻找 query 的最短前缀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">shortestPrefixOf</span><span class="o">(</span><span class="n">String</span> <span class="n">query</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从节点 node 开始搜索 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">query</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 无法向下搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 找到一个键是 query 的前缀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 向下搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果 query 本身就是一个键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">query</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在所有键中寻找 query 的最长前缀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">longestPrefixOf</span><span class="o">(</span><span class="n">String</span> <span class="n">query</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 记录前缀的最大长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 从节点 node 开始搜索 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">query</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 无法向下搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 找到一个键是 query 的前缀，更新前缀的最大长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">max_len</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 向下搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果 query 本身就是一个键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">query</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">max_len</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 搜索前缀为 prefix 的所有键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 找到匹配 prefix 在 Trie 树中的那个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">prefix</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// DFS 遍历以 x 为根的这棵 Trie 树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">traverse</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="n">prefix</span><span class="o">),</span> <span class="n">res</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历以 node 节点为根的 Trie 树，找到所有键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="n">StringBuilder</span> <span class="n">path</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 到达 Trie 树底部叶子结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 找到一个 key，添加到结果列表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 回溯算法遍历框架
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 做选择
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">path</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 撤销选择
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">path</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通配符 . 匹配任意字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPattern</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(),</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="n">StringBuilder</span> <span class="n">path</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 树枝不存在，即匹配失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// pattern 匹配完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果这个节点存储着 val，则找到一个匹配的键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// pattern[i] 是通配符，可以变化成任意字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 多叉树（回溯算法）遍历框架
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">path</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">path</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// pattern[i] 是普通字符 c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">path</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">path</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断是和否存在前缀为 prefix 的键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasKeyWithPattern</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从 root 节点开始匹配 pattern[0..]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">hasKeyWithPattern</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">hasKeyWithPattern</span><span class="o">(</span><span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 树枝不存在，即匹配失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 模式串走到头了，看看匹配到的是否是一个键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 没有遇到通配符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从 node.children[c] 节点开始匹配 pattern[i+1..]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">hasKeyWithPattern</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 遇到通配符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">hasKeyWithPattern</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 都没有匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">getNode</span><span class="o">(</span><span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">TrieNode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从节点 node 开始搜索 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 无法向下搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 向下搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>TrieSet模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">TrieSet</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 值的类型可以随便设置，我参考 Java 标准库设置成 Object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">TrieMap</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/***** 增 *****/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在集合中添加元素 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/***** 删 *****/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从集合中删除元素 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/***** 查 *****/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断元素 key 是否存在集合中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在集合中寻找 query 的最短前缀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">shortestPrefixOf</span><span class="o">(</span><span class="n">String</span> <span class="n">query</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">shortestPrefixOf</span><span class="o">(</span><span class="n">query</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在集合中寻找 query 的最长前缀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">longestPrefixOf</span><span class="o">(</span><span class="n">String</span> <span class="n">query</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">longestPrefixOf</span><span class="o">(</span><span class="n">query</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在集合中搜索前缀为 prefix 的所有元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">keysWithPrefix</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断集合中是否存在前缀为 prefix 的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasKeyWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">hasKeyWithPrefix</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPattern</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">keysWithPattern</span><span class="o">(</span><span class="n">pattern</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasKeyWithPattern</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">hasKeyWithPattern</span><span class="o">(</span><span class="n">pattern</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回集合中元素的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="单调栈">单调栈<a hidden class="anchor" aria-hidden="true" href="#单调栈">#</a></h3>
<p>就是元素单调递增或递减的栈，比如单减栈，入栈的时候将小于入栈元素的栈顶出栈，就可以保证栈的单调递减，一般可以用在「下一个更大元素」，「上一个更小元素」等问题上，「下一个更大元素」模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">[]</span> <span class="nf">nextGreaterElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 存放答案的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 倒着往栈里放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 判定个子高矮
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 矮个起开，反正也被挡着了。。。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// nums[i] 身后的更大元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="o">-</span><span class="n">1</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="单调队列">单调队列<a hidden class="anchor" aria-hidden="true" href="#单调队列">#</a></h3>
<p>就是元素单调递增或递减的队列，比如单减队列，入队的时候将小于入队元素的队尾出队，就可以保证队的单调递减，一般可以用在「滑动窗口最大值」问题上，模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/* 单调队列的实现 */</span>
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MonotonicQueue</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">maxq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将小于 n 的元素全部删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(!</span><span class="n">maxq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">maxq</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxq</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 然后将 n 加入尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">maxq</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">maxq</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">poll</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">maxq</span><span class="o">.</span><span class="na">getFirst</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxq</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="二叉堆">二叉堆<a hidden class="anchor" aria-hidden="true" href="#二叉堆">#</a></h3>
<p>就是最大堆或最小堆，是一颗完全二叉树，所以可以放在数组里面，用简单的计算就能得到结点的父节点和左右孩子，基于二叉堆开发出了优先队列，优先队列插入时将插入结点放到数组最后面然后对该节点执行上浮操作，删除时将堆顶删除，然后将数组最后面的结点放到堆顶的位置，然后对堆顶做下沉操作。模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPQ</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">Key</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 存储元素的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Key</span><span class="o">[]</span> <span class="n">pq</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前 Priority Queue 中的元素个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 索引 0 不用，所以多分配一个空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pq</span> <span class="o">=</span> <span class="o">(</span><span class="n">Key</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">cap</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 返回当前队列中最大元素 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Key</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 插入元素 e */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Key</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">size</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 先把新元素加到最后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pq</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 然后让它上浮到正确的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">swim</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 删除并返回当前队列中最大元素 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Key</span> <span class="nf">delMax</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 最大堆的堆顶就是最大元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Key</span> <span class="n">max</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 把这个最大元素换到最后，删除之
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">swap</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pq</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">size</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 让 pq[1] 下沉到正确位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">sink</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 上浮第 x 个元素，以维护最大堆性质 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果浮到堆顶，就不能再上浮了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">1</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">parent</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">x</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果第 x 个元素比上层大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 将 x 换上去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">swap</span><span class="o">(</span><span class="n">parent</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 下沉第 x 个元素，以维护最大堆性质 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果沉到堆底，就沉不下去了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 先假设左边节点较大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">left</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果右边节点存在，比一下大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">right</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">                <span class="n">max</span> <span class="o">=</span> <span class="n">right</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 结点 x 比俩孩子都大，就不必下沉了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 否则，不符合最大堆的结构，下沉 x 结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">swap</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 交换数组的两个元素 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Key</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* pq[i] 是否比 pq[j] 小？ */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">less</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 父节点的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">parent</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">root</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 左孩子的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">left</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">root</span> <span class="o">*</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 右孩子的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">right</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">root</span> <span class="o">*</span> <span class="n">2</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="队列实现栈以及栈实现队列">队列实现栈以及栈实现队列<a hidden class="anchor" aria-hidden="true" href="#队列实现栈以及栈实现队列">#</a></h3>
<p>栈实现队列用两个栈即可，入栈相当于入队，出栈时先将一个栈里的元素出栈到另一个栈中，栈顶就是队头，模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyQueue</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">MyQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** 添加元素到队尾 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** 返回队头元素 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 把 s1 元素压入 s2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">                <span class="n">s2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">s2</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** 删除队头的元素并返回 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 先调用 peek 保证 s2 非空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">peek</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">s2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** 判断队列是否为空 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>栈实现队列简单粗暴，pop的时候把除了队尾的其他都出队再加入到队尾即可，模板如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyStack</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">top_elem</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** 添加元素到栈顶 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// x 是队列的队尾，是栈的栈顶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">top_elem</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** 返回栈顶元素 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">top</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">top_elem</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** 删除栈顶的元素并返回 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 留下队尾 2 个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">size</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 记录新的队尾元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">top_elem</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 删除之前的队尾元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/** 判断栈是否为空 */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="其他-2">其他<a hidden class="anchor" aria-hidden="true" href="#其他-2">#</a></h1>
<h2 id="零碎">零碎<a hidden class="anchor" aria-hidden="true" href="#零碎">#</a></h2>
<p>从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。</p>
<p>数据结构的物理存储方式就是链式和顺序两种，基本操作就是增删改查，遍历方式无非迭代和递归。</p>
<p>计算机算法的本质就是枚举，只不过这里枚举需要做到两个方面：无遗漏和无冗余，有时候还可以利用一些定理进行优化（缩小搜索范围），比如剪枝和数学定理</p>
<p>难点在无遗漏的问题：</p>
<p>难点在无冗余的问题：递归类问题（动态规划）</p>
<p>难点在优化的问题：非递归类问题（并查集，贪心，KMP）</p>
<p>Java里优先队列就是二叉堆，也就是PriorityQueue</p>
<p>base case就是最基本的情况，从递归的角度理解就是递归出口，从分解问题(分治)的角度理解就是最基本的问题（不能再分了）</p>
<p>如果需要通过值找到其在数组的索引，将数组遍历一遍是一种做法，还可以创建一个valToIndex的hashmap</p>
<p>序列化就是把结构化的数据（比如树）打平（比如转换为字符串）</p>
<p>序列化和反序列化的目的：以某种特定格式组织数据，使得数据可以独立于编程语言。</p>
<h2 id="待做">待做<a hidden class="anchor" aria-hidden="true" href="#待做">#</a></h2>
<p><a href="https://labuladong.gitee.io/algo/1/3/">https://labuladong.gitee.io/algo/1/3/</a>的那几个算法框架及之后的几个框架文章都没看</p>
<p><a href="https://labuladong.gitee.io/algo/2/21/41/">https://labuladong.gitee.io/algo/2/21/41/</a>没看</p>
<p><a href="https://labuladong.gitee.io/algo/2/21/45/">https://labuladong.gitee.io/algo/2/21/45/</a>没看</p>
<p><a href="https://labuladong.gitee.io/algo/2/22/57/">https://labuladong.gitee.io/algo/2/22/57/</a>没看</p>
<p><a href="https://labuladong.gitee.io/algo/2/23/67/">https://labuladong.gitee.io/algo/2/23/67/</a>没看</p>
<p><a href="https://labuladong.gitee.io/algo/2/20/29/">https://labuladong.gitee.io/algo/2/20/29/</a>没看</p>
<h2 id="技巧">技巧<a hidden class="anchor" aria-hidden="true" href="#技巧">#</a></h2>
<p>dummy（虚拟头结点)：可以很好的避免第一个节点的特殊性，将第一个节点当作第二个节点，也即是所有节点统一处理</p>
<p>把 return 语句都放在函数开头，因为一般 return 语句都是 base case，集中放在一起可以让算法结构更清晰。</p>
<p>将二维坐标映射到一维的常用技巧：将二维坐标 <code>(x,y)</code> 转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）</p>
<p>方向数组 d 是上下左右搜索的常用手法：<code>int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};</code></p>
<h2 id="学习方法">学习方法<a hidden class="anchor" aria-hidden="true" href="#学习方法">#</a></h2>
<p>以后做题，先想这道题考察什么知识点。</p>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-23/">
    <span class="title">« Prev</span>
    <br>
    <span>LeetCode 23</span>
  </a>
  <a class="next" href="https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-86/">
    <span class="title">Next »</span>
    <br>
    <span>LeetCode 86</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share LeetCode Note 1 on twitter"
       href="https://twitter.com/intent/tweet/?text=LeetCode%20Note%201&amp;url=https%3a%2f%2fblog.zhangmengyang.tk%2fen%2fposts%2fleetcode%2fleetcode-note-1%2f&amp;hashtags=leetcode">
    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share LeetCode Note 1 on linkedin"
       href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.zhangmengyang.tk%2fen%2fposts%2fleetcode%2fleetcode-note-1%2f&amp;title=LeetCode%20Note%201&amp;summary=LeetCode%20Note%201&amp;source=https%3a%2f%2fblog.zhangmengyang.tk%2fen%2fposts%2fleetcode%2fleetcode-note-1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share LeetCode Note 1 on reddit"
       href="https://reddit.com/submit?url=https%3a%2f%2fblog.zhangmengyang.tk%2fen%2fposts%2fleetcode%2fleetcode-note-1%2f&title=LeetCode%20Note%201">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share LeetCode Note 1 on facebook"
       href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.zhangmengyang.tk%2fen%2fposts%2fleetcode%2fleetcode-note-1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share LeetCode Note 1 on whatsapp"
       href="https://api.whatsapp.com/send?text=LeetCode%20Note%201%20-%20https%3a%2f%2fblog.zhangmengyang.tk%2fen%2fposts%2fleetcode%2fleetcode-note-1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share LeetCode Note 1 on telegram"
       href="https://telegram.me/share/url?text=LeetCode%20Note%201&amp;url=https%3a%2f%2fblog.zhangmengyang.tk%2fen%2fposts%2fleetcode%2fleetcode-note-1%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

        </footer>
    </div>
</article>
</main>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2022-2022
        <a href="https://blog.zhangmengyang.tk/en/" style="color:#939393;">ZMY&#39;s Blog</a>
         All Rights Reserved
    </span>

    

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"ZMY's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"ZMY's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄copy';

        function copyingDone() {
            copybutton.innerText = '👌🏻copied!';
            setTimeout(() => {
                copybutton.innerText = '📄copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"ZMY's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
