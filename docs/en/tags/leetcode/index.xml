<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>leetcode on ZMY&#39;s Blog</title>
    <link>https://blog.zhangmengyang.tk/en/tags/leetcode/</link>
    <description>Recent content in leetcode on ZMY&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 13 Dec 2022 23:32:03 +0800</lastBuildDate><atom:link href="https://blog.zhangmengyang.tk/en/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 1024</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1024/</link>
      <pubDate>Tue, 13 Dec 2022 23:32:03 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1024/</guid>
      <description>思路 利用贪心算法，思路很简单，先按start排序，遍历区间，找end最大的区间，然后再遍历区间找start小于前一个end，end最大的区间</description>
    </item>
    
    <item>
      <title>LeetCode 452</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-452/</link>
      <pubDate>Tue, 13 Dec 2022 22:30:48 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-452/</guid>
      <description>思路 其实就是求解无重叠区间最多有几个，同LeetCode-435，因为可以每一发都打在无重叠区间中每个区间的最右边，这样下一个区间之前的区间</description>
    </item>
    
    <item>
      <title>LeetCode 435</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-435/</link>
      <pubDate>Tue, 13 Dec 2022 22:03:10 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-435/</guid>
      <description>思路 利用贪心算法，每次选择结束最早的区间（这就是局部最优选择），然后统计就可以了 代码 class Solution { private int intervalSchedule(int[][] intervals) { Arrays.sort(intervals, (a, b) -&amp;gt; { return a[1] - b[1]; }); int count = 1, x_end = intervals[0][1]; for (int[] interval</description>
    </item>
    
    <item>
      <title>LeetCode 312</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-312/</link>
      <pubDate>Tue, 13 Dec 2022 14:15:00 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-312/</guid>
      <description>思路 利用动态规划的思想，dp[i][j] = x表示，戳破气球i和气球j之间（开区间，不包括i和j）的所有气球，可以获得的最高分数为x。状态转移</description>
    </item>
    
    <item>
      <title>LeetCode 887</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-887/</link>
      <pubDate>Mon, 12 Dec 2022 22:55:21 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-887/</guid>
      <description>思路 比较复杂，详见：https://leetcode.cn/problems/super-egg-drop/solutions/44427/</description>
    </item>
    
    <item>
      <title>LeetCode 337</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-337/</link>
      <pubDate>Mon, 12 Dec 2022 15:03:50 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-337/</guid>
      <description>思路 同LeetCode-198，只不过变成了二叉树 代码 原版 class Solution { private Map&amp;lt;TreeNode, Integer&amp;gt; memo = new HashMap&amp;lt;&amp;gt;(); public int rob(TreeNode root) { if (root == null) { return 0; } if (memo.containsKey(root)) { return memo.get(root); } int do_it = root.val + (root.left == null ? 0 : rob(root.left.left)</description>
    </item>
    
    <item>
      <title>LeetCode 213</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-213/</link>
      <pubDate>Mon, 12 Dec 2022 14:25:48 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-213/</guid>
      <description>思路 同LeetCode-198，只不过首尾不能同时偷，共有三种情况，其中第一种情况不需要考虑因为肯定比其他两种小 代码 class Solution { private int robRange(int[] nums, int start, int end) {</description>
    </item>
    
    <item>
      <title>LeetCode 198</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-198/</link>
      <pubDate>Mon, 12 Dec 2022 13:51:41 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-198/</guid>
      <description>思路 利用动态规划的思想，dp数组里存截止到当前户最多偷到多少钱，状态转移方程为： dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 2]); base case 为dp[0]和dp[1]为0，可</description>
    </item>
    
    <item>
      <title>LeetCode 121&#43;122&#43;123&#43;188&#43;309&#43;714</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-121&#43;122&#43;123&#43;188&#43;309&#43;714/</link>
      <pubDate>Sun, 11 Dec 2022 21:42:50 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-121&#43;122&#43;123&#43;188&#43;309&#43;714/</guid>
      <description>思路 比较复杂，详见：https://labuladong.gitee.io/algo/3/28/96/ 代码 121题 class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][]</description>
    </item>
    
    <item>
      <title>LeetCode 516</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-516/</link>
      <pubDate>Sun, 11 Dec 2022 20:18:17 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-516/</guid>
      <description>思路 利用动态规划的思想，dp数组里存s[i&amp;hellip;j]的最长回文子序列，状态转移方程如下： if (s.charAt(j) == s.charAt(j + i)) { dp[j][j + i] = 2 + dp[j + 1][j + i - 1]; }</description>
    </item>
    
    <item>
      <title>LeetCode 10</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-10/</link>
      <pubDate>Sun, 11 Dec 2022 19:15:55 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-10/</guid>
      <description>思路 dp数组里存s[i&amp;hellip;]和p[j&amp;hellip;]是否匹配，状态转移方程需要根据s[i]和p[j]是否相等来选择，具体如下：</description>
    </item>
    
    <item>
      <title>LeetCode 174</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-174/</link>
      <pubDate>Sun, 11 Dec 2022 14:42:53 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-174/</guid>
      <description>思路 与LeetCode-64类似，只不过dp数组中dp[i][j]的定义是从 grid[i][j] 到达终点（右下角）所需的最少生命值 代码 class Solution { public int calculateMinimumHP(int[][] dungeon) { int m = dungeon.length,</description>
    </item>
    
    <item>
      <title>LeetCode 64</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-64/</link>
      <pubDate>Sun, 11 Dec 2022 14:03:02 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-64/</guid>
      <description>思路 经典动态规划问题，构造dp[][]数组，里面存放从(0, 0)到(i, j)的最小路径，dp[i][j]由min(dp[i - 1][j], dp[i][j - 1]) + gri</description>
    </item>
    
    <item>
      <title>LeetCode 494</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-494/</link>
      <pubDate>Sat, 10 Dec 2022 23:32:55 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-494/</guid>
      <description>思路 有三种思路： 递归思路 findTargetSumWays(nums, i, remain) = findTargetSumWays(nums, i + 1, remain - nums[i]) + findTargetSumWays(nums, i + 1, remain + nums[i])，直接看代码 回溯思路 经典回溯问题，套模板即可 动态规划 这道题还可以</description>
    </item>
    
    <item>
      <title>LeetCode 518</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-518/</link>
      <pubDate>Sat, 10 Dec 2022 22:36:12 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-518/</guid>
      <description>思路 经典完全背包问题，直接套模板即可，详见思想篇章，可以优化空间复杂度 代码 原版 class Solution { public int change(int amount, int[] coins) { int n = coins.length; int[][] dp = new int[n + 1][amount + 1]; for (int i = 0; i &amp;lt;= n;</description>
    </item>
    
    <item>
      <title>LeetCode 416</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-416/</link>
      <pubDate>Sat, 10 Dec 2022 22:02:28 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-416/</guid>
      <description>思路 其实就是背包问题，直接套背包问题模板，构造二维dp数组，dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下 dp[</description>
    </item>
    
    <item>
      <title>LeetCode 712</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-712/</link>
      <pubDate>Sat, 10 Dec 2022 20:40:33 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-712/</guid>
      <description>思路 利用动态规划的思想，同LeetCode-583，只不过不是计算删除操作数，而是删除的ASCII码 代码 class Solution { public int minimumDeleteSum(String s1, String s2) { int m = s1.length(), n = s2.length(); int[][]</description>
    </item>
    
    <item>
      <title>LeetCode 583</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-583/</link>
      <pubDate>Sat, 10 Dec 2022 17:36:14 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-583/</guid>
      <description>思路 基本同最长公共子序列：LeetCode-1143，也可以直接重用LCS，因为删除的结果不就是它俩的最长公共子序列，那么删除的次数就是wo</description>
    </item>
    
    <item>
      <title>LeetCode 1143</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1143/</link>
      <pubDate>Sat, 10 Dec 2022 17:18:32 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1143/</guid>
      <description>思路 利用动态规划的思想，dp数组里存s1[0&amp;hellip;i]和s2[0&amp;hellip;j]的最长公共子序列，如果s1[i]==s2[j]</description>
    </item>
    
    <item>
      <title>LeetCode 53</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-53/</link>
      <pubDate>Sat, 10 Dec 2022 15:39:44 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-53/</guid>
      <description>思路 三种思路： 动态规划 dp数组里放以该元素结尾的最大子数组和，可以由前面那个元素推出来，base case是dp[0] = nums[0]，可以优</description>
    </item>
    
    <item>
      <title>LeetCode 72</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-72/</link>
      <pubDate>Sat, 10 Dec 2022 15:01:28 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-72/</guid>
      <description>思路 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来： base case是第一行和第一</description>
    </item>
    
    <item>
      <title>LeetCode 931</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-931/</link>
      <pubDate>Fri, 09 Dec 2022 21:38:07 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-931/</guid>
      <description>思路 利用动态规划的思想，dp数组里放落到该位置的最小路径和，由上一行临近自己的三个元素最小值+自己元素的大小得到，base case是dp数组</description>
    </item>
    
    <item>
      <title>LeetCode 354</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-354/</link>
      <pubDate>Fri, 09 Dec 2022 20:39:25 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-354/</guid>
      <description>思路 本质上就是最长递增子序列问题，见LeetCode-300，只不过需要先对width升序排序，然后计算height的最长递增子序列即可 ps</description>
    </item>
    
    <item>
      <title>LeetCode 300</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-300/</link>
      <pubDate>Fri, 09 Dec 2022 19:57:21 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-300/</guid>
      <description>思路 两种解法： 动态规划 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素</description>
    </item>
    
    <item>
      <title>LeetCode Note 2</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-2/</link>
      <pubDate>Fri, 09 Dec 2022 19:25:56 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-2/</guid>
      <description>动态规划基本问题 解法 经典动态规划问题，详见思想篇章 题目 1. 斐波那契数 题解详见：https://blog.zhangmengyang.tk/po</description>
    </item>
    
    <item>
      <title>LeetCode 322</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-322/</link>
      <pubDate>Thu, 08 Dec 2022 22:42:46 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-322/</guid>
      <description>思路 经典动态规划问题，具有最优子结构性质，“状态”为金额，“选择”为硬币的面值，dp数组定义为dp[金额] = 取得该金额需要的最少硬币，”ba</description>
    </item>
    
    <item>
      <title>LeetCode 509</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-509/</link>
      <pubDate>Thu, 08 Dec 2022 22:42:39 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-509/</guid>
      <description>思路 状态转移方程很简单，注意一下直接递归会有重复子问题，所以可以使用数组备份一下（其实就是dp数组），又发现只会用到每个元素的前两个元素，所</description>
    </item>
    
    <item>
      <title>LeetCode 225</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-225/</link>
      <pubDate>Thu, 08 Dec 2022 12:21:22 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-225/</guid>
      <description>思路 直接套用队列实现栈的模板即可，详见思想篇章 代码 class MyStack { private Queue&amp;lt;Integer&amp;gt; q; private int topElem; public MyStack() { q = new LinkedList&amp;lt;&amp;gt;(); } public void push(int x) { q.offer(x); topElem = x; } public int pop() { int size = q.size(); while (size &amp;gt; 2) { q.offer(q.poll()); size--; } topElem =</description>
    </item>
    
    <item>
      <title>LeetCode 232</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-232/</link>
      <pubDate>Thu, 08 Dec 2022 12:09:36 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-232/</guid>
      <description>思路 直接套栈实现队列模板即可，详见思想篇章 代码 class MyQueue { private Stack&amp;lt;Integer&amp;gt; s1, s2; public MyQueue() { s1 = new Stack&amp;lt;&amp;gt;(); s2 = new Stack&amp;lt;&amp;gt;(); } public void push(int x) { s2.push(x); } public int pop() { peek(); return s1.pop(); } public int peek() { if (s1.isEmpty()) { while (!s2.isEmpty()) { s1.push(s2.pop()); } }</description>
    </item>
    
    <item>
      <title>LeetCode 239</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-239/</link>
      <pubDate>Wed, 07 Dec 2022 13:49:34 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-239/</guid>
      <description>思路 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色</description>
    </item>
    
    <item>
      <title>LeetCode 503</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-503/</link>
      <pubDate>Wed, 07 Dec 2022 11:08:46 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-503/</guid>
      <description>思路 利用单调栈的思想，同LeetCode-496，只不过牵扯到循环数组的问题，常用套路就是将数组长度翻倍，代码实现的时候也可以用i % nums</description>
    </item>
    
    <item>
      <title>LeetCode 739</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-739/</link>
      <pubDate>Wed, 07 Dec 2022 10:53:22 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-739/</guid>
      <description>思路 利用单调栈的思想即可，同LeetCode-496，只不过这次存的是索引而不是元素 代码 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; Deque&amp;lt;Integer&amp;gt; stack = new ArrayDeque&amp;lt;&amp;gt;(); int[] res = new int[n]; for (int i =</description>
    </item>
    
    <item>
      <title>LeetCode 496</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-496/</link>
      <pubDate>Wed, 07 Dec 2022 10:35:40 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-496/</guid>
      <description>思路 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充</description>
    </item>
    
    <item>
      <title>LeetCode 677</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-677/</link>
      <pubDate>Tue, 06 Dec 2022 21:48:51 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-677/</guid>
      <description>思路 经典TrieMap问题，不解释 代码 class MapSum { private TrieMap&amp;lt;Integer&amp;gt; trieMap; public MapSum() { this.trieMap = new TrieMap(); } public void insert(String key, int val) { trieMap.put(key, val); } public int sum(String prefix) { List&amp;lt;String&amp;gt; keys = trieMap.keysWithPrefix(prefix); int res = 0; for (String key : keys) { res += trieMap.get(key); } return res; } class</description>
    </item>
    
    <item>
      <title>LeetCode 295</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-295/</link>
      <pubDate>Tue, 06 Dec 2022 20:15:23 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-295/</guid>
      <description>思路 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：h</description>
    </item>
    
    <item>
      <title>LeetCode 211</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-211/</link>
      <pubDate>Tue, 06 Dec 2022 17:05:05 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-211/</guid>
      <description>思路 利用Trie树的思想即可，详见思想篇章 代码 class WordDictionary { private TrieNode root; private static class TrieNode { boolean isEnd = false; TrieNode[] children = new TrieNode[26]; } public WordDictionary() { this.root = new TrieNode(); } public void addWord(String word) { this.root = put(root, word, 0); } private TrieNode put(TrieNode node, String word, int</description>
    </item>
    
    <item>
      <title>LeetCode 648</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-648/</link>
      <pubDate>Tue, 06 Dec 2022 16:58:09 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-648/</guid>
      <description>思路 经典前缀树（Trie）问题，只不过需要注意将dictionary添加进set即可（因为只添加进set的字符串才能充当前缀） 代码 class Solution { public String</description>
    </item>
    
    <item>
      <title>LeetCode 208</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-208/</link>
      <pubDate>Tue, 06 Dec 2022 16:41:25 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-208/</guid>
      <description>思路 经典前缀树（Trie）问题，直接套模板即可，详见思想篇章 代码 class Trie { private TrieSet trieSet; public Trie() { this.trieSet = new TrieSet(); } public void insert(String word) { trieSet.add(word); } public boolean search(String word) { return trieSet.contains(word); } public boolean startsWith(String prefix) { return trieSet.hasKeyWithPrefix(prefix); } class</description>
    </item>
    
    <item>
      <title>LeetCode 146</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-146/</link>
      <pubDate>Tue, 06 Dec 2022 15:02:34 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-146/</guid>
      <description>思路 经典LRU缓存问题，直接套LRU模板即可，详见思想篇章 代码 手写轮子 class LRUCache { private Map&amp;lt;Integer, Node&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); private DoubleList cache = new DoubleList(); private int capacity; public LRUCache(int capacity) { this.capacity = capacity; } public int get(int key) { if (!map.containsKey(key)) {</description>
    </item>
    
    <item>
      <title>LeetCode 460</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-460/</link>
      <pubDate>Tue, 06 Dec 2022 14:58:18 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-460/</guid>
      <description>思路 经典LFU缓存问题，直接套LFU模板即可，详见思想篇章 代码 class LFUCache { private Map&amp;lt;Integer, Integer&amp;gt; keyToVal; private Map&amp;lt;Integer, Integer&amp;gt; keyToFreq; private Map&amp;lt;Integer, LinkedHashSet&amp;lt;Integer&amp;gt;&amp;gt; freqToKeys; private int minFreq; private int capacity; public LFUCache(int capacity) { keyToVal = new HashMap&amp;lt;&amp;gt;(); keyToFreq = new HashMap&amp;lt;&amp;gt;(); freqToKeys = new HashMap&amp;lt;&amp;gt;(); this.capacity =</description>
    </item>
    
    <item>
      <title>LeetCode 1584</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1584/</link>
      <pubDate>Mon, 05 Dec 2022 12:46:30 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1584/</guid>
      <description>思路 两种思路： kruskal 利用kruskal算法即可，只不过这里的边需要自己生成，详见思想章节 prim 利用prim算法即可，只不过这里的边需要自己生成，详见</description>
    </item>
    
    <item>
      <title>LeetCode 1514</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1514/</link>
      <pubDate>Sun, 04 Dec 2022 22:07:34 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1514/</guid>
      <description>思路 dijkstra问题的变种，利用dijkstra模板即可，主要有两个注意点： 首先需要构造图，构造图时注意无向图的一条边相当于两条有向边 w</description>
    </item>
    
    <item>
      <title>LeetCode 1631</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1631/</link>
      <pubDate>Sun, 04 Dec 2022 21:20:32 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1631/</guid>
      <description>思路 利用dijkstra的思想，只不过需要把矩阵里的每个元素当成一个结点，求一个结点的相邻结点与一般的图不同（即adj函数），而且最后求的体</description>
    </item>
    
    <item>
      <title>LeetCode 743</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-743/</link>
      <pubDate>Sun, 04 Dec 2022 20:17:02 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-743/</guid>
      <description>思路 经典dijkstra问题，利用dijkstra模板即可，详见思想章节 代码 class Solution { class State { int id; int distFromStart; public State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } private int[] dijkstra(List&amp;lt;int[]&amp;gt;[] graph, int start) { int[]</description>
    </item>
    
    <item>
      <title>LeetCode 990</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-990/</link>
      <pubDate>Thu, 03 Nov 2022 23:57:29 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-990/</guid>
      <description>思路 利用并查集的思想，先将相等的连接起来，然后再判断不相等的是否与并查集里的连通状态冲突 代码 class Solution { public boolean equationsPossible(String[] equations) { UF uf = new UF(26); for (String equation : equations) { if (equation.charAt(1) == &amp;#39;=&amp;#39;) {</description>
    </item>
    
    <item>
      <title>LeetCode 130</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-130/</link>
      <pubDate>Thu, 03 Nov 2022 23:38:17 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-130/</guid>
      <description>思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的&amp;rsquo;O&amp;rsquo;相连的&amp;rsquo;O&amp;rsquo;加入到dum</description>
    </item>
    
    <item>
      <title>LeetCode 886</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-886/</link>
      <pubDate>Thu, 03 Nov 2022 16:58:49 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-886/</guid>
      <description>思路 经典二分图判断，只不过需要先构造一个图，详见思想章节 代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List&amp;lt;Integer&amp;gt;[] graph = buildGraph(n, dislikes); for (int</description>
    </item>
    
    <item>
      <title>LeetCode 785</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-785/</link>
      <pubDate>Thu, 03 Nov 2022 16:17:09 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-785/</guid>
      <description>思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节 代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color</description>
    </item>
    
    <item>
      <title>LeetCode 210</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-210/</link>
      <pubDate>Fri, 28 Oct 2022 21:47:32 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-210/</guid>
      <description>思路 寻找可行的选课顺序其实就是计算拓扑排序 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无</description>
    </item>
    
    <item>
      <title>LeetCode 207</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-207/</link>
      <pubDate>Fri, 28 Oct 2022 20:32:56 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-207/</guid>
      <description>思路 这道题其实就是检测图里是否有环 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该</description>
    </item>
    
    <item>
      <title>LeetCode 797</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-797/</link>
      <pubDate>Wed, 26 Oct 2022 23:21:47 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-797/</guid>
      <description>思路 经典图的遍历，只不过要同时记录路径 代码 class Solution { private List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; allPathsSourceTarget(int[][] graph) { LinkedList&amp;lt;Integer&amp;gt; path = new LinkedList&amp;lt;&amp;gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList&amp;lt;Integer&amp;gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s</description>
    </item>
    
    <item>
      <title>LeetCode 222</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-222/</link>
      <pubDate>Wed, 26 Oct 2022 22:38:25 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-222/</guid>
      <description>思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和</description>
    </item>
    
    <item>
      <title>LeetCode 235</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-235/</link>
      <pubDate>Sat, 22 Oct 2022 23:19:23 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-235/</guid>
      <description>思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是</description>
    </item>
    
    <item>
      <title>LeetCode 236</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-236/</link>
      <pubDate>Sat, 22 Oct 2022 22:47:12 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-236/</guid>
      <description>思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或</description>
    </item>
    
    <item>
      <title>LeetCode 341</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-341/</link>
      <pubDate>Sat, 22 Oct 2022 21:57:50 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-341/</guid>
      <description>思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码 思路二 思路一会在</description>
    </item>
    
    <item>
      <title>LeetCode 95</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-95/</link>
      <pubDate>Fri, 14 Oct 2022 11:32:09 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-95/</guid>
      <description>思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用 我的</description>
    </item>
    
    <item>
      <title>LeetCode 96</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-96/</link>
      <pubDate>Fri, 14 Oct 2022 11:08:45 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-96/</guid>
      <description>思路 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这</description>
    </item>
    
    <item>
      <title>LeetCode 504</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-504/</link>
      <pubDate>Fri, 14 Oct 2022 10:37:01 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-504/</guid>
      <description>思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种</description>
    </item>
    
    <item>
      <title>LeetCode 701</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-701/</link>
      <pubDate>Thu, 13 Oct 2022 16:21:01 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-701/</guid>
      <description>思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造 我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) {</description>
    </item>
    
    <item>
      <title>LeetCode 700</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-700/</link>
      <pubDate>Thu, 13 Oct 2022 16:06:44 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-700/</guid>
      <description>思路 利用二分查找的思想，不解释了 我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val &amp;gt; root.val) { return searchBST(root.right, val); } if (val &amp;lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜</description>
    </item>
    
    <item>
      <title>LeetCode 98</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-98/</link>
      <pubDate>Thu, 13 Oct 2022 15:34:20 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-98/</guid>
      <description>思路 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题</description>
    </item>
    
    <item>
      <title>LeetCode 538</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-538/</link>
      <pubDate>Thu, 13 Oct 2022 14:42:01 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-538/</guid>
      <description>思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，</description>
    </item>
    
    <item>
      <title>LeetCode 230</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-230/</link>
      <pubDate>Thu, 13 Oct 2022 14:07:42 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-230/</guid>
      <description>思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return 我的代码 class Solution { private int rank</description>
    </item>
    
    <item>
      <title>LeetCode 297</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-297/</link>
      <pubDate>Wed, 12 Oct 2022 15:25:34 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-297/</guid>
      <description>思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（</description>
    </item>
    
    <item>
      <title>LeetCode 889</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-889/</link>
      <pubDate>Wed, 12 Oct 2022 13:57:30 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-889/</guid>
      <description>思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树 详见：https://blog.zhangmengya</description>
    </item>
    
    <item>
      <title>LeetCode 106</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-106/</link>
      <pubDate>Wed, 12 Oct 2022 12:05:51 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-106/</guid>
      <description>思路 同LeetCode-105，就是改一下递归的参数 详见：https://blog.zhangmengyang.tk/posts/leetc</description>
    </item>
    
    <item>
      <title>LeetCode 105</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-105/</link>
      <pubDate>Wed, 12 Oct 2022 11:53:59 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-105/</guid>
      <description>思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据ro</description>
    </item>
    
    <item>
      <title>LeetCode 654</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-654/</link>
      <pubDate>Wed, 12 Oct 2022 11:18:53 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-654/</guid>
      <description>思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即</description>
    </item>
    
    <item>
      <title>LeetCode 114</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-114/</link>
      <pubDate>Tue, 11 Oct 2022 15:09:41 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-114/</guid>
      <description>思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路 将该问题分解为：左子树展开+右子树展开</description>
    </item>
    
    <item>
      <title>LeetCode 116</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-116/</link>
      <pubDate>Tue, 11 Oct 2022 14:33:15 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-116/</guid>
      <description>思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历 思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的 思路二 把间隙看成结点，那</description>
    </item>
    
    <item>
      <title>LeetCode 226</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-226/</link>
      <pubDate>Tue, 11 Oct 2022 13:48:45 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-226/</guid>
      <description>思路 遍历方式和分解方式都可以 遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可 分解思路 利用二叉树的分解</description>
    </item>
    
    <item>
      <title>LeetCode 543</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-543/</link>
      <pubDate>Mon, 10 Oct 2022 14:53:44 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-543/</guid>
      <description>思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，</description>
    </item>
    
    <item>
      <title>LeetCode 104</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-104/</link>
      <pubDate>Mon, 10 Oct 2022 14:25:10 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-104/</guid>
      <description>思路 有两种思路，分别是分解问题和遍历二叉树 思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度 思路二 把二叉树</description>
    </item>
    
    <item>
      <title>LeetCode 周赛 314</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-314/</link>
      <pubDate>Sun, 09 Oct 2022 14:17:29 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-314/</guid>
      <description>思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可 第二题 考察差分数组和异或的性质 由a^b=c &amp;mdash;&amp;gt; a^a^b=a^c &amp;mdash;&amp;gt; 0^b=a^c &amp;mdash;&amp;gt; b</description>
    </item>
    
    <item>
      <title>LeetCode 710</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-710/</link>
      <pubDate>Tue, 27 Sep 2022 15:05:11 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-710/</guid>
      <description>思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.le</description>
    </item>
    
    <item>
      <title>LeetCode 380</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-380/</link>
      <pubDate>Tue, 27 Sep 2022 14:35:51 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-380/</guid>
      <description>思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索</description>
    </item>
    
    <item>
      <title>LeetCode 528</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-528/</link>
      <pubDate>Mon, 26 Sep 2022 22:42:24 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-528/</guid>
      <description>思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值</description>
    </item>
    
    <item>
      <title>LeetCode 59</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-59/</link>
      <pubDate>Mon, 26 Sep 2022 21:53:13 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-59/</guid>
      <description>思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leet</description>
    </item>
    
    <item>
      <title>LeetCode 54</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-54/</link>
      <pubDate>Mon, 26 Sep 2022 21:39:37 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-54/</guid>
      <description>思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界： 需要注意水平遍历需要判断upperBound&amp;lt</description>
    </item>
    
    <item>
      <title>LeetCode 48</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-48/</link>
      <pubDate>Mon, 26 Sep 2022 11:12:45 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-48/</guid>
      <description>思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的</description>
    </item>
    
    <item>
      <title>LeetCode 151</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-151/</link>
      <pubDate>Mon, 26 Sep 2022 10:45:08 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-151/</guid>
      <description>思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再revers</description>
    </item>
    
    <item>
      <title>LeetCode 1094</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1094/</link>
      <pubDate>Mon, 26 Sep 2022 00:32:18 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1094/</guid>
      <description>思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算 代码 class Solution { public boolean carPooling(int[][] trips, int</description>
    </item>
    
    <item>
      <title>LeetCode 1109</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1109/</link>
      <pubDate>Sun, 25 Sep 2022 23:57:09 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-1109/</guid>
      <description>思路 标准差分数组，详见LeetCode-note 代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff;</description>
    </item>
    
    <item>
      <title>LeetCode 304</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-304/</link>
      <pubDate>Sun, 25 Sep 2022 23:11:19 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-304/</guid>
      <description>思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位 还需要</description>
    </item>
    
    <item>
      <title>LeetCode 303</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-303/</link>
      <pubDate>Sun, 25 Sep 2022 22:41:54 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-303/</guid>
      <description>思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位 代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum =</description>
    </item>
    
    <item>
      <title>LeetCode 3</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-3/</link>
      <pubDate>Sun, 25 Sep 2022 22:16:07 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-3/</guid>
      <description>思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找</description>
    </item>
    
    <item>
      <title>LeetCode 438</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-438/</link>
      <pubDate>Sun, 25 Sep 2022 21:52:06 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-438/</guid>
      <description>思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengya</description>
    </item>
    
    <item>
      <title>LeetCode 567</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-567/</link>
      <pubDate>Sun, 25 Sep 2022 18:13:05 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-567/</guid>
      <description>思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法</description>
    </item>
    
    <item>
      <title>LeetCode 76</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-76/</link>
      <pubDate>Sun, 25 Sep 2022 17:01:39 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-76/</guid>
      <description>思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节 代码 class Solution {</description>
    </item>
    
    <item>
      <title>LeetCode 周赛-312</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-312/</link>
      <pubDate>Sun, 25 Sep 2022 15:22:34 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-312/</guid>
      <description>思路 第一题 排序，不解释 第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了 第三题 暴力会超时，利用</description>
    </item>
    
    <item>
      <title>LeetCode 34</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-34/</link>
      <pubDate>Sun, 25 Sep 2022 00:24:53 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-34/</guid>
      <description>思路 进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，</description>
    </item>
    
    <item>
      <title>LeetCode 704</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-704/</link>
      <pubDate>Sat, 24 Sep 2022 16:18:38 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-704/</guid>
      <description>思路 经典二分查找，不解释 详见：https://labuladong.gitee.io/algo/2/20/29/ 代码 class Solution { public int search(int[] nums, int target) { int left</description>
    </item>
    
    <item>
      <title>LeetCode 5</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-5/</link>
      <pubDate>Sat, 24 Sep 2022 15:30:02 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-5/</guid>
      <description>思路 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。 代码 class Solution { public String longestPalindrome(String s) { String res = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; s.length(); i++) { // 从中心向两边寻找回文串 String</description>
    </item>
    
    <item>
      <title>LeetCode 344</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-344/</link>
      <pubDate>Sat, 24 Sep 2022 15:10:28 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-344/</guid>
      <description>思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值 代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left &amp;lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1.</description>
    </item>
    
    <item>
      <title>LeetCode 167</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-167/</link>
      <pubDate>Sat, 24 Sep 2022 14:58:51 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-167/</guid>
      <description>思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right&amp;ndash;，否则left++，直到左右之和等于target。 代</description>
    </item>
    
    <item>
      <title>LeetCode 26&#43;83&#43;27&#43;283</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-26&#43;83&#43;27&#43;283/</link>
      <pubDate>Sat, 24 Sep 2022 14:13:53 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-26&#43;83&#43;27&#43;283/</guid>
      <description>思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题） 26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的</description>
    </item>
    
    <item>
      <title>LeetCode 234 快慢指针&#43;反转链表</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88&#43;%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 24 Sep 2022 00:05:26 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88&#43;%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。 代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找</description>
    </item>
    
    <item>
      <title>LeetCode 234 链表后序遍历</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E9%93%BE%E8%A1%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 24 Sep 2022 00:00:43 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-234-%E9%93%BE%E8%A1%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。 代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private</description>
    </item>
    
    <item>
      <title>LeetCode 25</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-25/</link>
      <pubDate>Fri, 23 Sep 2022 23:21:30 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-25/</guid>
      <description>思路 1、先反转以 head 开头的 k 个元素。 2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。 3、将上述两个过程的结果连接起来。 注意base case为最后元素</description>
    </item>
    
    <item>
      <title>LeetCode 92</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-92/</link>
      <pubDate>Fri, 23 Sep 2022 22:52:35 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-92/</guid>
      <description>思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right</description>
    </item>
    
    <item>
      <title>反转链表前n个节点</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 23 Sep 2022 22:20:19 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>思路 解决思路和反转整个链表差不多，只要稍加修改即可： 1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。 2、刚才我们直接</description>
    </item>
    
    <item>
      <title>LeetCode 206</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-206/</link>
      <pubDate>Fri, 23 Sep 2022 22:01:54 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-206/</guid>
      <description>思路 利用递归的思想，先反转head后面的，然后把head也反转即可。 代码 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next =</description>
    </item>
    
    <item>
      <title>LeetCode 160</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-160/</link>
      <pubDate>Fri, 23 Sep 2022 15:29:13 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-160/</guid>
      <description>思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等</description>
    </item>
    
    <item>
      <title>LeetCode 142</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-142/</link>
      <pubDate>Fri, 23 Sep 2022 15:02:29 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-142/</guid>
      <description>思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次</description>
    </item>
    
    <item>
      <title>LeetCode 141</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-141/</link>
      <pubDate>Fri, 23 Sep 2022 14:49:25 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-141/</guid>
      <description>思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环 代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表</description>
    </item>
    
    <item>
      <title>LeetCode 876</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-876/</link>
      <pubDate>Fri, 23 Sep 2022 14:18:22 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-876/</guid>
      <description>思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 需要注意的是，如果链表</description>
    </item>
    
    <item>
      <title>LeetCode 19</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-19/</link>
      <pubDate>Fri, 23 Sep 2022 12:32:27 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-19/</guid>
      <description>思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指</description>
    </item>
    
    <item>
      <title>LeetCode 23</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-23/</link>
      <pubDate>Fri, 23 Sep 2022 10:47:55 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-23/</guid>
      <description>思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。 代码 class Solution { public ListNode mergeKLists(ListNode[] lists) {</description>
    </item>
    
    <item>
      <title>LeetCode Note 1</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/</link>
      <pubDate>Fri, 23 Sep 2022 10:21:48 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-note-1/</guid>
      <description>链表 合并两个有序链表 解法 略 题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetc</description>
    </item>
    
    <item>
      <title>LeetCode 86</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-86/</link>
      <pubDate>Fri, 23 Sep 2022 00:09:37 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-86/</guid>
      <description>思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。 代码 class</description>
    </item>
    
    <item>
      <title>LeetCode 21</title>
      <link>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-21/</link>
      <pubDate>Thu, 22 Sep 2022 23:42:59 +0800</pubDate>
      
      <guid>https://blog.zhangmengyang.tk/en/posts/leetcode/leetcode-21/</guid>
      <description>思路 不解释 代码 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null &amp;amp;&amp;amp; list2 != null) { if (list1.val &amp;lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2</description>
    </item>
    
  </channel>
</rss>
