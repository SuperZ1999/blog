[{"content":"思路 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来：\nbase case是第一行和第一列，可以优化空间复杂度但是懒得弄了\n补充：具体s1是怎么转换为s2的，可以在dp数组的每个元素里补充额外的信息，详见：https://labuladong.gitee.io/algo/3/26/75/\n代码 class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt;= m; i++) { dp[i][0] = i; } for (int i = 0; i \u0026lt;= n; i++) { dp[0][i] = i; } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1)); } } } return dp[m][n]; } } References 1. 编辑距离 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-72/","summary":"思路 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来： base case是第一行和第一","title":"LeetCode 72"},{"content":"思路 利用动态规划的思想，dp数组里放落到该位置的最小路径和，由上一行临近自己的三个元素最小值+自己元素的大小得到，base case是dp数组第一行为matrix数组第一行，可以优化空间复杂度，因为只用到了两行，但是懒得弄了\n代码 class Solution { public int minFallingPathSum(int[][] matrix) { int n = matrix.length; int[][] dp = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { dp[0][i] = matrix[0][i]; } for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.min(dp[i - 1][0], dp[i - 1][1]) + matrix[i][0]; for (int j = 1; j \u0026lt; n - 1; j++) { dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j + 1])) + matrix[i][j]; } dp[i][n - 1] = Math.min(dp[i - 1][n - 1], dp[i - 1][n - 2]) + matrix[i][n - 1]; } int res = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; n; i++) { res = Math.min(res, dp[n - 1][i]); } return res; } } References 1. 下降路径最小和 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-931/","summary":"思路 利用动态规划的思想，dp数组里放落到该位置的最小路径和，由上一行临近自己的三个元素最小值+自己元素的大小得到，base case是dp数组","title":"LeetCode 931"},{"content":"思路 本质上就是最长递增子序列问题，见LeetCode-300，只不过需要先对width升序排序，然后计算height的最长递增子序列即可\nps：此版本会超时，需要融合二分查找\n代码 class Solution { public int maxEnvelopes(int[][] envelopes) { int n = envelopes.length; Arrays.sort(envelopes, (a, b) -\u0026gt; { return a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]; }); int[] dp = new int[n]; Arrays.fill(dp, 1); int res = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (envelopes[j][1] \u0026lt; envelopes[i][1]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } res = Math.max(res, dp[i]); } return res; } } References 1. 俄罗斯套娃信封问题 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-354/","summary":"思路 本质上就是最长递增子序列问题，见LeetCode-300，只不过需要先对width升序排序，然后计算height的最长递增子序列即可 ps","title":"LeetCode 354"},{"content":"思路 两种解法：\n动态规划 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素的索引，base case为f(0) = 1，具有最优子结构，状态转移方程为f(x) = \u0026hellip;.(懒得写了)，会有重叠子问题所以用dp数组记录，无法优化空间复杂度\n动态规划+二分查找 没看懂，也不重要，以后再说吧 // TODO\n代码 动态规划 class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length, res = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[j] \u0026lt; nums[i]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } res = Math.max(res, dp[i]); } return res; } } References 1. 最长递增子序列 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-300/","summary":"思路 两种解法： 动态规划 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素","title":"LeetCode 300"},{"content":"动态规划基本问题 解法 经典动态规划问题，详见思想篇章\n题目 1. 斐波那契数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-509/\n2. 零钱兑换 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-322/\n3. 下降路径最小和 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-931/\n子序列问题 最长递增子序列 解法 利用动态规划的思想，y=f(x)的x是数组的索引，y是以这个索引的元素结尾的最长递增子序列的长度，选择为x之前所有元素的索引，base case为f(0) = 1，具有最优子结构，状态转移方程为f(x) = \u0026hellip;.(懒得写了)，会有重叠子问题所以用dp数组记录，无法优化空间复杂度\n题目 1. 最长递增子序列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-300/\n2. 俄罗斯套娃信封问题 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-354/\n编辑距离 解法 利用动态规划的思想，dp数组里存*s1[0..i-1] 和 s2[0..j-1]*的编辑距离，可以由以下元素推出来：\nbase case是第一行和第一列，可以优化空间复杂度但是懒得弄了\n补充：具体s1是怎么转换为s2的，可以在dp数组的每个元素里补充额外的信息，详见：https://labuladong.gitee.io/algo/3/26/75/\n题目 1. 编辑距离 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-72/\n思想 动态规划 动态规划问题有两个重要的特点，分别是最优子结构性质和存在重叠子问题\n流程 明确状态方程y = f(x)的定义\n确定「状态」，也就是原问题和子问题中会变化的变量。即y = f(x)中的x 确定y = f(x)中的y，一般是问题要求我们计算的量 确定「选择」，也就是导致「状态」产生变化的行为。即状态转移方程里的x应该选择哪一个 确定base case 写出状态转移方程（列出状态转移方程，就是在解决“如何穷举”的问题。），这个过程就是判断问题是否具有最优子结构性质（就是能否通过子问题的最优解求出原问题的最优解），此时可以通过状态转移方程写出递归写法，递归写法就是自顶向下的解法，但是这种写法一般存在重叠子问题\n判断问题是否具有重叠子问题，如果有，使用DP table代替f(x)函数，同时将递归改成迭代（也就是自底向上），DP table起到了记录子问题的作用，DP table 就是在追求“如何聪明地穷举”\n优化空间复杂度，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度\n精简流程 构造一个dp数组 确定dp数组里面放什么 dp数组里的元素怎么根据前面元素推出来 base case 优化空间复杂度 注意点 动态规划的核心问题是“如何穷举”（状态转移方程），然后考虑“如何聪明地穷举”（消除重叠子问题、剪枝） 算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举” 递归是自顶向下，dp table迭代是自底向上 dp数组的大小有时候要比原问题大一点，目的是防止特殊判断和dummy node的原理类似 dp 数组的遍历方向只要保证两点即可 遍历的过程中，所需的状态必须是已经计算出来的 遍历结束后，存储结果的那个位置必须已经被计算出来 经典问题 子序列问题 一般y = f(x)的x都是数组的索引，y是以这个索引对应的元素结尾的最长\u0026hellip;子序列，两个数组同理，只不过是二维的\n","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-note-2/","summary":"动态规划基本问题 解法 经典动态规划问题，详见思想篇章 题目 1. 斐波那契数 题解详见：https://blog.zhangmengyang.tk/po","title":"LeetCode Note 2"},{"content":"思路 经典动态规划问题，具有最优子结构性质，“状态”为金额，“选择”为硬币的面值，dp数组定义为dp[金额] = 取得该金额需要的最少硬币，”basecase“为dp[0] = 0，状态转移方程如下：\n直接递归存在重复子问题，所以用dp数组迭代方式\n代码 class Solution { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for(int i = 1; i \u0026lt;= amount; i++) { for (int coin : coins) { if (i - coin \u0026lt; 0) { continue; } dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] == amount + 1 ? -1 : dp[amount]; } } References 1. 零钱兑换 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-322/","summary":"思路 经典动态规划问题，具有最优子结构性质，“状态”为金额，“选择”为硬币的面值，dp数组定义为dp[金额] = 取得该金额需要的最少硬币，”ba","title":"LeetCode 322"},{"content":"思路 状态转移方程很简单，注意一下直接递归会有重复子问题，所以可以使用数组备份一下（其实就是dp数组），又发现只会用到每个元素的前两个元素，所以可以把数组换成前两个元素\n代码 class Solution { public int fib(int n) { if (n == 0 || n == 1) { return n; } int dp_i_1 = 0, dp_i_2 = 1; for (int i = 2; i \u0026lt;= n; i++) { int dp_i_3 = dp_i_1 + dp_i_2; dp_i_1 = dp_i_2; dp_i_2 = dp_i_3; } return dp_i_2; } } References 1. 斐波那契数 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-509/","summary":"思路 状态转移方程很简单，注意一下直接递归会有重复子问题，所以可以使用数组备份一下（其实就是dp数组），又发现只会用到每个元素的前两个元素，所","title":"LeetCode 509"},{"content":"思路 直接套用队列实现栈的模板即可，详见思想篇章\n代码 class MyStack { private Queue\u0026lt;Integer\u0026gt; q; private int topElem; public MyStack() { q = new LinkedList\u0026lt;\u0026gt;(); } public void push(int x) { q.offer(x); topElem = x; } public int pop() { int size = q.size(); while (size \u0026gt; 2) { q.offer(q.poll()); size--; } topElem = q.peek(); q.offer(q.poll()); return q.poll(); } public int top() { return topElem; } public boolean empty() { return q.isEmpty(); } } References 1. 用队列实现栈 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-225/","summary":"思路 直接套用队列实现栈的模板即可，详见思想篇章 代码 class MyStack { private Queue\u0026lt;Integer\u0026gt; q; private int topElem; public MyStack() { q = new LinkedList\u0026lt;\u0026gt;(); } public void push(int x) { q.offer(x); topElem = x; } public int pop() { int size = q.size(); while (size \u0026gt; 2) { q.offer(q.poll()); size--; } topElem =","title":"LeetCode 225"},{"content":"思路 直接套栈实现队列模板即可，详见思想篇章\n代码 class MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { s2.push(x); } public int pop() { peek(); return s1.pop(); } public int peek() { if (s1.isEmpty()) { while (!s2.isEmpty()) { s1.push(s2.pop()); } } return s1.peek(); } public boolean empty() { return s1.isEmpty() \u0026amp;\u0026amp; s2.isEmpty(); } } References 1. 用栈实现队列 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-232/","summary":"思路 直接套栈实现队列模板即可，详见思想篇章 代码 class MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { s2.push(x); } public int pop() { peek(); return s1.pop(); } public int peek() { if (s1.isEmpty()) { while (!s2.isEmpty()) { s1.push(s2.pop()); } }","title":"LeetCode 232"},{"content":"思路 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色），详见思想篇章\n代码 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); MonotonicQueue window = new MonotonicQueue(); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026lt; k - 1) { window.push(nums[i]); } else { window.push(nums[i]); res.add(window.max()); window.poll(nums[i - k + 1]); } } int[] arr = new int[res.size()]; for (int i = 0; i \u0026lt; res.size(); i++) { arr[i] = res.get(i); } return arr; } class MonotonicQueue { LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); private void push(int n) { while (!queue.isEmpty() \u0026amp;\u0026amp; queue.getLast() \u0026lt; n) { queue.pollLast(); } queue.addLast(n); } private void poll(int n) { if (n == queue.getFirst()) { queue.pollFirst(); } } private int max() { return queue.getFirst(); } } } References 1. 滑动窗口最大值 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-239/","summary":"思路 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色","title":"LeetCode 239"},{"content":"思路 利用单调栈的思想，同LeetCode-496，只不过牵扯到循环数组的问题，常用套路就是将数组长度翻倍，代码实现的时候也可以用i % nums.length来模拟数组长度翻倍\n代码 class Solution { public int[] nextGreaterElements(int[] nums) { int n = nums.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i = 2 * n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026lt;= nums[i % n]) { stack.pop(); } res[i % n] = stack.isEmpty() ? -1 : stack.peek(); stack.push(nums[i % n]); } return res; } } References 1. 下一个更大元素 II ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-503/","summary":"思路 利用单调栈的思想，同LeetCode-496，只不过牵扯到循环数组的问题，常用套路就是将数组长度翻倍，代码实现的时候也可以用i % nums","title":"LeetCode 503"},{"content":"思路 利用单调栈的思想即可，同LeetCode-496，只不过这次存的是索引而不是元素\n代码 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i = n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt;= temperatures[i]) { stack.pop(); } res[i] = stack.isEmpty() ? 0 : (stack.peek() - i); stack.push(i); } return res; } } References 1. 每日温度 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-739/","summary":"思路 利用单调栈的思想即可，同LeetCode-496，只不过这次存的是索引而不是元素 代码 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] res = new int[n]; for (int i =","title":"LeetCode 739"},{"content":"思路 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充当下一个更大元素的角色（中间去除的元素是无法充当这种角色的），那么此时栈顶就是当前元素下一个更大元素\n代码 class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int n = nums2.length; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; res = new HashMap\u0026lt;\u0026gt;(); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026lt;= nums2[i]) { stack.pop(); } res.put(nums2[i], stack.isEmpty() ? -1 : stack.peek()); stack.push(nums2[i]); } for (int i = 0; i \u0026lt; nums1.length; i++) { nums1[i] = res.get(nums1[i]); } return nums1; } } References 1. 下一个更大元素 I ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-496/","summary":"思路 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充","title":"LeetCode 496"},{"content":"思路 经典TrieMap问题，不解释\n代码 class MapSum { private TrieMap\u0026lt;Integer\u0026gt; trieMap; public MapSum() { this.trieMap = new TrieMap(); } public void insert(String key, int val) { trieMap.put(key, val); } public int sum(String prefix) { List\u0026lt;String\u0026gt; keys = trieMap.keysWithPrefix(prefix); int res = 0; for (String key : keys) { res += trieMap.get(key); } return res; } class TrieMap { /* 见思想篇章 */ } } References 1. 键值映射 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-677/","summary":"思路 经典TrieMap问题，不解释 代码 class MapSum { private TrieMap\u0026lt;Integer\u0026gt; trieMap; public MapSum() { this.trieMap = new TrieMap(); } public void insert(String key, int val) { trieMap.put(key, val); } public int sum(String prefix) { List\u0026lt;String\u0026gt; keys = trieMap.keysWithPrefix(prefix); int res = 0; for (String key : keys) { res += trieMap.get(key); } return res; } class","title":"LeetCode 677"},{"content":"思路 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg\n代码 class MedianFinder { private Queue\u0026lt;Integer\u0026gt; small; private Queue\u0026lt;Integer\u0026gt; large; public MedianFinder() { small = new PriorityQueue\u0026lt;\u0026gt;(); large = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return b - a; }); } public void addNum(int num) { if (small.size() \u0026gt; large.size()) { small.offer(num); large.offer(small.poll()); } else { large.offer(num); small.offer(large.poll()); } } public double findMedian() { if (small.size() \u0026gt; large.size()) { return small.peek(); } else if (small.size() \u0026lt; large.size()) { return large.peek(); } else { return (small.peek() + large.peek()) / 2.0; } } } References 1. 数据流的中位数 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-295/","summary":"思路 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：h","title":"LeetCode 295"},{"content":"思路 利用Trie树的思想即可，详见思想篇章\n代码 class WordDictionary { private TrieNode root; private static class TrieNode { boolean isEnd = false; TrieNode[] children = new TrieNode[26]; } public WordDictionary() { this.root = new TrieNode(); } public void addWord(String word) { this.root = put(root, word, 0); } private TrieNode put(TrieNode node, String word, int i) { if (node == null) { node = new TrieNode(); } if (i == word.length()) { node.isEnd = true; return node; } int c = word.charAt(i) - \u0026#39;a\u0026#39;; node.children[c] = put(node.children[c], word, i + 1); return node; } public boolean search(String word) { return hasKeyWithPattern(root, word, 0); } private boolean hasKeyWithPattern(TrieNode node, String word, int i) { if (node == null) { return false; } if (i == word.length()) { return node.isEnd; } char c = word.charAt(i); if (c != \u0026#39;.\u0026#39;) { return hasKeyWithPattern(node.children[c - \u0026#39;a\u0026#39;], word, i + 1); } for (int j = 0; j \u0026lt; 26; j++) { if (hasKeyWithPattern(node.children[j], word, i + 1)) { return true; } } return false; } } References 1. 添加与搜索单词 - 数据结构设计 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-211/","summary":"思路 利用Trie树的思想即可，详见思想篇章 代码 class WordDictionary { private TrieNode root; private static class TrieNode { boolean isEnd = false; TrieNode[] children = new TrieNode[26]; } public WordDictionary() { this.root = new TrieNode(); } public void addWord(String word) { this.root = put(root, word, 0); } private TrieNode put(TrieNode node, String word, int","title":"LeetCode 211"},{"content":"思路 经典前缀树（Trie）问题，只不过需要注意将dictionary添加进set即可（因为只添加进set的字符串才能充当前缀）\n代码 class Solution { public String replaceWords(List\u0026lt;String\u0026gt; dictionary, String sentence) { TrieSet trieSet = new TrieSet(); for (String key : dictionary) { trieSet.add(key); } String[] words = sentence.split(\u0026#34; \u0026#34;); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; words.length; i++) { String word = words[i]; String prefix = trieSet.shortestPrefixOf(word); if (prefix.isEmpty()) { sb.append(word); } else { sb.append(prefix); } if (i != words.length - 1) { sb.append(\u0026#34; \u0026#34;); } } return sb.toString(); } class TrieSet { /* 见思想篇章 */ } class TrieMap { /* 见思想篇章 */ } } References 1. 单词替换 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-648/","summary":"思路 经典前缀树（Trie）问题，只不过需要注意将dictionary添加进set即可（因为只添加进set的字符串才能充当前缀） 代码 class Solution { public String","title":"LeetCode 648"},{"content":"思路 经典前缀树（Trie）问题，直接套模板即可，详见思想篇章\n代码 class Trie { private TrieSet trieSet; public Trie() { this.trieSet = new TrieSet(); } public void insert(String word) { trieSet.add(word); } public boolean search(String word) { return trieSet.contains(word); } public boolean startsWith(String prefix) { return trieSet.hasKeyWithPrefix(prefix); } class TrieSet { /* 见思想篇章 */ } class TrieMap { /* 见思想篇章 */ } } References 1. 实现 Trie (前缀树) ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-208/","summary":"思路 经典前缀树（Trie）问题，直接套模板即可，详见思想篇章 代码 class Trie { private TrieSet trieSet; public Trie() { this.trieSet = new TrieSet(); } public void insert(String word) { trieSet.add(word); } public boolean search(String word) { return trieSet.contains(word); } public boolean startsWith(String prefix) { return trieSet.hasKeyWithPrefix(prefix); } class","title":"LeetCode 208"},{"content":"思路 经典LRU缓存问题，直接套LRU模板即可，详见思想篇章\n代码 手写轮子 class LRUCache { private Map\u0026lt;Integer, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private DoubleList cache = new DoubleList(); private int capacity; public LRUCache(int capacity) { this.capacity = capacity; } public int get(int key) { if (!map.containsKey(key)) { return -1; } makeRecently(key); return map.get(key).val; } public void put(int key, int value) { if (map.containsKey(key)) { deleteKey(key); addRecently(key, value); return; } if (cache.size() == capacity) { removeLeastRecently(); } addRecently(key, value); } private void makeRecently(int key) { Node x = map.get(key); cache.remove(x); cache.addLast(x); } private void addRecently(int key, int val) { Node x = new Node(key, val); cache.addLast(x); map.put(key, x); } private void deleteKey(int key) { Node x = map.get(key); cache.remove(x); map.remove(key); } private void removeLeastRecently() { Node x = cache.removeFirst(); map.remove(x.key); } class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class DoubleList { private Node head, tail; private int size; public DoubleList() { this.head = new Node(0, 0); this.tail = new Node(0, 0); head.next = tail; tail.prev = head; size = 0; } public void addLast(Node x) { x.next = tail; x.prev = tail.prev; tail.prev.next = x; tail.prev = x; size++; } public void remove(Node x) { x.prev.next = x.next; x.next.prev = x.prev; size--; } public Node removeFirst() { if (size == 0) { return null; } Node first = head.next; remove(first); return first; } public int size() { return size; } } } 重用LinkedHashMap class LRUCache { int cap; LinkedHashMap\u0026lt;Integer, Integer\u0026gt; cache = new LinkedHashMap\u0026lt;\u0026gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() \u0026gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); } } References 1. LRU 缓存 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-146/","summary":"思路 经典LRU缓存问题，直接套LRU模板即可，详见思想篇章 代码 手写轮子 class LRUCache { private Map\u0026lt;Integer, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private DoubleList cache = new DoubleList(); private int capacity; public LRUCache(int capacity) { this.capacity = capacity; } public int get(int key) { if (!map.containsKey(key)) {","title":"LeetCode 146"},{"content":"思路 经典LFU缓存问题，直接套LFU模板即可，详见思想篇章\n代码 class LFUCache { private Map\u0026lt;Integer, Integer\u0026gt; keyToVal; private Map\u0026lt;Integer, Integer\u0026gt; keyToFreq; private Map\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; private int minFreq; private int capacity; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.capacity = capacity; this.minFreq = 0; } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } increaseFreq(key); return keyToVal.get(key); } public void put(int key, int value) { if (this.capacity == 0) { return; } if (keyToVal.containsKey(key)) { keyToVal.put(key, value); increaseFreq(key); return; } if (keyToVal.size() == this.capacity) { removeMinFreqKey(); } keyToVal.put(key, value); keyToFreq.put(key, 1); freqToKeys.putIfAbsent(1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(1).add(key); this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); keyToFreq.put(key, freq + 1); freqToKeys.get(freq).remove(key); freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(freq + 1).add(key); if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); if (this.minFreq == freq) { this.minFreq++; } } } private void removeMinFreqKey() { LinkedHashSet\u0026lt;Integer\u0026gt; keyList = freqToKeys.get(this.minFreq); int deleteKey = keyList.iterator().next(); keyList.remove(deleteKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 这里不用修改minFreq因为后面会置为1 } keyToVal.remove(deleteKey); keyToFreq.remove(deleteKey); } } References 1. LFU 缓存 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-460/","summary":"思路 经典LFU缓存问题，直接套LFU模板即可，详见思想篇章 代码 class LFUCache { private Map\u0026lt;Integer, Integer\u0026gt; keyToVal; private Map\u0026lt;Integer, Integer\u0026gt; keyToFreq; private Map\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; private int minFreq; private int capacity; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.capacity =","title":"LeetCode 460"},{"content":"思路 两种思路：\nkruskal 利用kruskal算法即可，只不过这里的边需要自己生成，详见思想章节\nprim 利用prim算法即可，只不过这里的边需要自己生成，详见思想章节\n代码 kruskal class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; List\u0026lt;int[]\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { int xi = points[i][0], yi = points[i][1]; int xj = points[j][0], yj = points[j][1]; edges.add(new int[]{i, j, Math.abs(xi - xj) + Math.abs(yi- yj)}); } } Collections.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UF uf = new UF(n); int mst = 0; for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (uf.connected(u, v)) { continue; } mst += weight; uf.union(u, v); } return mst; } class UF { // 连通分量个数 private int count; // 存储每个节点的父节点 private int[] parent; // n 为图中节点的个数 public UF(int n) { this.count = n; parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } // 将节点 p 和节点 q 连通 public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootQ] = rootP; // 两个连通分量合并成一个连通分量 count--; } // 判断节点 p 和节点 q 是否连通 public boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } // 返回图中的连通分量个数 public int count() { return count; } } } prim class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; List\u0026lt;int[]\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { int xi = points[i][0], yi = points[i][1]; int xj = points[j][0], yj = points[j][1]; int weight = Math.abs(xi - xj) + Math.abs(yi- yj); graph[i].add(new int[]{i, j, weight}); graph[j].add(new int[]{j, i, weight}); } } return new Prim(graph).getWeightSum(); } class Prim { private List\u0026lt;int[]\u0026gt;[] graph; private Queue\u0026lt;int[]\u0026gt; pq; private boolean[] inMST; private int weightSum = 0; public Prim(List\u0026lt;int[]\u0026gt;[] graph) { this.graph = graph; this.pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a[2] - b[2]; }); int n = graph.length; inMST = new boolean[n]; inMST[0] = true; cut(0); while (!pq.isEmpty()) { int[] edge = pq.poll(); int to = edge[1]; int weight = edge[2]; if (inMST[to]) { continue; } weightSum += weight; inMST[to] = true; cut(to); } } private void cut(int s) { for (int[] edge : graph[s]) { int to = edge[1]; if (inMST[to]) { continue; } pq.offer(edge); } } private int getWeightSum() { return weightSum; } private boolean allConnected() { for (boolean b : inMST) { if (!b) { return false; } } return true; } } } References 1. 连接所有点的最小费用 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/","summary":"思路 两种思路： kruskal 利用kruskal算法即可，只不过这里的边需要自己生成，详见思想章节 prim 利用prim算法即可，只不过这里的边需要自己生成，详见","title":"LeetCode 1584"},{"content":"思路 dijkstra问题的变种，利用dijkstra模板即可，主要有两个注意点：\n首先需要构造图，构造图时注意无向图的一条边相当于两条有向边 weight计算方式与普通的dijkstra不同，即需要修改weight函数 代码 class Solution { class State { int id; double probFromStart; public State(int id, double probFromStart) { this.id = id; this.probFromStart = probFromStart; } } private double dijkstra(List\u0026lt;double[]\u0026gt;[] graph, int start, int end) { double[] probTo = new double[graph.length]; Arrays.fill(probTo, -1); probTo[start] = 1; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;State\u0026gt;((a, b) -\u0026gt; { return Double.compare(b.probFromStart, a.probFromStart); }); pq.offer(new State(start, 1)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeId = curState.id; double curProbFromStart = curState.probFromStart; if (curNodeId == end) { return probTo[end]; } if (curProbFromStart \u0026lt; probTo[curNodeId]) { continue; } for (double[] neighbor : graph[curNodeId]) { int nextId = (int) neighbor[0]; double nextProbFromStart = curProbFromStart * neighbor[1]; if (nextProbFromStart \u0026gt; probTo[nextId]) { probTo[nextId] = nextProbFromStart; pq.offer(new State(nextId, nextProbFromStart)); } } } return 0.0; } public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) { List\u0026lt;double[]\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; succProb.length; i++) { int from = edges[i][0]; int to = edges[i][1]; double weight = succProb[i]; graph[from].add(new double[]{to, weight}); graph[to].add(new double[]{from, weight}); } return dijkstra(graph, start, end); } } References 1. 概率最大的路径 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1514/","summary":"思路 dijkstra问题的变种，利用dijkstra模板即可，主要有两个注意点： 首先需要构造图，构造图时注意无向图的一条边相当于两条有向边 w","title":"LeetCode 1514"},{"content":"思路 利用dijkstra的思想，只不过需要把矩阵里的每个元素当成一个结点，求一个结点的相邻结点与一般的图不同（即adj函数），而且最后求的体力消耗是路径上体力的最大值，不是体力消耗之和，所以刷新权重的时候需要编写相应的weight函数\n其实dijsktra问题的变种只要编写相应的adj函数和weight函数即可\n代码 class Solution { class State { int x, y; int effortFromStart; public State(int x, int y, int effortFromStart) { this.x = x; this.y = y; this.effortFromStart = effortFromStart; } } private int[][] dirs = new int[][]{{0, 1}, {0, -1}, {-1, 0}, {1, 0}}; private List\u0026lt;int[]\u0026gt; adj(int[][] matrix, int x, int y) { int m = matrix.length, n = matrix[0].length; List\u0026lt;int[]\u0026gt; neighbors = new ArrayList\u0026lt;\u0026gt;(); for (int[] dir : dirs) { int nx = x + dir[0]; int ny = y + dir[1]; if (nx \u0026lt; 0 || nx \u0026gt;= m || ny \u0026lt; 0 || ny \u0026gt;= n) { continue; } neighbors.add(new int[]{nx, ny}); } return neighbors; } public int minimumEffortPath(int[][] heights) { int m = heights.length, n = heights[0].length; int[][] effortTo = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { Arrays.fill(effortTo[i], Integer.MAX_VALUE); } effortTo[0][0] = 0; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.effortFromStart - b.effortFromStart; }); pq.offer(new State(0, 0, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curX = curState.x; int curY = curState.y; int curEffortFromStart = curState.effortFromStart; if (curX == m -1 \u0026amp;\u0026amp; curY == n - 1) { return curEffortFromStart; } if (curEffortFromStart \u0026gt; effortTo[curX][curY]) { continue; } for (int[] neighbor : adj(heights, curX, curY)) { int nextX = neighbor[0]; int nextY = neighbor[1]; int nextEffort = Math.max(effortTo[curX][curY], Math.abs(heights[nextX][nextY] - heights[curX][curY])); if (nextEffort \u0026lt; effortTo[nextX][nextY]) { effortTo[nextX][nextY] = nextEffort; pq.offer(new State(nextX, nextY, nextEffort)); } } } return -1; } } References 1. 最小体力消耗路径 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1631/","summary":"思路 利用dijkstra的思想，只不过需要把矩阵里的每个元素当成一个结点，求一个结点的相邻结点与一般的图不同（即adj函数），而且最后求的体","title":"LeetCode 1631"},{"content":"思路 经典dijkstra问题，利用dijkstra模板即可，详见思想章节\n代码 class Solution { class State { int id; int distFromStart; public State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } private int[] dijkstra(List\u0026lt;int[]\u0026gt;[] graph, int start) { int[] distTo = new int[graph.length]; Arrays.fill(distTo, Integer.MAX_VALUE); distTo[start] = 0; Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.distFromStart - b.distFromStart; }); pq.offer(new State(start, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeId = curState.id; int curDistFromStart = curState.distFromStart; if (curDistFromStart \u0026gt; distTo[curNodeId]) { continue; } for (int[] neighbor : graph[curNodeId]) { int neighborId = neighbor[0]; int distToNeighbor = distTo[curNodeId] + neighbor[1]; if (distToNeighbor \u0026lt; distTo[neighborId]) { distTo[neighborId] = distToNeighbor; pq.offer(new State(neighborId, distToNeighbor)); } } } return distTo; } public int networkDelayTime(int[][] times, int n, int k) { List\u0026lt;int[]\u0026gt;[] graph = new List[n + 1]; for (int i = 1; i \u0026lt; n + 1; i++) { graph[i] = new ArrayList\u0026lt;\u0026gt;(); } for (int[] time : times) { int from = time[0]; int to = time[1]; int weight = time[2]; graph[from].add(new int[]{to, weight}); } int[] distTo = dijkstra(graph, k); int res = 0; for (int i = 1; i \u0026lt; n + 1; i++) { if (distTo[i] == Integer.MAX_VALUE) { return -1; } res = Math.max(res, distTo[i]); } return res; } } References 1. 网络延迟时间 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-743/","summary":"思路 经典dijkstra问题，利用dijkstra模板即可，详见思想章节 代码 class Solution { class State { int id; int distFromStart; public State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } private int[] dijkstra(List\u0026lt;int[]\u0026gt;[] graph, int start) { int[]","title":"LeetCode 743"},{"content":"思路 利用并查集的思想，先将相等的连接起来，然后再判断不相等的是否与并查集里的连通状态冲突\n代码 class Solution { public boolean equationsPossible(String[] equations) { UF uf = new UF(26); for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) { uf.union(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;); } } for (String equation : equations) { if (equation.charAt(1) == \u0026#39;!\u0026#39;) { if (uf.isConnected(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;)) { return false; } } } return true; } class UF { private int[] parent; private int count; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } count = n; } public int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int xRoot = find(x); int yRoot = find(y); if (xRoot == yRoot) { return; } parent[xRoot] = yRoot; count--; } public boolean isConnected(int x, int y) { int xRoot = find(x); int yRoot = find(y); return xRoot == yRoot; } public int getCount() { return count; } } } References 1. 等式方程的可满足性 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-990/","summary":"思路 利用并查集的思想，先将相等的连接起来，然后再判断不相等的是否与并查集里的连通状态冲突 代码 class Solution { public boolean equationsPossible(String[] equations) { UF uf = new UF(26); for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) {","title":"LeetCode 990"},{"content":"思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的\u0026rsquo;O\u0026rsquo;相连的\u0026rsquo;O\u0026rsquo;加入到dummy的集合中，然后遍历一遍二维数组，将不在dummy集合里的\u0026rsquo;O\u0026rsquo;改成\u0026rsquo;X\u0026rsquo;即可\n代码 class Solution { public void solve(char[][] board) { int m = board.length; int n = board[0].length; UF uf = new UF(m * n + 1); int dummy = m * n; for (int i = 0; i \u0026lt; m; i++) { if (board[i][0] == \u0026#39;O\u0026#39;) { uf.union(dummy,i * n); } if (board[i][n - 1] == \u0026#39;O\u0026#39;) { uf.union(dummy,i * n + n - 1); } } for (int i = 0; i \u0026lt; n; i++) { if (board[0][i] == \u0026#39;O\u0026#39;) { uf.union(dummy, i); } if (board[m - 1][i] == \u0026#39;O\u0026#39;) { uf.union(dummy, (m - 1) * n + i); } } int[][] d = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; for (int i = 1; i \u0026lt; m - 1; i++) { for (int j = 1; j \u0026lt; n - 1; j++) { if (board[i][j] == \u0026#39;O\u0026#39;) { for (int k = 0; k \u0026lt; 4; k++) { int x = i + d[k][0]; int y = j + d[k][1]; if (board[x][y] == \u0026#39;O\u0026#39;) { uf.union(i * n + j, x * n + y); } } } } } for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (!uf.isConnected(i * n + j, dummy)) { board[i][j] = \u0026#39;X\u0026#39;; } } } } class UF { private int[] parent; private int count; public UF(int n) { parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } count = n; } public int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int xRoot = find(x); int yRoot = find(y); if (xRoot == yRoot) { return; } parent[xRoot] = yRoot; count--; } public boolean isConnected(int x, int y) { int xRoot = find(x); int yRoot = find(y); return xRoot == yRoot; } public int getCount() { return count; } } } References 1. 被围绕的区域 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-130/","summary":"思路 利用并查集的思想，设置一个dummy结点，想办法把与边界的\u0026rsquo;O\u0026rsquo;相连的\u0026rsquo;O\u0026rsquo;加入到dum","title":"LeetCode 130"},{"content":"思路 经典二分图判断，只不过需要先构造一个图，详见思想章节\n代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(n, dislikes); for (int i = 1; i \u0026lt;= n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int n, int[][] dislikes) { List\u0026lt;Integer\u0026gt;[] graph = new List[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] dislike : dislikes) { int s = dislike[0]; int d = dislike[1]; graph[s].add(d); graph[d].add(s); } return graph; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int v) { if (!ok) { return; } visited[v] = true; for (int neighbor : graph[v]) { if (!visited[neighbor]) { color[neighbor] = !color[v]; traverse(graph, neighbor); } else { if (color[v] == color[neighbor]) { ok = false; return; } } } } } References 1. 可能的二分法 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-886/","summary":"思路 经典二分图判断，只不过需要先构造一个图，详见思想章节 代码 class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean possibleBipartition(int n, int[][] dislikes) { color = new boolean[n + 1]; visited = new boolean[n + 1]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(n, dislikes); for (int","title":"LeetCode 886"},{"content":"思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节\n代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color = new boolean[n]; visited = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private void traverse(int[][] graph, int v) { if (!ok) { return; } visited[v] = true; for (int neighbor : graph[v]) { if (!visited[neighbor]) { color[neighbor] = !color[v]; traverse(graph, neighbor); } else { if (color[v] == color[neighbor]) { ok = false; return; } } } } } BFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color = new boolean[n]; visited = new boolean[n]; for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { traverse(graph, i); } } return ok; } private void traverse(int[][] graph, int start) { if (!ok) { return; } Deque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); visited[start] = true; queue.offer(start); while (!queue.isEmpty() \u0026amp;\u0026amp; ok) { int v = queue.poll(); for (int n : graph[v]) { if (!visited[n]) { color[n] = !color[v]; visited[n] = true; queue.offer(n); } else { if (color[n] == color[v]) { ok = false; return; } } } } } } References 1. 判断二分图 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-785/","summary":"思路 经典二分图判断问题，利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节 代码 DFS class Solution { private boolean ok = true; private boolean[] color; private boolean[] visited; public boolean isBipartite(int[][] graph) { int n = graph.length; color","title":"LeetCode 785"},{"content":"思路 寻找可行的选课顺序其实就是计算拓扑排序\n思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序\n思路二 利用图的BFS，只不过只把入度为零的结点加入队列，队列出队的序列就是该图的拓扑排序\n代码 思路一 class Solution { private boolean[] visited; private boolean[] onPath; private boolean hasCycle = false; private List\u0026lt;Integer\u0026gt; postorder = new LinkedList\u0026lt;\u0026gt;(); public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i]) { traverse(graph, i); } } if (hasCycle) { return new int[0]; } Collections.reverse(postorder); int[] res = new int[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { res[i] = postorder.get(i); } return res; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; return; } if (visited[s]) { return; } visited[s] = true; onPath[s] = true; for (Integer n : graph[s]) { traverse(graph, n); } onPath[s] = false; postorder.add(s); } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } 思路二 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int to = edge[0]; indegree[to]++; } Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int count = 0; int[] res = new int[numCourses]; while (!queue.isEmpty()) { int node = queue.poll(); res[count] = node; count++; for (Integer next : graph[node]) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } if (count != numCourses) { return new int[0]; } return res; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } References 1. 课程表 II ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-210/","summary":"思路 寻找可行的选课顺序其实就是计算拓扑排序 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无","title":"LeetCode 210"},{"content":"思路 这道题其实就是检测图里是否有环\n思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回\n思路二 利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列即可，最后判断访问过的结点个数是否等于总结点个数\n代码 思路一 class Solution { private boolean[] visited; private boolean[] onPath; private boolean hasCycle = false; public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i]) { traverse(graph, i); } } return !hasCycle; } private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; return; } if (visited[s]) { return; } visited[s] = true; onPath[s] = true; for (Integer n : graph[s]) { traverse(graph, n); } onPath[s] = false; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } 思路二 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int to = edge[0]; indegree[to]++; } Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int count = 0; while (!queue.isEmpty()) { int node = queue.poll(); count++; for (Integer next : graph[node]) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } return count == numCourses; } private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; graph[from].add(to); } return graph; } } References 1. 课程表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-207/","summary":"思路 这道题其实就是检测图里是否有环 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该","title":"LeetCode 207"},{"content":"思路 经典图的遍历，只不过要同时记录路径\n代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList\u0026lt;Integer\u0026gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s == n) { res.add(new LinkedList\u0026lt;\u0026gt;(path)); path.removeLast(); return; } for (int v : graph[s]) { traverse(graph, v, path); } // 离开结点时 path.removeLast(); } } References 1. 所有可能的路径 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-797/","summary":"思路 经典图的遍历，只不过要同时记录路径 代码 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allPathsSourceTarget(int[][] graph) { LinkedList\u0026lt;Integer\u0026gt; path = new LinkedList\u0026lt;\u0026gt;(); traverse(graph, 0, path); return res; } private void traverse(int[][] graph, int s, LinkedList\u0026lt;Integer\u0026gt; path) { // 进入结点时 path.add(s); int n = graph.length - 1; if (s","title":"LeetCode 797"},{"content":"思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树\n这种做法时间复杂度是O(logn*logn)，详见：https://labuladong.gitee.io/algo/2/21/48/\n代码 class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } TreeNode left = root, right = root; int lh = 0, rh = 0; while (left != null) { left = left.left; lh++; } while (right != null) { right = right.right; rh++; } if (lh == rh) { return (int) (Math.pow(2, lh) - 1); } return 1 + countNodes(root.left) + countNodes(root.right); } } References 1. 完全二叉树的节点个数 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-222/","summary":"思路 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和","title":"LeetCode 222"},{"content":"思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是LCA\n代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { int val1 = Math.min(p.val, q.val); int val2 = Math.max(p.val, q.val); return find(root, val1, val2); } private TreeNode find(TreeNode root, int val1, int val2) { if (root == null) { return null; } if (root.val \u0026gt; val2) { return find(root.left, val1, val2); } if (root.val \u0026lt; val1) { return find(root.right, val1, val2); } return root; } } References 1. 二叉搜索树的最近公共祖先 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/","summary":"思路 跟236类似，只不过不需要一个一个遍历，因为是BST，可以根据结点的大小选择去左子树还是右子树，第一个在val1和val2之间的结点就是","title":"LeetCode 235"},{"content":"思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或q或qp的LCA\n代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return findLCA(root, p.val, q.val); } private TreeNode findLCA(TreeNode root, int p, int q) { if (root == null) { return null; } if (root.val == p || root.val == q) { return root; } TreeNode left = findLCA(root.left, p, q); TreeNode right = findLCA(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left != null ? left : right; } } References 1. 二叉树的最近公共祖先 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/","summary":"思路 使用二叉树遍历的思想，遍历每一个节点，当左子树找到了q或p，右子树也找到了的话，该节点就是LCA，直接返回即可，注意返回值只有可能是p或","title":"LeetCode 236"},{"content":"思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码\n思路二 思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代\n代码 思路一 public class NestedIterator implements Iterator\u0026lt;Integer\u0026gt; { private Iterator\u0026lt;Integer\u0026gt; it; public NestedIterator(List\u0026lt;NestedInteger\u0026gt; nestedList) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (NestedInteger nestedInteger : nestedList) { traverse(nestedInteger, result); } it = result.iterator(); } private void traverse(NestedInteger nestedInteger, List\u0026lt;Integer\u0026gt; result) { if (nestedInteger.isInteger()) { result.add(nestedInteger.getInteger()); return; } List\u0026lt;NestedInteger\u0026gt; list = nestedInteger.getList(); for (NestedInteger integer : list) { traverse(integer, result); } } @Override public Integer next() { return it.next(); } @Override public boolean hasNext() { return it.hasNext(); } } 思路二 public class NestedIterator implements Iterator\u0026lt;Integer\u0026gt; { private LinkedList\u0026lt;NestedInteger\u0026gt; nestedList; public NestedIterator(List\u0026lt;NestedInteger\u0026gt; nestedList) { this.nestedList = new LinkedList\u0026lt;\u0026gt;(nestedList); } @Override public Integer next() { return nestedList.remove(0).getInteger(); } @Override public boolean hasNext() { while (!nestedList.isEmpty() \u0026amp;\u0026amp; !nestedList.get(0).isInteger()) { List\u0026lt;NestedInteger\u0026gt; first = nestedList.remove(0).getList(); for (int i = first.size() - 1; i \u0026gt;= 0; i--) { nestedList.addFirst(first.get(i)); } } return !nestedList.isEmpty(); } } References 1. 扁平化嵌套列表迭代器 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-341/","summary":"思路 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码 思路二 思路一会在","title":"LeetCode 341"},{"content":"思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用\n我的代码 class Solution { private List\u0026lt;TreeNode\u0026gt; generateTrees(int min, int max) { List\u0026lt;TreeNode\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (min \u0026gt; max) { res.add(null); return res; } for (int i = min; i \u0026lt;= max; i++) { List\u0026lt;TreeNode\u0026gt; leftList = generateTrees(min, i - 1); List\u0026lt;TreeNode\u0026gt; rightList = generateTrees(i + 1, max); for (TreeNode leftNode : leftList) { for (TreeNode rightNode : rightList) { TreeNode root = new TreeNode(i); root.left = leftNode; root.right = rightNode; res.add(root); } } } return res; } public List\u0026lt;TreeNode\u0026gt; generateTrees(int n) { return generateTrees(1, n); } } References 1. 不同的二叉搜索树 II ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-95/","summary":"思路 类似LeetCode 96，利用分解问题的思想，将原问题分解为：构造root+构造左子树+构造右子树即可，但是注意root不能重复利用 我的","title":"LeetCode 95"},{"content":"思路 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类\n动态规划 递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划\n我的代码 递归 class Solution { public int numTrees(int n) { if (n == 1 || n == 0) { return 1; } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += numTrees(i) * numTrees(n - i - 1); } return sum; } } 动态规划 class Solution { public int numTrees(int n) { int[] num = new int[n + 1]; num[0] = num[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; i; j++) { num[i] += num[j] * num[i - j - 1]; } } return num[n]; } } References 1. 不同的二叉搜索树 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-96/","summary":"思路 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这","title":"LeetCode 96"},{"content":"思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种情况：\nroot左右皆为空，此时直接删除 root左右有一个为空，将不为空的子树替换为当前结点的位置 root左右都不为空，找左子树中最大的或右子树中最小的替换root 我的代码 class Solution { private TreeNode getMin(TreeNode root) { while (root.left != null) { root = root.left; } return root; } public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return null; if (root.val == key) { // 删除该结点 if (root.left == null \u0026amp;\u0026amp; root.right == null) { return null; } if (root.left == null) return root.right; if (root.right == null) return root.left; TreeNode min = getMin(root.right); root.right = deleteNode(root.right, min.val); min.left = root.left; min.right = root.right; root = min; } if (key \u0026gt; root.val) { root.right = deleteNode(root.right, key); } if (key \u0026lt; root.val) { root.left = deleteNode(root.left, key); } return root; } } References 1. 删除二叉搜索树中的节点 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-504/","summary":"思路 删除时先把删除的结点跟root比较，小于root在左子树中删除，大于root在右子树中删除，等于root时，需要删除root，有以下三种","title":"LeetCode 504"},{"content":"思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造\n我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } if (val \u0026gt; root.val) { root.right = insertIntoBST(root.right, val); } if (val \u0026lt; root.val) { root.left = insertIntoBST(root.left, val); } return root; } } References 1. 二叉搜索树中的插入操作 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-701/","summary":"思路 类比构造二叉树，需要把问题分解为：构造root+构造左子树+构造右子树，注意只有root为null时需要构造 我的代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) {","title":"LeetCode 701"},{"content":"思路 利用二分查找的思想，不解释了\n我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val \u0026gt; root.val) { return searchBST(root.right, val); } if (val \u0026lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜索 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-700/","summary":"思路 利用二分查找的思想，不解释了 我的代码 class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val \u0026gt; root.val) { return searchBST(root.right, val); } if (val \u0026lt; root.val) { return searchBST(root.left, val); } return root; } } References 1. 二叉搜索树中的搜","title":"LeetCode 700"},{"content":"思路 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去\n我的代码 class Solution { private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) { if (root == null) { return true; } if (min != null \u0026amp;\u0026amp; root.val \u0026lt;= min.val) return false; if (max != null \u0026amp;\u0026amp; root.val \u0026gt;= max.val) return false; return isValidBST(root.left, min, root) \u0026amp; isValidBST(root.right, root, max); } public boolean isValidBST(TreeNode root) { return isValidBST(root, null, null); } } References 1. 验证二叉搜索树 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-98/","summary":"思路 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题","title":"LeetCode 98"},{"content":"思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，这样的话遍历到当前节点的时候，比这个结点大的结点已经遍历完了，用个变量累加一下，然后赋值给当前结点就可以了\n我的代码 class Solution { private int sum = 0; public TreeNode convertBST(TreeNode root) { if (root == null) { return null; } convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root; } } References 1. 把二叉搜索树转换为累加树 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-538/","summary":"思路 因为要累加比自己更大的结点的值，所以完全可以在升序序列里倒着遍历，把累加的值放到节点里去，所以这里采用中序遍历，但是是先右子树再左子树，","title":"LeetCode 538"},{"content":"思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return\n我的代码 class Solution { private int rank = 0; public int kthSmallest(TreeNode root, int k) { if (root == null) { return 0; } int res; if ((res = kthSmallest(root.left, k)) != 0) { return res; } rank++; if (rank == k) { return root.val; } return kthSmallest(root.right, k); } } References 1. 二叉搜索树中第 K 小的元素 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-230/","summary":"思路 BST的中序遍历就是升序序列，所以先中序遍历，然后找第k大的就行了，但是可以优化一下，找到第k大的就直接return 我的代码 class Solution { private int rank","title":"LeetCode 230"},{"content":"思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（空结点和左右子树都不为null的结点），如果是那就出栈挂在新栈顶的左子树或右子树上，循环往复，直到所有的结点都被加入到栈中，树就被反序列化完成了\n官方思路一 序列化和反序列化均采用分解问题的思想，序列化不用多说，这里把反序列化问题拆分为：新建根节点+反序列化左子树+反序列化右子树（我当时为什么没想到，因为没想到还要写base case）\n官方思路二 使用文法的思想，可以将树用T -\u0026gt; (T) num (T) | X文法来序列化和反序列化，其实本质思路和我的思路一样\n代码 我的代码 public class Codec { private static final char NULL = \u0026#39;#\u0026#39;; private static final char SEP = \u0026#39;,\u0026#39;; private void doSerialize(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(NULL).append(SEP); return; } sb.append(root.val).append(SEP); doSerialize(root.left, sb); doSerialize(root.right, sb); } // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); doSerialize(root, sb); return sb.toString(); } private TreeNode newTreeNode(String val) { if (\u0026#34;#\u0026#34;.equals(val)) { return new TreeNode(-1001); } return new TreeNode(Integer.parseInt(val)); } private TreeNode fixTree(TreeNode root) { if (root == null || root.val == -1001) { return null; } root.left = fixTree(root.left); root.right = fixTree(root.right); return root; } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] nodes = data.split(\u0026#34;,\u0026#34;); Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); TreeNode dummyRoot = new TreeNode(1001); stack.push(dummyRoot); for (int i = 0; i \u0026lt; nodes.length; i++) { stack.push(newTreeNode(nodes[i])); while (stack.peek().val == -1001 || stack.peek().left != null \u0026amp;\u0026amp; stack.peek().right != null) { TreeNode peek = stack.pop(); if (stack.peek().left == null) { stack.peek().left = peek; } else { stack.peek().right = peek; } } } return fixTree(dummyRoot).left; } } 官方思路一 public class Codec { public String serialize(TreeNode root) { return rserialize(root, \u0026#34;\u0026#34;); } public TreeNode deserialize(String data) { String[] dataArray = data.split(\u0026#34;,\u0026#34;); List\u0026lt;String\u0026gt; dataList = new LinkedList\u0026lt;String\u0026gt;(Arrays.asList(dataArray)); return rdeserialize(dataList); } public String rserialize(TreeNode root, String str) { if (root == null) { str += \u0026#34;None,\u0026#34;; } else { str += str.valueOf(root.val) + \u0026#34;,\u0026#34;; str = rserialize(root.left, str); str = rserialize(root.right, str); } return str; } public TreeNode rdeserialize(List\u0026lt;String\u0026gt; dataList) { if (dataList.get(0).equals(\u0026#34;None\u0026#34;)) { dataList.remove(0); return null; } TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0))); dataList.remove(0); root.left = rdeserialize(dataList); root.right = rdeserialize(dataList); return root; } } 官方思路二 public class Codec { public String serialize(TreeNode root) { if (root == null) { return \u0026#34;X\u0026#34;; } String left = \u0026#34;(\u0026#34; + serialize(root.left) + \u0026#34;)\u0026#34;; String right = \u0026#34;(\u0026#34; + serialize(root.right) + \u0026#34;)\u0026#34;; return left + root.val + right; } public TreeNode deserialize(String data) { int[] ptr = {0}; return parse(data, ptr); } public TreeNode parse(String data, int[] ptr) { if (data.charAt(ptr[0]) == \u0026#39;X\u0026#39;) { ++ptr[0]; return null; } TreeNode cur = new TreeNode(0); cur.left = parseSubtree(data, ptr); cur.val = parseInt(data, ptr); cur.right = parseSubtree(data, ptr); return cur; } public TreeNode parseSubtree(String data, int[] ptr) { ++ptr[0]; // 跳过左括号 TreeNode subtree = parse(data, ptr); ++ptr[0]; // 跳过右括号 return subtree; } public int parseInt(String data, int[] ptr) { int x = 0, sgn = 1; if (!Character.isDigit(data.charAt(ptr[0]))) { sgn = -1; ++ptr[0]; } while (Character.isDigit(data.charAt(ptr[0]))) { x = x * 10 + data.charAt(ptr[0]++) - \u0026#39;0\u0026#39;; } return x * sgn; } } References 1. 二叉树的序列化与反序列化 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-297/","summary":"思路 我的思路 序列化采用前序遍历即可，反序列化先把序列化的字符串分隔开，然后将分割的元素转换为结点，逐个加入栈中，并且判断栈顶是不是完整的树（","title":"LeetCode 297"},{"content":"思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树\n详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] preorder, int preStart, int preEnd, int[] postorder, int postStart, int postEnd) { if (preStart \u0026gt; preEnd) { return null; } if (preStart == preEnd) { return new TreeNode(preorder[preStart]); } int val = preorder[preStart]; TreeNode root = new TreeNode(val); int leftIndex = valToIndex.get(preorder[preStart + 1]); int leftSize = leftIndex - postStart + 1; TreeNode left = build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, leftIndex); TreeNode right = build(preorder, preStart + leftSize + 1, preEnd, postorder, leftIndex + 1, postEnd - 1); root.left = left; root.right = right; return root; } public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { for (int i = 0; i \u0026lt; postorder.length; i++) { valToIndex.put(postorder[i], i); } return build(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1); } } References 1. 根据前序和后序遍历构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-889/","summary":"思路 同LeetCode-105，就是改一下递归的参数，而且前序和后序无法唯一确定一棵树 详见：https://blog.zhangmengya","title":"LeetCode 889"},{"content":"思路 同LeetCode-105，就是改一下递归的参数\n详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] postorder, int postStart, int postEnd, int[] inorder, int inStart, int inEnd) { if (postStart \u0026gt; postEnd) { return null; } int val = postorder[postEnd]; TreeNode root = new TreeNode(val); int index = valToIndex.get(val); int leftSize = index - inStart; TreeNode left = build(postorder, postStart, postStart + leftSize - 1, inorder, inStart, index - 1); TreeNode right = build(postorder, postStart + leftSize, postEnd - 1, inorder, index + 1, inEnd); root.left = left; root.right = right; return root; } public TreeNode buildTree(int[] inorder, int[] postorder) { for (int i = 0; i \u0026lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(postorder, 0, postorder.length - 1, inorder, 0, inorder.length - 1); } } References 1. 从后序和中序遍历序列构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-106/","summary":"思路 同LeetCode-105，就是改一下递归的参数 详见：https://blog.zhangmengyang.tk/posts/leetc","title":"LeetCode 106"},{"content":"思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据root在中序遍历的位置得到左右子树节点的个数，再构造左右子树即可\n注意这里可以用map优化通过元素的值找所在数组的索引，用一个valToIndex的hashmap即可\n代码 class Solution { private Map\u0026lt;Integer, Integer\u0026gt; valToIndex = new HashMap(); private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { if (preStart \u0026gt; preEnd) { return null; } int val = preorder[preStart]; TreeNode root = new TreeNode(val); int index = valToIndex.get(val); int leftSize = index - inStart; TreeNode left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); TreeNode right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); root.left = left; root.right = right; return root; } public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i \u0026lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } } References 1. 从前序和中序遍历序列构造二叉树 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/","summary":"思路 经典根据前中遍历序列构造树，利用分解问题的思想，将问题拆分为找出root+构造左子树+构造右子树，前序遍历第一个就是root，再根据ro","title":"LeetCode 105"},{"content":"思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即可\n代码 class Solution { private TreeNode build(int[] nums, int low, int high) { if (low \u0026gt; high) { return null; } int max = nums[low], index = low; for (int i = low + 1; i \u0026lt;= high; i++) { if (nums[i] \u0026gt; max) { max = nums[i]; index = i; } } TreeNode root = new TreeNode(max); TreeNode left = build(nums, low, index - 1); TreeNode right = build(nums, index + 1, high); root.left = left; root.right = right; return root; } public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0 , nums.length - 1); } } References 1. 最大二叉树 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-654/","summary":"思路 利用二叉树分解问题的思想，将原问题分解为找出root结点+构造左子树+构造右子树，找出root结点，遍历数组即可，构造左右子树递归调用即","title":"LeetCode 654"},{"content":"思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路\n将该问题分解为：左子树展开+右子树展开+将右子树接到左子树上，即可，不过需要注意左右子树为空的情况\n代码 class Solution { private TreeNode tranToLinkedList(TreeNode root) { if (root == null) { return null; } TreeNode left = root.left; TreeNode right = root.right; TreeNode leftLast = tranToLinkedList(left); TreeNode rightLast = tranToLinkedList(right); if (leftLast == null) { root.left = null; root.right = right; } else if (rightLast == null) { root.left = null; root.right = left; } else { root.left = null; root.right = left; leftLast.right = right; } return rightLast != null ? rightLast : (leftLast != null ? leftLast : root); } public void flatten(TreeNode root) { if (root == null) { return; } tranToLinkedList(root); } } References 1. 二叉树展开为链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-114/","summary":"思路 由于题目要求原地转换为链表所以不能使用遍历的方法，一边遍历一遍新建一个链表，只能使用分解问题的思路 将该问题分解为：左子树展开+右子树展开","title":"LeetCode 114"},{"content":"思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历\n思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的\n思路二 把间隙看成结点，那么间隙组成的数据结构就是一颗三叉树，遍历这个三叉树即可解决问题，每个间隙结点需要做的事是把这个间隙的两个结点连接起来，在前中后序位置都可以\n代码 思路一 class Solution { public Node connect(Node root) { if (root == null) { return null; } Deque\u0026lt;Node\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { Node cur = queue.poll(); if (cur.left != null) { queue.offer(cur.left); queue.offer(cur.right); } if (i == size - 1) { cur.next = null; } else { cur.next = queue.peek(); } } } return root; } } 思路二 class Solution { private void traverse(Node left, Node right) { if (left == null) { return; } left.next = right; traverse(left.left, left.right); traverse(left.right, right.left); traverse(right.left, right.right); } public Node connect(Node root) { if (root == null) { return null; } traverse(root.left, root.right); return root; } } References 1. 填充每个节点的下一个右侧节点指针 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/","summary":"思路 有两种思路，分别是层序遍历和把间隙看成结点的遍历 思路一 层序遍历，遍历一层就把这层的结点加上next，没什么好说的 思路二 把间隙看成结点，那","title":"LeetCode 116"},{"content":"思路 遍历方式和分解方式都可以\n遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可\n分解思路 利用二叉树的分解问题思想，将原问题分解为左子树的翻转和右子树的分解，然后翻转左右子树\n代码 遍历思路 class Solution { private void traverse(TreeNode root) { if (root == null) { return; } TreeNode temp = root.right; root.right = root.left; root.left = temp; traverse(root.left); traverse(root.right); } public TreeNode invertTree(TreeNode root) { traverse(root); return root; } } 分解思路 class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; } } References 1. 翻转二叉树 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/","summary":"思路 遍历方式和分解方式都可以 遍历思路 利用二叉树的遍历思想，遍历一遍，遍历的时候，将每个正在遍历的结点交换左右子树即可 分解思路 利用二叉树的分解","title":"LeetCode 226"},{"content":"思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，因为只有后序遍历能获得左右子树的信息。\n代码 class Solution { int maxDiameter = 0; private int maxDeep(TreeNode root) { if (root == null) { return 0; } int leftDeep = maxDeep(root.left); int rightDeep = maxDeep(root.right); maxDiameter = Math.max(maxDiameter, leftDeep + rightDeep); return Math.max(leftDeep, rightDeep) + 1; } public int diameterOfBinaryTree(TreeNode root) { maxDeep(root); return maxDiameter; } } References 1. 二叉树的直径 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-543/","summary":"思路 直径等于左子树的深度加右子树的深度，那么遍历一遍树，找出直径里的最大值即可，不过需要注意，因为要获得每个节点子树的深度，需要用后序遍历，","title":"LeetCode 543"},{"content":"思路 有两种思路，分别是分解问题和遍历二叉树\n思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度\n思路二 把二叉树遍历一遍，同时用一个外部变量记录最大的深度，注意需要在前序位置deep++，后序位置deep\u0026ndash;\n代码 思路一 class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } } 思路二 class Solution { int res = 0, deep = 0; private void traverse(TreeNode root) { if (root == null) { return; } deep++; if (root.left == null \u0026amp;\u0026amp; root.right == null) { res = Math.max(res, deep); } traverse(root.left); traverse(root.right); deep--; } public int maxDepth(TreeNode root) { traverse(root); return res; } } References 1. 二叉树的最大深度 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/","summary":"思路 有两种思路，分别是分解问题和遍历二叉树 思路一 把当前问题分解为左子树和右子树中深度较大的那个子树的深度+1，就是当前树的深度 思路二 把二叉树","title":"LeetCode 104"},{"content":"思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可\n第二题 考察差分数组和异或的性质\n由a^b=c \u0026mdash;\u0026gt; a^a^b=a^c \u0026mdash;\u0026gt; 0^b=a^c \u0026mdash;\u0026gt; b=a^c，因为相同的数异或为0，任何数异或0都不变\n给你的数组相当于是前缀和数组，前缀和数组的差分既是原数组，知道了异或的结果，求异或前的值，用上述推断，然后遍历数组逐个异或即可\n第三题 考察贪心和栈\n哪里贪心了？答：因为题目要求给出字典序最小的字符串，也就是需要尽量把最小的字母放在前面，那么可以比较栈顶和没入栈的那些字母，看下没入栈的那些字母是否有比栈顶小的字母，如果没有，那直接出栈，如果有，那就入栈直到遇到最小的字符串，这样贪心，最后的结果一定是字典序最小的字符串。\n第四题 考察动态规划\n非常典型的动态规划，唯一要注意的就是动态规划数组里的元素不能是所有路径长度的list，因为逐个遍历list的元素会超时，需要使用map，key为路径长度，value为长度为key的路径的个数，还需要注意value有可能很大，需要取余1000000007，key有可能很多，所以需要取余k，因为最终只需要长度能整除k的路径个数，而不需要具体的路径长度。\n总结 本次周赛难度偏低，但是我刷题太少，做起来不熟练，需要多练习多总结。\n代码 第一题 class Solution { public int hardestWorker(int n, int[][] logs) { int[] time = new int[logs.length]; int id = logs[0][0], maxTime = logs[0][1]; time[0] = logs[0][1]; for (int i = 1; i \u0026lt; time.length; i++) { time[i] = logs[i][1] - logs[i - 1][1]; if (time[i] \u0026gt; maxTime || time[i] == maxTime \u0026amp;\u0026amp; id \u0026gt; logs[i][0]) { maxTime = time[i]; id = logs[i][0]; } } return id; } } 第二题 class Solution { public int[] findArray(int[] pref) { for (int i = pref.length - 1; i \u0026gt; 0; i--) { pref[i] = pref[i] ^ pref[i - 1]; } return pref; } } 第三题 class Solution { private boolean hasSmaller(int[] count, int i) { for (int j = 0; j \u0026lt; i; j++) { if (count[j] != 0) { return true; } } return false; } public String robotWithString(String s) { int[] count = new int[26]; for (int i = 0; i \u0026lt; s.length(); i++) { count[s.charAt(i) - \u0026#39;a\u0026#39;]++; } StringBuilder ans = new StringBuilder(); Deque\u0026lt;Character\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push((char) (\u0026#39;z\u0026#39; + 1)); int index = 0; while (ans.length() != s.length()) { Character peek = stack.peek(); if (hasSmaller(count, peek - \u0026#39;a\u0026#39;)) { stack.push(s.charAt(index)); count[s.charAt(index) - \u0026#39;a\u0026#39;]--; index++; } else { ans.append(peek); stack.pop(); } } return ans.toString(); } } 第四题 class Solution { public int numberOfPaths(int[][] grid, int k) { Map\u0026lt;Integer, Integer\u0026gt;[] path = new HashMap[grid[0].length]; path[0] = new HashMap\u0026lt;\u0026gt;(); path[0].put(grid[0][0] % k, 1); for (int i = 1; i \u0026lt; grid[0].length; i++) { path[i] = new HashMap\u0026lt;\u0026gt;(); for (Integer integer : path[i - 1].keySet()) { path[i].put((integer + grid[0][i]) % k, 1); } } for (int i = 1; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++) { HashMap\u0026lt;Integer, Integer\u0026gt; temp = new HashMap\u0026lt;\u0026gt;(path[j]); path[j].clear(); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : temp.entrySet()) { path[j].put((entry.getKey() + grid[i][j]) % k, entry.getValue()); } if (j != 0) { for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : path[j - 1].entrySet()) { int newKey = (entry.getKey() + grid[i][j]) % k; path[j].put(newKey, (path[j].getOrDefault(newKey, 0) + entry.getValue()) % 1000000007); } } } } return path[path.length - 1].getOrDefault(0, 0); } } References 1. 处理用时最长的那个任务的员工 2. 找出前缀异或的原始数组 3. 使用机器人打印字典序最小的字符串 4. 矩阵中和能被 K 整除的路径 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-314/","summary":"思路 第一题 考察差分数组和模拟，差分之后数组的每个元素就是该任务所用的时间，找最大的即可 第二题 考察差分数组和异或的性质 由a^b=c \u0026mdash;\u0026gt; a^a^b=a^c \u0026mdash;\u0026gt; 0^b=a^c \u0026mdash;\u0026gt; b","title":"LeetCode 周赛 314"},{"content":"思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.length个格子里去，那么就可以把这些格子后面的不是黑名单的数字和前面黑名单的数字交换，这样就可以随机获取数字了\n又由于数组大部分元素的值和下标是一样的，所以可以省略数组，用map记录那些交换的元素\n代码 class Solution { int size; Set\u0026lt;Integer\u0026gt; blackSet = new HashSet\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; blackMap = new HashMap\u0026lt;\u0026gt;(); public Solution(int n, int[] blacklist) { size = n - blacklist.length; for (int num : blacklist) { if (num \u0026gt;= size) { blackSet.add(num); } } int last = n - 1; for (int num : blacklist) { if (num \u0026lt; size) { while (blackSet.contains(last)) { last--; } blackMap.put(num, last); last--; } } } public int pick() { int random = new Random().nextInt(size); if (blackMap.containsKey(random)) { return blackMap.get(random); } return random; } } References 1. 黑名单中的随机数 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-710/","summary":"思路 既然要随机获取，那么肯定要用数组存，并且是紧凑的，由于有黑名单，所以我们应该想办法把不是黑名单的数组紧凑到前n - blacklist.le","title":"LeetCode 710"},{"content":"思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组\n代码 class RandomizedSet { private List\u0026lt;Integer\u0026gt; nums; private Map\u0026lt;Integer, Integer\u0026gt; valToIndex; public RandomizedSet() { nums = new ArrayList\u0026lt;\u0026gt;(); valToIndex = new HashMap\u0026lt;\u0026gt;(); } public boolean insert(int val) { if (valToIndex.containsKey(val)) { return false; } valToIndex.put(val, nums.size()); nums.add(val); return true; } public boolean remove(int val) { if (!valToIndex.containsKey(val)) { return false; } int index = valToIndex.get(val); int lastNum = nums.get(nums.size() - 1); valToIndex.put(lastNum, index); valToIndex.remove(val); nums.set(index, lastNum); nums.remove(nums.size() - 1); return true; } public int getRandom() { return nums.get(new Random().nextInt(nums.size())); } } References 1. O(1) 时间插入、删除和获取随机元素 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-380/","summary":"思路 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索","title":"LeetCode 380"},{"content":"思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍\n有两个需要注意的地方：\n”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了 寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见LeetCode-note的思想章节二分查找注意点第10条 代码 class Solution { int[] preSum; public Solution(int[] w) { preSum = new int[w.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + w[i - 1]; } } public int pickIndex() { int random = new Random().nextInt(preSum[preSum.length - 1]) + 1; // 二分法寻找random所在的索引 int left = 0, right = preSum.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (random \u0026lt;= preSum[mid]) { right = mid; } else { left = mid + 1; } } return left - 1; } } References 1. 按权重随机选择 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-528/","summary":"思路 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值","title":"LeetCode 528"},{"content":"思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/\n代码 class Solution { public int[][] generateMatrix(int n) { int upperBound = 0, lowerBound = n - 1; int leftBound = 0, rightBound = n - 1; int[][] matrix = new int[n][n]; int num = 1; while (num \u0026lt;= n * n){ if (upperBound \u0026lt;= lowerBound) { for (int i = leftBound; i \u0026lt;= rightBound; i++) { matrix[upperBound][i] = num; num++; } upperBound++; } if (leftBound \u0026lt;= rightBound) { for (int i = upperBound; i \u0026lt;= lowerBound; i++) { matrix[i][rightBound] = num; num++; } rightBound--; } if (upperBound \u0026lt;= lowerBound) { for (int i = rightBound; i \u0026gt;= leftBound; i--) { matrix[lowerBound][i] = num; num++; } lowerBound--; } if (leftBound \u0026lt;= rightBound) { for (int i = lowerBound; i \u0026gt;= upperBound; i--) { matrix[i][leftBound] = num; num++; } leftBound++; } } return matrix; } } References 1. 螺旋矩阵 II ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-59/","summary":"思路 同LeetCode-54，只不过这里是往里填元素，详见：https://blog.zhangmengyang.tk/posts/leet","title":"LeetCode 59"},{"content":"思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：\n需要注意水平遍历需要判断upperBound\u0026lt;=lowerBound，垂直遍历需要判断leftBound\u0026lt;=rightBound\n代码 class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { int row = matrix.length, col = matrix[0].length; int upperBound = 0, lowerBound = row - 1; int leftBound = 0, rightBound = col - 1; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (ans.size() \u0026lt; row * col) { if (upperBound \u0026lt;= lowerBound) { for (int i = leftBound; i \u0026lt;= rightBound; i++) { ans.add(matrix[upperBound][i]); } upperBound++; } if (leftBound \u0026lt;= rightBound) { for (int i = upperBound; i \u0026lt;= lowerBound; i++) { ans.add(matrix[i][rightBound]); } rightBound--; } if (upperBound \u0026lt;= lowerBound) { for (int i = rightBound; i \u0026gt;= leftBound; i--) { ans.add(matrix[lowerBound][i]); } lowerBound--; } if (leftBound \u0026lt;= rightBound) { for (int i = lowerBound; i \u0026gt;= upperBound; i--) { ans.add(matrix[i][leftBound]); } leftBound++; } } return ans; } } References 1. 螺旋矩阵 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/","summary":"思路 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界： 需要注意水平遍历需要判断upperBound\u0026lt","title":"LeetCode 54"},{"content":"思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可\n为什么这样做？因为旋转90°相当于把行变成列，而对折矩阵刚好可以把行变成列，但是位置不对，那再反转一下就行了\n代码 class Solution { public void rotate(int[][] matrix) { for (int i = 0; i \u0026lt; matrix.length; i++) { // 注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，相当于对折了两次，所以这里要写j = i + 1 for (int j = i + 1; j \u0026lt; matrix[0].length; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } for (int i = 0; i \u0026lt; matrix.length; i++) { reverse(matrix[i]); } } private void reverse(int[] s) { int left = 0, right = s.length - 1; while (left \u0026lt; right) { int temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 旋转图像 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-48/","summary":"思路 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的","title":"LeetCode 48"},{"content":"思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再reverse各个单词，但要注意一下细节，比如去空格什么的\n代码 class Solution { private void reverse(char[] s, int i, int j) { int left = i, right = j - 1; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } private void translate(char[] s, int i, int j, int step) { for (int k = i; k \u0026lt; j; k++) { s[k - step] = s[k]; } for (int k = j - step; k \u0026lt; j; k++) { s[k] = \u0026#39; \u0026#39;; } } public String reverseWords(String s) { char[] cs = s.toCharArray(); reverse(cs, 0, cs.length); int left = -1, step = 0; for (int i = 0; i \u0026lt; cs.length; i++) { if (cs[i] == \u0026#39; \u0026#39;) { if (left != -1) { reverse(cs, left, i); translate(cs, left, i, step); left = -1; } else { step++; } } else { if (left == -1) { left = i; } } } if (left != -1) { reverse(cs, left, cs.length); translate(cs, left, cs.length, step); } return new String(cs).trim(); } } References 1. 反转字符串中的单词 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-151/","summary":"思路 可以split成单词，再reverse，再拼接，但是不够优雅，会使用了额外的空间，正确做法是先reverse整个数组，然后再revers","title":"LeetCode 151"},{"content":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算\n代码 class Solution { public boolean carPooling(int[][] trips, int capacity) { int len = 0; for (int[] trip : trips) { len = len \u0026gt; trip[2] ? len : trip[2]; } int[] nums = new int[len]; Difference df = new Difference(nums); for (int[] trip : trips) { df.increment(trip[1], trip[2] - 1, trip[0]); } for (int num : df.result()) { if (num \u0026gt; capacity) { return false; } } return true; } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 拼车 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1094/","summary":"思路 利用差分数组的思想即可，这里把路程中各个地方的乘客数目当作数组的元素，每个trip相当于对这个数组的某一段进行加运算 代码 class Solution { public boolean carPooling(int[][] trips, int","title":"LeetCode 1094"},{"content":"思路 标准差分数组，详见LeetCode-note\n代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } References 1. 航班预订统计 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1109/","summary":"思路 标准差分数组，详见LeetCode-note 代码 class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; Difference df = new Difference(nums); for (int[] booking : bookings) { df.increment(booking[0] - 1, booking[1] - 1, booking[2]); } return df.result(); } static class Difference { private int[] diff;","title":"LeetCode 1109"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n代码 class NumMatrix { int[][] preSum; public NumMatrix(int[][] matrix) { preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { for (int j = 1; j \u0026lt; preSum[0].length; j++) { preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } public int sumRegion(int row1, int col1, int row2, int col2) { return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]; } } References 1. 二维区域和检索 - 矩阵不可变 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位 还需要","title":"LeetCode 304"},{"content":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位\n代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } References 1. 区域和检索 - 数组不可变 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-303/","summary":"思路 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的是nums前n个元素的和，整体往后挪一位 代码 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum =","title":"LeetCode 303"},{"content":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找出窗口最大时的长度就可以了\n代码 class Solution { public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0, ans = 0; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) \u0026gt; 1) { char d = s.charAt(left); left++; window.put(d, window.get(d) - 1); } ans = Integer.max(ans, right - left); } return ans; } } References 1. 无重复字符的最长子串 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-3/","summary":"思路 利用滑动窗口的思想，如果窗口内相同元素超过1个，那么就开始收缩直到相同元素被移出，此时窗口内必定没有重复元素，记录一下此时的窗口大小，找","title":"LeetCode 3"},{"content":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/\n代码 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; p.length(); i++) { char c = p.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == p.length()) { ans.add(left); char d = s.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } } return ans; } } 另一种思路 vector\u0026lt;int\u0026gt; findAnagrams(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; vector\u0026lt;int\u0026gt; res; // 记录结果 while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 当窗口符合条件时，把起始索引加入 res if (valid == need.size()) res.push_back(left); char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } return res; } References 1. 找到字符串中所有字母异位词 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-438/","summary":"思路 同LeetCode-567，只不过找到子串后不直接返回而是存一下，同样是两种思路，详见：https://blog.zhangmengya","title":"LeetCode 438"},{"content":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法的字符，当窗口的长度和s1的长度一样时，就找到了这个子串\nlabuladong的思路：利用滑动窗口的思想，始终保持窗口大小为s1.size()-1，每次移入窗口一个元素，检查一下是否找到子串，如果没有，再让一个元素移出窗口，直到找到这个子串\n代码 class Solution { public boolean checkInclusion(String s1, String s2) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s1.length(); i++) { char c = s1.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, len = 0; while (right \u0026lt; s2.length()) { char c = s2.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); len++; while (window.get(c) \u0026gt; need.getOrDefault(c, 0)) { char d = s2.charAt(left); left++; len--; window.put(d, window.get(d) - 1); } if (len == s1.length()) { return true; } } return false; } } 另一种思路 // 判断 s 中是否存在 t 的排列 bool checkInclusion(string t, string s) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) valid++; } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 在这里判断是否找到了合法的子串 if (valid == need.size()) return true; char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } // 未找到符合条件的子串 return false; } References 1. 字符串的排列 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/","summary":"思路 我的思路：利用滑动窗口的思想，移入窗口一个字符，就收缩窗口直到这个移入的字符在窗口里的数目与s1保持一致，换句话说，保证窗口内不存在非法","title":"LeetCode 567"},{"content":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节\n代码 class Solution { public String minWindow(String s, String t) { Map\u0026lt;Character, Integer\u0026gt; need = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; t.length(); i++) { char c = t.charAt(i); need.put(c, need.getOrDefault(c, 0) + 1); } int left = 0, right = 0, valid = 0, begin = 0, end = Integer.MAX_VALUE; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素 // 所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (need.containsKey(c)) { window.put(c, window.getOrDefault(c, 0) + 1); if (window.get(c).equals(need.get(c))) { valid++; } } while (valid == need.size()) { if (end - begin \u0026gt; right - left) { begin = left; end = right; } c = s.charAt(left); left++; if (need.containsKey(c)) { if (window.get(c).equals(need.get(c))) { valid--; } window.put(c, window.get(c) - 1); } } } return end == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(begin, end); } } References 1. 最小覆盖子串 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-76/","summary":"思路 利用滑动窗口的思想，窗口内包含t的所有字符后收缩窗口，同时维护最小覆盖子串的两端的位置，详见LeetCode-note思想章节 代码 class Solution {","title":"LeetCode 76"},{"content":"思路 第一题 排序，不解释\n第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了\n第三题 暴力会超时，利用动态规划的思想，从左往右遍历一遍找各元素左边递减的元素个数，从右往左遍历一遍找各元素右边递增的元素个数，然后和k比较就可以了\n代码 第一题 class Solution { public String[] sortPeople(String[] names, int[] heights) { People[] peoples = new People[names.length]; for(int i = 0; i \u0026lt; peoples.length; i++) { peoples[i] = new People(names[i], heights[i]); } Arrays.sort(peoples, (a, b) -\u0026gt; b.height - a.height); for (int i = 0; i \u0026lt; peoples.length; i++) { names[i] = peoples[i].name; } return names; } static class People { String name; int height; public People(String name, int height) { this.name = name; this.height = height; } } } 第二题 class Solution { public int longestSubarray(int[] nums) { int max = Integer.MIN_VALUE, ans = 0, count = 0; for (int num : nums) { if (num != max) { count = 0; if (num \u0026gt; max) { max = num; ans = 0; } } if (num == max) { count++; } if (count \u0026gt; ans) { ans = count; } } return ans; } } 第三题 动态规划：\nclass Solution { public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { int[] decre = new int[nums.length]; decre[0] = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026lt;= nums[i - 1]) { decre[i] = decre[i - 1] + 1; } else { decre[i] = 1; } } int[] incre = new int[nums.length]; incre[nums.length - 1] = 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { if (nums[i] \u0026lt;= nums[i + 1]) { incre[i] = incre[i + 1] + 1; } else { incre[i] = 1; } } ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (decre[i - 1] \u0026gt;= k \u0026amp;\u0026amp; incre[i+1] \u0026gt;= k) { ans.add(i); } } return ans; } } 暴力解法：\nclass Solution { private boolean isGoodIndex(int[] nums, int index, int k) { for (int i = index - 1; i \u0026gt; index - k; i--) { if (nums[i] \u0026gt; nums[i - 1]) { return false; } } for (int i = index + 1; i \u0026lt; index + k; i++) { if (nums[i] \u0026gt; nums[i + 1]) { return false; } } return true; } public List\u0026lt;Integer\u0026gt; goodIndices(int[] nums, int k) { ArrayList\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int i = k; i \u0026lt; nums.length - k; i++) { if (isGoodIndex(nums, i, k)) { ans.add(i); } } return ans; } } References 1. 按身高排序 2. 按位与最大的最长子数组 3. 找到所有好下标 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-%E5%91%A8%E8%B5%9B-312/","summary":"思路 第一题 排序，不解释 第二题 按位与只会越与越小，那既然要找最大的结果，那遍历一遍数组统计一下最大的数出现了几次就可以了 第三题 暴力会超时，利用","title":"LeetCode 周赛-312"},{"content":"思路 进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，分别查找左边界或右边界即可，详见LeetCode-note\n代码 class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (target \u0026gt; nums[mid]) { left = mid + 1; } else { right = mid; } } if (nums[left] != target) { return new int[]{-1, -1}; } int[] ans = new int[2]; ans[0] = left; left = 0; right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if (target \u0026lt; nums[mid]) { right = mid - 1; } else { left = mid; } } ans[1] = left; return ans; } } References 1. 在排序数组中查找元素的第一个和最后一个位置 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-34/","summary":"思路 进阶版二分查找，寻找target的左右边界，在进阶版二分查找的二分阶段根据左边界或右边界的特征，选择合适的二分条件即可，来两次二分查找，","title":"LeetCode 34"},{"content":"思路 经典二分查找，不解释\n详见：https://labuladong.gitee.io/algo/2/20/29/\n代码 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } } References 1. 二分查找 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-704/","summary":"思路 经典二分查找，不解释 详见：https://labuladong.gitee.io/algo/2/20/29/ 代码 class Solution { public int search(int[] nums, int target) { int left","title":"LeetCode 704"},{"content":"思路 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n代码 class Solution { public String longestPalindrome(String s) { String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { // 从中心向两边寻找回文串 String s1 = findPalindrome(s, i, i); String s2 = findPalindrome(s, i, i + 1); res = res.length() \u0026gt;= s1.length() ? res : s1; res = res.length() \u0026gt;= s2.length() ? res : s2; } return res; } private String findPalindrome(String s, int left, int right) { while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(left) == s.charAt(right)) { left--; right++; } return s.substring(left + 1, right); } } References 1. 最长回文子串 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-5/","summary":"思路 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。 代码 class Solution { public String longestPalindrome(String s) { String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.length(); i++) { // 从中心向两边寻找回文串 String","title":"LeetCode 5"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1. 反转字符串 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-344/","summary":"思路 利用左右指针的思想，从两边向中间逼近，同时交换左右的值 代码 class Solution { public void reverseString(char[] s) { int left = 0, right = s.length -1 ; while (left \u0026lt; right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } References 1.","title":"LeetCode 344"},{"content":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n代码 class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; while (left \u0026lt; right) { int sum = numbers[left] + numbers[right]; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { return new int[]{left + 1, right + 1}; } } return new int[]{0, 0}; } } References 1. 两数之和 II - 输入有序数组 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-167/","summary":"思路 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。 代","title":"LeetCode 167"},{"content":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题）\n26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n83 同26，只不过是链表，要注意去重后要把slow后面的链表断开，否则slow后面可能会有和slow重复的。\n27 同26，只不过不是比较slow和fast的元素，而是让fast和确定的值比较。\n283 同27，只不过得把slow后面的改成0。\n代码 26 class Solution { public int removeDuplicates(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow + 1; } } 83 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { slow.next = fast; slow = slow.next; } fast = fast.next; } slow.next = null; return head; } } 27 class Solution { public int removeElement(int[] nums, int val) { if (nums.length == 0) { return 0; } int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } 283 class Solution { public void moveZeroes(int[] nums) { int slow = 0, fast = 0; while (fast \u0026lt; nums.length) { if (nums[fast] != 0) { nums[slow] = nums[fast]; slow++; } fast++; } while (slow \u0026lt; nums.length) { nums[slow] = 0; slow++; } } } References 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-26+83+27+283/","summary":"思路 都属于快慢指针里的原地修改数组问题（数组元素去重问题） 26 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的","title":"LeetCode 26+83+27+283"},{"content":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找中点 ListNode slow = head, fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } // 如果是奇数个节点，slow需要后移一位 if (fast != null) { slow = slow.next; } // 反转slow之后的 ListNode right = reverse(slow), left = head; // 判断回文 while (right != null) { if (left.val != right.val) { return false; } left = left.next; right = right.next; } return true; } private ListNode reverse(ListNode head) { ListNode pre = null, cur = head; while (cur != null) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88+%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"思路 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。 代码 class Solution { public boolean isPalindrome(ListNode head) { // 快慢指针找","title":"LeetCode 234 快慢指针+反转链表"},{"content":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private boolean traverse(ListNode right) { if (right == null) { return true; } boolean res = traverse(right.next); res = res \u0026amp;\u0026amp; (left.val == right.val); left = left.next; return res; } } References 1. 回文链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-%E9%93%BE%E8%A1%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"思路 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。 代码 class Solution { private ListNode left; public boolean isPalindrome(ListNode head) { left = head; return traverse(head); } private","title":"LeetCode 234 链表后序遍历"},{"content":"思路 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n代码 class Solution { private ListNode reverse(ListNode a, ListNode b) { // 这个做法需要对第一个节点特殊判断 // if (head == null) { // return null; // } // // ListNode pre = head, cur = head.next; // head.next = null; // while (cur != null) { // ListNode temp = cur.next; // cur.next = pre; // cur = temp; // } // // return pre; // 这个做法不需要对第一个节点特殊判断 ListNode pre = null, cur = a; while (cur != b) { ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } public ListNode reverseKGroup(ListNode head, int k) { ListNode p = head; // 找出前k个节点，不满k个直接return for (int i = 0; i \u0026lt; k; i++) { if (p == null) { return head; } p = p.next; } // 反转前k个 ListNode newHead = reverse(head, p); // 拼接后面反转后的链表 head.next = reverseKGroup(p, k); return newHead; } } References 1. K 个一组翻转链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-25/","summary":"思路 1、先反转以 head 开头的 k 个元素。 2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。 3、将上述两个过程的结果连接起来。 注意base case为最后元素","title":"LeetCode 25"},{"content":"思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n代码 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } public ListNode reverseBetween(ListNode head, int left, int right) { if (left == 1) { return reverseN(head, right); } head.next = reverseBetween(head.next, left - 1, right - 1); return head; } } References 1. 反转链表 II ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-92/","summary":"思路 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right","title":"LeetCode 92"},{"content":"思路 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n代码 class Solution { private ListNode succesor = null;\t// 后驱节点 public ListNode reverseN(ListNode head, int n) { // 递归出口 if (n == 1) { succesor = head.next; return head; } ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = succesor; return last; } } ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA%E8%8A%82%E7%82%B9/","summary":"思路 解决思路和反转整个链表差不多，只要稍加修改即可： 1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。 2、刚才我们直接","title":"反转链表前n个节点"},{"content":"思路 利用递归的思想，先反转head后面的，然后把head也反转即可。\n代码 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } } References 1. 反转链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-206/","summary":"思路 利用递归的思想，先反转head后面的，然后把head也反转即可。 代码 class Solution { public ListNode reverseList(ListNode head) { // 递归出口 if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next =","title":"LeetCode 206"},{"content":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n分析过程 难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：\n如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n转载于： https://labuladong.gitee.io/algo/2/19/18/\n代码 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headB; while (p1 != p2) { if (p1 == null) { p1 = headB; } else { p1 = p1.next; } if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } } References 1. 相交链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-160/","summary":"思路 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等","title":"LeetCode 160"},{"content":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n分析过程 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：\nfast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。\n假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。\n巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：\n所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。\n转载于：https://labuladong.gitee.io/algo/2/19/18/\n代码 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; // 寻找相遇点 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (slow == fast) { break; } } if (fast == null || fast.next == null) { return null; } // 再次相遇即为环起始点 fast = head; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } References 1. 环形链表 II ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-142/","summary":"思路 寻找环的起点，利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次","title":"LeetCode 142"},{"content":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表有环 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } } References 1. 环形链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-141/","summary":"思路 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环 代码 public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; // 快慢指针如果相遇，说明链表","title":"LeetCode 141"},{"content":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n代码 class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; // 经典快慢指针 while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } } References 1. 链表的中间结点 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-876/","summary":"思路 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 需要注意的是，如果链表","title":"LeetCode 876"},{"content":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n代码 class Solution { private ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // 先让p1指针走n步 for (int i = 0; i \u0026lt; n; i++) { p1 = p1.next; } ListNode p2 = head; // p1指针走到头，p2指针指向的就是需要找的节点 while (p1 != null) { p1 = p1.next; p2 = p2.next; } return p2; } public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; // 找到倒数第n+1个节点 ListNode node = findFromEnd(dummy, n + 1); node.next = node.next.next; return dummy.next; } } References 1. 删除链表的倒数第 N 个结点 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-19/","summary":"思路 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让p1指针走n步，然后p1和p2指针一起动，当p1指针到头了的时候，p2指针指","title":"LeetCode 19"},{"content":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n代码 class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } // 创建优先队列，将头节点加入 ListNode dummy = new ListNode(-1), p = dummy; PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(lists.length, (a, b) -\u0026gt; { return a.val - b.val; }); for (ListNode head : lists) { if (head != null) { pq.add(head); } } // 每次取出来一个最小的 while (!pq.isEmpty()) { ListNode node = pq.poll(); p.next = node; p = p.next; if (node.next != null) { pq.add(node.next); } } return dummy.next; } } References 1.合并K个升序链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-23/","summary":"思路 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。 代码 class Solution { public ListNode mergeKLists(ListNode[] lists) {","title":"LeetCode 23"},{"content":"链表 合并两个有序链表 解法 略\n题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-21/\n单链表的分解 解法 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n题目 1. 分隔链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-86/\n合并 k 个有序链表 解法 每次取出一个最小的加到链表中去，那问题就是怎么高效的获取最小的节点，这很明显用优先队列（二叉堆）就可以解决这个问题。\n题目 1. 合并K个升序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-23/\n寻找单链表的倒数第 k 个节点 解法 关键是找到倒数第n+1个节点，找到倒数第n个节点的做法：先让快指针走n步，然后快慢指针一起动，当快指针到头了的时候，慢指针指向的就是需要找的节点。\n注意使用dummy节点可以避免特殊性，比如就5个节点，删除倒数第5个，那需要找倒数第6个节点，可是总共就5个节点，会有空指针。\n题目 1. 删除链表的倒数第 N 个结点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-19/\n单链表的中点 解法 利用快慢指针的思想，每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\n需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。\n题目 1. 链表的中间结点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-876/\n判断链表是否包含环 解法 利用快慢指针的思想，如果快指针为空，说明没有环，如果快慢指针相遇说明有环\n题目 1. 环形链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-141/\n存在环的链表中寻找环起点 解法 利用快慢指针的思想并且稍做分析，即可得出结论：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。\n题目 1. 环形链表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-142/\n判断两个链表是否相交 解法 找到相交点的关键是将相交点之前的节点数凑成相等的，这样的话同时遍历，如果相等的话就是相交了。怎么凑呢？将两个链表连接一下，节点数不就想等了吗。\n代码实现方面，可以考虑四种情况：\n长度相等，有相交 长度相等，无相交 长度不等，有相交 长度不等，无相交 符合这四种情况的链表连接方法如下：\nl1 -\u0026gt; null -\u0026gt; l2 -\u0026gt; null\nl2 -\u0026gt; null -\u0026gt; l1 -\u0026gt; null\n另一种做法：将某一条链表首尾相连，该问题就转换为寻找有环链表的环起点问题。\n题目 1. 相交链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-160/\n反转单链表 解法 利用递归的思想，先反转head后面的，然后把head也反转即可。\n思想 反转的过程就是改变指针方向的过程并且最后一个指向null，比如反转第2个\u0026mdash;第5个：\n1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null\n反转后为：\n1 -\u0026gt; 2 \u0026lt;- 3 \u0026lt;- 4 \u0026lt;- 5\n​ null\n题目 1. 反转链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-206/\n反转链表前n个节点 解法 解决思路和反转整个链表差不多，只要稍加修改即可：\n1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n2、刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。\n题目 无\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/反转链表前n个节点/\n反转链表节点(m, n) 解法 与反转链表前n个节点区别在于不是从第一个节点开始反转，而是从left开始，那么只需要利用递归一次head往后移一位，left和right分别减一的特性，把head移到left的位置，然后反转前n个节点即可。\n题目 1. 反转链表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-92/\nK 个一组翻转链表 解法 1、先反转以 head 开头的 k 个元素。\n2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。\n3、将上述两个过程的结果连接起来。\n注意base case为最后元素不足 k 个时的情况\n题目 1. K 个一组翻转链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-25/\n链表的前后序遍历 void traverse(ListNode head) { // 前序遍历代码 traverse(head.next); // 后序遍历代码 } 回文串 寻找回文串 核心思想是从中心向两端扩展\n判断回文串 核心思想是从两端向中间逼近\n判断回文链表 解法 可以将链表全部反转，也可以部分反转\n链表全部反转 链表全部反转的方法共3种：\n将原链表反转，然后与原链表比较 略\n链表后序遍历 链表也可以后序遍历，这道题只需要使用后序遍历，然后提前存一下head，从两边向中间逼近就可以了。\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-链表后序遍历/\n利用栈 同链表后序遍历\n链表部分反转 快慢指针+反转链表 先用快慢指针找到链表的中点，从而找到回文串的后一半，然后将后一半反转，然后判断前后两部分是否相等就行了。\n题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-234-快慢指针+反转链表/\n题目 1. 回文链表 数组 快慢指针在数组中的应用 数组元素去重 解法 慢指针指向当前已经去重的数据的最后一个，快指针去前面探路，碰到和slow不一样的数据就让这个数据放在slow后面，slow++。\n具体变种详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-26+83+27+283/\n题目 1. 删除有序数组中的重复项 2. 删除排序链表中的重复元素 3. 移除元素 4. 移动零 滑动窗口 解法 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n详见思想章节\n题目 1. 最小覆盖子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-76/\n2. 字符串的排列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-567/\n3. 找到字符串中所有字母异位词 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-438/\n4. 无重复字符的最长子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-3/\n左右指针在数组中的应用 二分查找 解法 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度，详见思想章节\n题目 1. 在排序数组中查找元素的第一个和最后一个位置 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-34/\n2. 二分查找 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-704/\n两数之和 解法 利用左右指针的思想，从两边向中间逼近，如果左右之和太大，那就right\u0026ndash;，否则left++，直到左右之和等于target。\n题目 1. 两数之和 II - 输入有序数组 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-167/\n反转数组 解法 利用左右指针的思想，从两边向中间逼近，同时交换左右的值\n扩展 反转字符数组里的单词 先反转整个数组，然后再反转各个单词即可\n旋转矩阵 先按对角线对折矩阵（注意对折矩阵时，只需要遍历矩阵的一半即可，如果整个矩阵都遍历，那矩阵不会有任何变化，相当于对折了两次），再反转矩阵的每一行即可\n题目 1. 反转字符串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-344/\n2. 反转字符串中的单词 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-151/\n3. 旋转图像 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-48/\n回文串判断 解法 遍历一遍数组，同时从中心向两边寻找回文串，并且保存最长的即可。\n题目 1. 最长回文子串 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-5/\n前缀和在数组里的应用 一维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第n + 1个元素存的时nums前n个元素的和，整体往后挪一位\n题目 1. 区域和检索 - 数组不可变 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-303/\n二维数组中的前缀和 解法 利用前缀和的思想轻松秒杀，需要注意在preSum中，第[n + 1, n+1]个元素存的是matrix前n*n个元素的和，整体往右下挪一位\n还需要注意做减法时，会多减一块区域，需要加回来\n题目 1. 二维区域和检索 - 矩阵不可变 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-304/\n差分数组 解法 详见思想章节\n题目 1. 航班预订统计 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1109/\n2. 拼车 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1094/\n矩阵的螺旋遍历 解法 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：\n需要注意水平遍历需要判断upperBound\u0026lt;=lowerBound，垂直遍历需要判断leftBound\u0026lt;=rightBound\n题目 1. 螺旋矩阵 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-54/\n2. 螺旋矩阵 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-59/\n带权重的随机选择算法 解法 可以想象成一条线段，分成好几段，每段长度不一样，然后往上面撒石子，返回石子撒到了第几条线段上，直接把这个线段当成一个数组不现实，因为数值有可能很大，所以可以压缩一下，把每一段的长度当成一个元素，但这样寻找随机数处在哪一段还得把前面都加起来，不方便，那就压缩成一个前缀和数组，这样只需要从左往右遍历前缀和数组找第一个大于等于随机数的元素就行了，但是前缀和数组是一个有序数组，我们寻找第一个大于等于随机数的元素使用二分查找就可以快速定位，不需要从头遍历一遍\n有两个需要注意的地方：\n”线段“和前缀和的”格子“的对应关系需要想清楚，这个画张图就明白了 寻找第一个大于等于随机数的元素，需要用寻找左边界的二分查找，而不是寻找右边界的二分查找，详见思想章节二分查找注意点第10条 题目 1. 按权重随机选择 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-528/\n常数时间删除/查找数组中的任意元素 解法 为了随机选取元素，需要用到数组，并且得是紧凑的，但是数组增删不是O(1)的，所以再来个map，key是数组元素的值，value是数组的索引，这样就做到了O(1)的数组增删，增删的时候注意修改map和数组\n核心思想就是为了随机选取元素，肯定得用数组存，并且得是紧凑的\n题目 1. O(1) 时间插入、删除和获取随机元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-380/\n2. 黑名单中的随机数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-710/\n二叉树 遍历问题 解法 利用前中后序遍历模板（见思想），用一个 traverse 函数配合外部变量来实现。\n搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n题目 1. 二叉树的最大深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/\n2. 二叉树的前序遍历 题解略\n3. 翻转二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/\n4. 填充每个节点的下一个右侧节点指针 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/\n分解问题 解法 主要思想就是定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案\n首先写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)。\n搞清楚二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n题目 1. 二叉树的最大深度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-104/\n2. 二叉树的直径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-543/\n3. 翻转二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-226/\n4. 二叉树展开为链表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-114/\n层序遍历 解法 就是一个BFS，可以计算一些类似结点与root之间的距离的问题。详见思想里的模板\n题目 1. 填充每个节点的下一个右侧节点指针 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-116/\n构造二叉树 解法 二叉树的构造问题一般都是使用「分解问题」的思想：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。\n题目 1. 最大二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-654/\n2. 从前序和中序遍历序列构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-105/\n3. 从后序和中序遍历序列构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-106/\n4. 根据前序和后序遍历构造二叉树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-889/\n二叉搜索树性质 解法 只需要利用二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列就可以了\n题目 1. 二叉搜索树中第 K 小的元素 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-230/\n2. 把二叉搜索树转换为累加树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-538/\n二叉搜索树合法性 解法 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去\n题目 1. 验证二叉搜索树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-98/\n二叉搜索树增删改查 解法 见思想\n题目 1. 二叉搜索树中的搜索 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-700/\n2. 二叉搜索树中的插入操作 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-701/\n3. 删除二叉搜索树中的节点 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-504/\nn个结点的BST的种类 解法 递归思路 递归函数定义为n个结点可以组成几种BST，那么对于n个结点的BST的种类=将n个结点逐个当成root，左右子树的种类相乘，再把这些结果相加就是n个结点BST的种类\n动态规划 递归明显有重复计算的问题，我们可以对已经计算好的数据进行存储，需要时就不需要重新计算了，这种重复利用子问题的解的方式就是动态规划\n题目 1. 不同的二叉搜索树 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-96/\n2. 不同的二叉搜索树 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-95/\n扁平化嵌套列表迭代器 解法 思路一 将NestedInteger当成树的节点，list当成该节点的孩子，那么只需要遍历该树就可以完成迭代了，直接看代码\n思路二 思路一会在构造的时候将此树遍历一遍，所以速度会很慢，最好弄成懒惰式的，所以可以把NestedInteger当成一个队列，循环把第一个元素展开，直到第一个元素为数字为止，这样就可以完成迭代\n题目 1. 扁平化嵌套列表迭代器 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-341/\n最近公共祖先 解法 主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA\n题目 1. 二叉树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/\n2. 二叉搜索树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/\n最近公共祖先 解法 主要思想就是遍历二叉树，同时查找左子树和右子树是否分别含有一个节点，如果是，那么这个结点就是LCA\n题目 1. 二叉树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-236/\n2. 二叉搜索树的最近公共祖先 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-235/\n完全二叉树的结点个数 解法 普通二叉树需要对二叉树进行遍历才能统计结点个数，满二叉树只需要知道树的高度就可以计算出来，那么完全二叉树可以结合这两个的做法，如果左边和右边高度相同，就用满二叉树的计算方式，如果不同那就遍历二叉树，同时判断该节点为root的树是不是满二叉树\n这种做法时间复杂度是O(logn*logn)，详见：https://labuladong.gitee.io/algo/2/21/48/\n题目 1. 完全二叉树的节点个数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-222/\n图 图的遍历 解法 直接套模板，详见思想章节\n题目 1. 所有可能的路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-797/\n环检测 解法 思路一 利用图的DFS，首先构建图，把prerequisites当成图的边，然后利用图的DFS遍历模板遍历该图，同时记录路径里的结点，如果路径里的结点重复就是有环，记录结果并返回\n思路二 利用图的BFS，首先构建图，把prerequisites当成图的边，注意BFS时，只能让入度为零的结点入队列，出队相当于访问该节点，环里的结点不会入队列，最后判断访问过的结点个数是否等于总结点个数即可\n题目 1. 课程表 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-207/\n拓扑排序 解法 思路一 利用图的DFS，只要是无环的有向图，就有拓扑排序，所以需要像207题一样判断是否有环，如果无环，那么只需要反转该图的后序遍历序列就得到了该图的拓扑排序\n思路二 利用图的BFS，只不过只把入度为零的结点加入队列，出队相当于访问该节点，队列出队的序列就是该图的拓扑排序\n题目 1. 课程表 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-210/\n二分图的判断 解法 利用二分图判断模板即可，有dfs和bfs两种做法，详见思想章节\n题目 1. 判断二分图 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-785/\n2. 可能的二分法 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-886/\n并查集 解法 利用并查集模板即可，详见思想章节\n题目 1. 被围绕的区域 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-130/\n2. 等式方程的可满足性 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-990/\ndijkstra问题 解法 利用dijkstra模板即可，注意dijkstra的变种需要修改adj和weight函数，详见思想章节\n题目 1. 网络延迟时间 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-743/\n2. 最小体力消耗路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1631/\n3. 概率最大的路径 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1514/\nkruskal问题 解法 利用kruskal算法即可，详见思想章节\n题目 1. 连接所有点的最小费用 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/\nprim问题 解法 利用prim算法即可，详见思想章节\n题目 1. 连接所有点的最小费用 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-1584/\n设计数据结构 LRU 解法 直接套LRU模板即可，详见思想篇章\n题目 1. LRU 缓存 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-146/\nLFU 解法 直接套LFU模板即可，详见思想篇章\n题目 1. LFU 缓存 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-460/\nTrieMap和TrieSet 解法 直接套模板即可，详见思想篇章\n题目 1. 实现 Trie (前缀树) 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-208/\n2. 单词替换 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-648/\n3. 添加与搜索单词 - 数据结构设计 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-211/\n4. 键值映射 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-677/\n数据流的中位数 解法 用两个优先队列（最大/小堆），等量的将数据流分成两部分，最大堆放小的那一部分，最小堆放大的那一部分，中位数就是堆顶的元素平均数，详见：https://mp.weixin.qq.com/s/oklQN_xjYy--_fbFkd9wMg\n题目 1. 数据流的中位数 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-295/\n单调栈问题 下一个更大元素 解法 利用单调栈的思想即可，倒着入栈，碰到栈顶比自己小就出栈直到比自己大，那么这么就把两个较大元素中间的小元素去除掉了，剩下的两个元素就可以充当下一个更大元素的角色（中间去除的元素是无法充当这种角色的），那么此时栈顶就是当前元素下一个更大元素\n题目 1. 下一个更大元素 I 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-496/\n2. 每日温度 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-739/\n3. 下一个更大元素 II 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-503/\n单调队列问题 滑动窗口最大值 解法 利用单调队列的思想即可，保持队列中为单调递减那么队头就是最大值，入栈时把小于两头的元素全部出队（因为这些元素不可能充当窗口内最大值的角色），详见思想篇章\n题目 1. 滑动窗口最大值 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-239/\n用栈实现队列 解法 直接套栈实现队列模板即可，详见思想篇章\n题目 1. 用栈实现队列 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-232/\n用队列实现栈 解法 直接套用队列实现栈的模板即可，详见思想篇章\n题目 1. 用队列实现栈 题解详见：https://blog.zhangmengyang.tk/posts/leetcode/leetcode-225/\n思想 双指针 就是两个指针，分为左右指针和快慢指针，只要数组有序，就应该想到双指针技巧\n左右指针 两个指针一个左一个右\n二分查找 就是将搜索空间合理的分成两部分，摒弃不可能的那部分，缩减搜索空间，加快搜索速度\n经典思路 public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid -1; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } } return -1; } 这种就是一边缩减搜索空间，一边寻找要找的元素。\n但是有时候问题并不是这么简单，比如寻找一个可能在数组里不存在，或者是找边界这样的问题，这时使用进阶思路 ，在循环体内排除一定不存在目标元素的区间会更简单一些。\n经典思路是寻找元素\n进阶思路是排除n-1个不可能的元素\n进阶思路 class Solution { public int search(int[] nums, int target) { // 此思路搜索空间为[left, right]，闭闭空间 int left = 0, right = nums.length - 1; // 循环条件写成left\u0026lt;right，因为循环体内把数组分成两部分，那么一定会达到left和right重合的状态 // 所以循环条件写成left\u0026lt;right，可以保证退出循环时left等于right while (left \u0026lt; right) { // 求中点，left=mid+1时不需要向上取整 int mid = left + (right - left) / 2; // left=mid时需要向上取整，记忆方式：left和mid要有一个+1 // 这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left //int mid = left + (right - left + 1) / 2; // 下面是核心逻辑，分成两个区间是因为这样扩展性更强 // 这块主要就是筛选不可能的区间，然后缩减搜索空间，具体问题具体分析，注意left没加一时mid要加一 if (target \u0026gt; nums[mid]) { left = mid + 1; } else { right = mid; } /*if (target \u0026lt;= nums[mid]) { right = mid; } else { left = mid + 1; }*/ /*if (target \u0026lt; nums[mid]) { right = mid - 1; } else { left = mid; }*/ /*if (target \u0026gt;= nums[mid]) { left = mid; } else { right = mid -1; }*/ } // 此时left一定等于right，所以返回left或者right都一样 // 排除了n-1个不可能的元素，还剩下[left, right]区间的元素，而left=right，就看剩下这个是不是要寻找的元素了 // 如果该题一定存在指定的元素，那么下一步可以省略，直接return left就好了 if (nums[left] == target) { return left; } return -1; } } 步骤 left和right分别设置为搜索空间的左右端点，注意是闭区间 循环条件写成left\u0026lt;right 求中点，先写成int mid = left + (right - left) / 2; 根据具体问题将搜索空间分成两部分，其中一部分必须是不可能的区域，然后根据这个不可能区域的特征写出第一个if，然后else里写和if互补的区域就好了，注意如果结果是left=mid，上面求中点要改成int mid = left + (right - left + 1) / 2; 如果根据题意不能判断出一定存在寻找的元素，需要判断下nums[left]是不是寻找的元素，是则return left，否则未找到该元素；如果根据题意能判断出一定存在寻找的元素，那直接return left就好了 注意点 此思路搜索空间为[left, right]，闭闭空间 循环条件写成left\u0026lt;right，因为循环体内把数组分成两部分，并且根据left的取值选择mid是向上或向下取整，那么一定会达到left和right重合的状态（把所有情况都模拟一边就可以得出这个结论），所以循环条件写成left\u0026lt;right，可以保证退出循环时left等于right 求中点时，如果使用(left + right) / 2有可能相加溢出，为了防止溢出使用left + (right - left) / 2 求中点时，left=mid+1时不需要向下取整，left=mid时需要向上取整，记忆方式：left和mid要有一个+1。这么做的原因是：向下取整时，如果还剩下两个元素，刚好又走到left=mid这个分支，就死循环了，因为此时mid就等于left。right=mid时需要向下取整，原因同理 把搜索空间分成两个区间是因为这样扩展性更强 缩减搜索空间时，将搜索空间分成两部分需要注意分出不可能的区间，然后缩减搜索空间，具体问题具体分析，根据这个不可能区间的特征写出第一个if，然后else里写和if互补的区域 注意left没加一时mid要加一 退出循环后left和right相等，并且是唯一有希望的元素（只是有希望，有可能不是它，还要再判断一下，如果该题一定存在指定的元素，那么直接return left就好了） 对于寻找左右侧边界的二分查找，在缩减搜索空间时一定要考虑\u0026gt;=或\u0026lt;=的情况，因为这样才能使用找左或右侧这个性质，比如target \u0026lt;= nums[mid]，可以寻找左边界，因为这时左边界不可能在mid右边所以直接right=mid就可以找到左边界，右边界同理。为什么找到的是左边界，也可以这么理解：target \u0026lt;= nums[mid]-\u0026gt;right=mid，所以target \u0026gt; nums[mid]-\u0026gt;left=mid + 1，此时left左边全部都小于target，因为退出循环时如果能找到target，left指向的就是target，又因为left左边全部都小于target，所以此时left指向左边界。找右边界同理。 对于寻找左侧边界的二分查找，说是寻找该元素的左侧边界，实际上是寻找大于等于target的所有元素的左侧边界，同理，寻找右侧边界的二分查找实际上是寻找小于等于target的所有元素的右侧边界，也可以理解成左侧边界的左边都小于target，右侧边界的右边都大于target，并且左右边界不一定等于target 详见：leetcode笔记word版和https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/\n其他 见上面各知识点章节\n快慢指针 两个指针一个快一个慢\n滑动窗口 left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n模板 /* 滑动窗口算法模板 */ void slidingWindow(String s) { Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0; // 这里用\u0026lt;而不用\u0026lt;=不是说明使用的闭闭区间，而是right当前位置的元素是我们下一个要入窗口的元素，所以这里其实是闭开窗口 while (right \u0026lt; s.length()) { // 获取移入窗口的元素，并扩大窗口 char c = s.charAt(right); right++; // 进行扩大窗口时数据的一系列更新 ... // debug位置 // System.out.println(\u0026#34;left:\u0026#34; + left + \u0026#34;\\t\u0026#34; + \u0026#34;right:\u0026#34; + right); // 判断左侧窗口是否要收缩 while (window needs shrink) { // 获取移出窗口的元素，并收缩窗口 char d = s.charAt(left); left++; // 进行收缩窗口时数据的一系列更新，一般与上面扩大窗口时数据更新相反 ... } } } 步骤 设置存储窗口内元素的数据结构，并且设置循环while (right \u0026lt; s.length()) 扩大窗口，并更新相关的数据 判断是否需要收缩窗口，如需要，则收缩窗口，并更新相关的数据 退出循环后，返回相应的数据 注意点 此模板采用闭开区间，循环条件用\u0026lt;而不用\u0026lt;=是因为right当前位置的元素是我们下一个要入窗口的元素 收缩窗口和扩大窗口对数据的更新一般是相反的（更新顺序和加减等都是相反的） 详见：https://labuladong.gitee.io/algo/2/20/27/\n进阶 ==RABIN KARP 字符匹配算法==，详见：https://labuladong.gitee.io/algo/2/20/28/\n其他 见上面各知识点章节\n递归 一个问题 = 规模更小的同类问题 + 扩展成该问题要解决的问题\n这种情况就可以用递归，递归的关键是不要跳进递归，而是明确递归函数的定义\n递归由两部分组成：递归出口和递归公式\n注意递归需要递归出口（也就是base case）\n值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。\n前缀和与差分 前缀和数组的差分是原数组，差分数组的前缀和是原数组，两者互逆。\n前缀和 对于一个数组，求此数组[left, right]区域内的和时，不需要从left\u0026ndash;right逐个相加，直接right+1前的和减去left前的和即可，要想使用这种方式就得有一个前缀和数组，用来存该数组前k个的和。注意也可能是二维数组，稍作修改即可。\n主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。\n详见：https://labuladong.gitee.io/algo/2/20/24/\n标准模板 class NumArray { int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } 差分数组 差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减\n类似前缀和构造的 preSum 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差，通过这个 diff 差分数组是可以反推出原始数组 nums 的，理解：diff[0]就是原数组的第一个元素，其他元素就是比前一个元素高多少\n这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可\n原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 又意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对 nums[i..j] 中的所有元素都加 3 了\n详见：https://labuladong.gitee.io/algo/2/20/25/\n标准模板 class Difference { private int[] diff; public Difference(int[] nums) { assert nums.length \u0026gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[1] - nums[0]; } } public void increment(int i, int j, int val) { diff[i] += val; // 注意这里j有可能是最后一个元素，此时的意思就是i后面的元素全部加val，所以不需要减val了 if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } 二叉树 前中后序理解 前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点：\n前序位置的代码在刚刚进入一个二叉树节点的时候执行；\n后序位置的代码在将要离开一个二叉树节点的时候执行；\n中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。\n比如快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历\n遍历模板 void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 } 多叉树的遍历模板：\n/* 多叉树遍历框架 */ void traverse(TreeNode root) { if (root == null) return; // 前序位置 for (TreeNode child : root.children) { traverse(child); } // 后序位置 } 做题思路 有两种思路，分别是分解问题和遍历二叉树\n遇到一道二叉树的题目时的通用思考过程是：\n1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。\n2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值(这个返回值就是需要用到的子树信息)，这样的话递归函数就会一直分解这个问题，直到该问题不能再分解，所以我们还需要考虑base case(递归出口)。\n3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n后序位置的特殊之处 因为前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的，所以：\n前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。\n层序遍历 就是一个BFS，可以计算一些类似结点与root之间的距离的问题。\n模板 // 输入一棵二叉树的根节点，层序遍历这棵二叉树 void levelTraverse(TreeNode root) { if (root == null) return; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); // 从上到下遍历二叉树的每一层 while (!q.isEmpty()) { int sz = q.size(); // 从左到右遍历每一层的每个节点 for (int i = 0; i \u0026lt; sz; i++) { TreeNode cur = q.poll(); // 将下一层节点放入队列 if (cur.left != null) { // 注意不要把null放队列里面 q.offer(cur.left); } if (cur.right != null) { // 注意不要把null放队列里面 q.offer(cur.right); } } } } 注意点 前序中序，后序中序可以唯一确定一颗二叉树，或者带空指针的任意一个遍历序列都可以唯一确定一棵二叉树\n前序后序不能唯一确定一颗二叉树，因为：\n当节点左右子树都存在时，可以确定左右子树，但是当其中一个为空时，无法确定不为空的子树是左子树还是右子树\n二叉搜索树 性质 二叉树左边子树全部小于根节点，右边全部大于根节点，中序遍历就是升序序列，并且中序遍历到一个结点时，比该结点小的结点全部都遍历过了，这个性质可以用于二叉搜索树的累加上，二叉搜索树最左边是最小的结点，最右边是最大的结点\n合法性 利用二叉树的分解思想，将原问题分解为：root左边的的结点都比root小右边的的结点都比root大+左子树是BST+右子树是BST，问题在于root只能获得左右孩子的值，从而判断是都大于小于root，想要让整个子树都小于或大于自己，需要将min和max传下去，如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。\n增删改查 在二叉树递归框架之上，扩展出一套 BST 代码框架：\nvoid BST(TreeNode root, int target) { if (root.val == target) // 找到目标，做点什么 if (root.val \u0026lt; target) BST(root.right, target); if (root.val \u0026gt; target) BST(root.left, target); } 根据代码框架掌握了 BST 的增删查改操作。\n图 存储方式 邻接表 优点：省空间\n邻接矩阵 优点：可以随机访问\n遍历模板 DFS 和多叉树类似，只不过需要记录访问过的结点\n// 记录被遍历过的节点 boolean[] visited; // 记录从起点到当前节点的路径 boolean[] onPath; /* 图遍历框架 */ void traverse(Graph graph, int s) { if (visited[s]) return; // 进入结点时 // 经过节点 s，标记为已遍历 visited[s] = true; // 做选择：标记节点 s 在路径上 onPath[s] = true; for (int neighbor : graph.neighbors(s)) { traverse(graph, neighbor); } // 离开结点时 // 撤销选择：节点 s 离开路径 onPath[s] = false; } BFS // 记录被遍历过的节点 boolean[] visited; void traverse(Graph graph, int s) { Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(s); while (!queue.isEmpty()) { int node = queue.poll(); visited[node] = true; for (int neighbor : graph.neighbors(s)) { if (!visited[neighbor]) { queue.offer(next); } } } } 图的拓扑排序 拓扑排序 直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的\n如果一个图里存在环，是无法进行拓扑排序的，反之，如果图里没有环那么一定可以拓扑排序\n注意有向无环图不一定是树\n如何拓扑排序 将后序遍历的结果进行反转，就是拓扑排序的结果。至于原因由于需要严格的数学证明，就不用看了，可以自己画个图看一看 利用图的BFS，每次只让入度为零的结点入队列，此时遍历的结果就是拓扑排序的结果 二分图 如图所示就是二分图，可以使用染色法判断一个图是否为二分图，如下所示：\n在某些场景下二分图也可以作为存储键值对的数据结构（符号表）\n判断二分图（染色）模板 其实就是图的遍历，只不过一边遍历一边染色\nDFS /* 判断二分图框架(DFS) */ private boolean[] color; private boolean[] visited; void traverse(Graph graph, int v) { visited[v] = true; // 遍历节点 v 的所有相邻节点 neighbor for (int neighbor : graph.neighbors(v)) { if (!visited[neighbor]) { // 相邻节点 neighbor 没有被访问过 // 那么应该给节点 neighbor 涂上和节点 v 不同的颜色 color[neighbor] = color[v]; traverse(graph, neighbor); } else { // 相邻节点 neighbor 已经被访问过 // 那么应该比较节点 neighbor 和节点 v 的颜色 // 若相同，则此图不是二分图 } } } BFS /* 判断二分图框架(BFS) */ private boolean[] color; private boolean[] visited; void traverse(Graph graph, int start) { Deque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); visited[start] = true; queue.offer(start); while (!queue.isEmpty()) { int v = queue.poll(); // 从节点 v 向所有相邻节点扩散 for (int w : graph[v]) { if (!visited[w]) { // 相邻节点 w 没有被访问过 // 那么应该给节点 w 涂上和节点 v 不同的颜色 color[w] = !color[v]; // 标记 w 节点，并放入队列 visited[w] = true; queue.offer(w); } else { // 相邻节点 w 已经被访问过 // 根据 v 和 w 的颜色判断是否是二分图 if (color[w] == color[v]) { // 若相同，则此图不是二分图 return; } } } } } 并查集 就是可以1、方便的合并两个集合，2、快速的判断两个结点是否处于一个集合中的树状数据结构，长下面这个样子\n模板 class UF { // 连通分量个数 private int count; // 存储每个节点的父节点 private int[] parent; // n 为图中节点的个数 public UF(int n) { this.count = n; parent = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } } // 将节点 p 和节点 q 连通 public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootQ] = rootP; // 两个连通分量合并成一个连通分量 count--; } // 判断节点 p 和节点 q 是否连通 public boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } // 返回图中的连通分量个数 public int count() { return count; } } 这里做了路径压缩的优化，在 find 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 size 数组的平衡优化。\ndijkstra问题 dijkstra是求最短路径的算法，实际上是由图的BFS演化而来，模板如下：\nclass State { // 图节点的 id int id; // 从 start 节点到当前节点的距离 int distFromStart; State(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } // 返回节点 from 到节点 to 之间的边的权重 int weight(int from, int to); // 输入节点 s 返回 s 的相邻节点 List\u0026lt;Integer\u0026gt; adj(int s); // 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离 int[] dijkstra(int start, List\u0026lt;Integer\u0026gt;[] graph) { // 图中节点的个数 int V = graph.length; // 记录最短路径的权重，你可以理解为 dp table // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重 int[] distTo = new int[V]; // 求最小值，所以 dp table 初始化为正无穷 Arrays.fill(distTo, Integer.MAX_VALUE); // base case，start 到 start 的最短距离就是 0 distTo[start] = 0; // 优先级队列，distFromStart 较小的排在前面 Queue\u0026lt;State\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { return a.distFromStart - b.distFromStart; }); // 从起点 start 开始进行 BFS pq.offer(new State(start, 0)); while (!pq.isEmpty()) { State curState = pq.poll(); int curNodeID = curState.id; int curDistFromStart = curState.distFromStart; // 如果只需要start到end的最短距离加上这句就可以了 // if (curNodeID == end) { // return curDistFromStart; // } if (curDistFromStart \u0026gt; distTo[curNodeID]) { // 已经有一条更短的路径到达 curNode 节点了 continue; } // 将 curNode 的相邻节点装入队列 for (int nextNodeID : adj(curNodeID)) { // 看看从 curNode 达到 nextNode 的距离是否会更短 int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID); if (distTo[nextNodeID] \u0026gt; distToNextNode) { // 更新 dp table distTo[nextNodeID] = distToNextNode; // 将这个节点以及距离放入队列 pq.offer(new State(nextNodeID, distToNextNode)); } } } return distTo; } 解释：同一个结点可能会入队多个State，一定会先遍历到dist较小的那个，结点的第一次遍历，就确定了这个结点的最短距离，然后按照这个最短距离刷新start到其他节点的距离，之后这个结点的任务就算是结束了，以后再碰到这个结点直接continue就可以了。\n注意dijkstra的变种需要修改adj和weight函数\nkruskal问题 用于求解最小生成树问题，主要思路就是先把边按权重排序，从小到大添加边，同时判断边添加后是否有环（这一步可以用并查集做），模板如下：\nint minimumCost(int n, int[][] edges) { UF uf = new UF(n); // 对所有边按照权重从小到大排序 Arrays.sort(edges, (a, b) -\u0026gt; (a[2] - b[2])); // 记录最小生成树的权重之和 int mst = 0; for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; // 若这条边会产生环，则不能加入 mst if (uf.connected(u, v)) { continue; } // 若这条边不会产生环，则属于最小生成树 mst += weight; uf.union(u, v); } // 保证所有节点都被连通 // uf.count() == 1 说明所有节点被连通 return uf.count() == 1 ? mst : -1; } class UF { // 见上文并查集模板 } 详见：https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w\nprim问题 用于求解最小生成树问题，原理就是横切边中最小的一定是最小生成树的一条边，可以每次添加一个结点找横切边（这样比较方便），然后把最小生成树的边都找到就可以了，模板如下：\nclass Prim { // 核心数据结构，存储「横切边」的优先级队列 private PriorityQueue\u0026lt;int[]\u0026gt; pq; // 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分 private boolean[] inMST; // 记录最小生成树的权重和 private int weightSum = 0; // graph 是用邻接表表示的一幅图， // graph[s] 记录节点 s 所有相邻的边， // 三元组 int[]{from, to, weight} 表示一条边 private List\u0026lt;int[]\u0026gt;[] graph; public Prim(List\u0026lt;int[]\u0026gt;[] graph) { this.graph = graph; this.pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; { // 按照边的权重从小到大排序 return a[2] - b[2]; }); // 图中有 n 个节点 int n = graph.length; this.inMST = new boolean[n]; // 随便从一个点开始切分都可以，我们不妨从节点 0 开始 inMST[0] = true; cut(0); // 不断进行切分，向最小生成树中添加边 while (!pq.isEmpty()) { int[] edge = pq.poll(); int to = edge[1]; int weight = edge[2]; if (inMST[to]) { // 节点 to 已经在最小生成树中，跳过 // 否则这条边会产生环 continue; } // 将边 edge 加入最小生成树 weightSum += weight; inMST[to] = true; // 节点 to 加入后，进行新一轮切分，会产生更多横切边 cut(to); } } // 将 s 的横切边加入优先队列 private void cut(int s) { // 遍历 s 的邻边 for (int[] edge : graph[s]) { int to = edge[1]; if (inMST[to]) { // 相邻接点 to 已经在最小生成树中，跳过 // 否则这条边会产生环 continue; } // 加入横切边队列 pq.offer(edge); } } // 最小生成树的权重和 public int weightSum() { return weightSum; } // 判断最小生成树是否包含图中的所有节点 public boolean allConnected() { for (int i = 0; i \u0026lt; inMST.length; i++) { if (!inMST[i]) { return false; } } return true; } } 详见：https://labuladong.gitee.io/algo/2/22/55/\n回溯 回溯和DFS的区别：\n回溯关注的是树枝，DFS关注的是结点，反映到代码上：\n// DFS 算法，关注点在节点 void traverse(TreeNode root) { if (root == null) return; printf(\u0026#34;进入节点 %s\u0026#34;, root); for (TreeNode child : root.children) { traverse(child); } printf(\u0026#34;离开节点 %s\u0026#34;, root); } // 回溯算法，关注点在树枝 void backtrack(TreeNode root) { if (root == null) return; for (TreeNode child : root.children) { // 做选择 printf(\u0026#34;从 %s 到 %s\u0026#34;, root, child); backtrack(child); // 撤销选择 printf(\u0026#34;从 %s 到 %s\u0026#34;, child, root); } } 设计数据结构 LRU 即Least Recently Used，也就是每次淘汰那些最久没被使用的数据，主要就是利用了哈希链表（在Java中是LinkedHashMap）这种数据结构，如下图所示：\n手写轮子模板：\nclass LRUCache { // key -\u0026gt; Node(key, val) private Map\u0026lt;Integer, Node\u0026gt; map; // Node(k1, v1) \u0026lt;-\u0026gt; Node(k2, v2)... private DoubleList cache; // 最大容量 private int capacity; public LRUCache(int capacity) { this.capacity = capacity; map = new HashMap\u0026lt;\u0026gt;(); cache = new DoubleList(); } public int get(int key) { if (!map.containsKey(key)) { return -1; } // 将该数据提升为最近使用的 makeRecently(key); return map.get(key).val; } public void put(int key, int val) { if (map.containsKey(key)) { // 删除旧的数据 deleteKey(key); // 新插入的数据为最近使用的数据 addRecently(key, val); return; } if (cap == cache.size()) { // 删除最久未使用的元素 removeLeastRecently(); } // 添加为最近使用的元素 addRecently(key, val); } /* 将某个 key 提升为最近使用的 */ private void makeRecently(int key) { Node x = map.get(key); // 先从链表中删除这个节点 cache.remove(x); // 重新插到队尾 cache.addLast(x); } /* 添加最近使用的元素 */ private void addRecently(int key, int val) { Node x = new Node(key, val); // 链表尾部就是最近使用的元素 cache.addLast(x); // 别忘了在 map 中添加 key 的映射 map.put(key, x); } /* 删除某一个 key */ private void deleteKey(int key) { Node x = map.get(key); // 从链表中删除 cache.remove(x); // 从 map 中删除 map.remove(key); } /* 删除最久未使用的元素 */ private void removeLeastRecently() { // 链表头部的第一个元素就是最久未使用的 Node deletedNode = cache.removeFirst(); // 同时别忘了从 map 中删除它的 key int deletedKey = deletedNode.key; map.remove(deletedKey); } class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class DoubleList { // 头尾虚节点 private Node head, tail; // 链表元素数 private int size; public DoubleList() { // 初始化双向链表的数据 head = new Node(0, 0); tail = new Node(0, 0); head.next = tail; tail.prev = head; size = 0; } // 在链表尾部添加节点 x，时间 O(1) public void addLast(Node x) { x.prev = tail.prev; x.next = tail; tail.prev.next = x; tail.prev = x; size++; } // 删除链表中的 x 节点（x 一定存在） // 由于是双链表且给的是目标 Node 节点，时间 O(1) public void remove(Node x) { x.prev.next = x.next; x.next.prev = x.prev; size--; } // 删除链表中第一个节点，并返回该节点，时间 O(1) public Node removeFirst() { if (size == 0) { return null; } Node first = head.next; remove(first); return first; } // 返回链表长度，时间 O(1) public int size() { return size; } } } 使用LinkedHashMap模板：\nclass LRUCache { int cap; LinkedHashMap\u0026lt;Integer, Integer\u0026gt; cache = new LinkedHashMap\u0026lt;\u0026gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() \u0026gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); } } LFU Least Frequently Used，也就是每次淘汰那些使用次数最少的数据，主要利用了keyToVal，keyToFreq，freqToKeys三个数据结构相互配合，详见：https://mp.weixin.qq.com/s/oXv03m1J8TwtHwMJEZ1ApQ，模板如下：\nclass LFUCache { // key 到 val 的映射，我们后文称为 KV 表 HashMap\u0026lt;Integer, Integer\u0026gt; keyToVal; // key 到 freq 的映射，我们后文称为 KF 表 HashMap\u0026lt;Integer, Integer\u0026gt; keyToFreq; // freq 到 key 列表的映射，我们后文称为 FK 表 HashMap\u0026lt;Integer, LinkedHashSet\u0026lt;Integer\u0026gt;\u0026gt; freqToKeys; // 记录最小的频次 int minFreq; // 记录 LFU 缓存的最大容量 int cap; public LFUCache(int capacity) { keyToVal = new HashMap\u0026lt;\u0026gt;(); keyToFreq = new HashMap\u0026lt;\u0026gt;(); freqToKeys = new HashMap\u0026lt;\u0026gt;(); this.cap = capacity; this.minFreq = 0; } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } // 增加 key 对应的 freq increaseFreq(key); return keyToVal.get(key); } public void put(int key, int val) { if (this.cap \u0026lt;= 0) return; /* 若 key 已存在，修改对应的 val 即可 */ if (keyToVal.containsKey(key)) { keyToVal.put(key, val); // key 对应的 freq 加一 increaseFreq(key); return; } /* key 不存在，需要插入 */ /* 容量已满的话需要淘汰一个 freq 最小的 key */ if (this.cap \u0026lt;= keyToVal.size()) { removeMinFreqKey(); } /* 插入 key 和 val，对应的 freq 为 1 */ // 插入 KV 表 keyToVal.put(key, val); // 插入 KF 表 keyToFreq.put(key, 1); // 插入 FK 表 freqToKeys.putIfAbsent(1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(1).add(key); // 插入新 key 后最小的 freq 肯定是 1 this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); /* 更新 KF 表 */ keyToFreq.put(key, freq + 1); /* 更新 FK 表 */ // 将 key 从 freq 对应的列表中删除 freqToKeys.get(freq).remove(key); // 将 key 加入 freq + 1 对应的列表中 freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet\u0026lt;\u0026gt;()); freqToKeys.get(freq + 1).add(key); // 如果 freq 对应的列表空了，移除这个 freq if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); // 如果这个 freq 恰好是 minFreq，更新 minFreq if (freq == this.minFreq) { this.minFreq++; } } } private void removeMinFreqKey() { // freq 最小的 key 列表 LinkedHashSet\u0026lt;Integer\u0026gt; keyList = freqToKeys.get(this.minFreq); // 其中最先被插入的那个 key 就是该被淘汰的 key int deletedKey = keyList.iterator().next(); /* 更新 FK 表 */ keyList.remove(deletedKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 问：这里需要更新 minFreq 的值吗？ // 这里不用修改minFreq因为后面会置为1 } /* 更新 KV 表 */ keyToVal.remove(deletedKey); /* 更新 KF 表 */ keyToFreq.remove(deletedKey); } } TrieMap和TrieSet Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。结构如下所示：\n底层是Trie树的Map就是TrieMap，TrieMap就是key是字符串，value是任何类型的map，TrieSet就是没用到value的TrieMap，详见：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==\u0026amp;mid=2247495471\u0026amp;idx=1\u0026amp;sn=fd180d7e207e92a87a9c9cce69b8cdb9\nTrieMap模板如下：\nclass TrieMap\u0026lt;V\u0026gt; { // ASCII 码个数 private static final int R = 256; // 当前存在 Map 中的键值对个数 private int size = 0; // Trie 树的根节点 private TrieNode\u0026lt;V\u0026gt; root = null; private static class TrieNode\u0026lt;V\u0026gt; { V val = null; TrieNode\u0026lt;V\u0026gt;[] children = new TrieNode[R]; } /***** 增/改 *****/ // 在 map 中添加或修改键值对 public void put(String key, V val) { if (!containsKey(key)) { // 新增键值对 size++; } // 需要一个额外的辅助函数，并接收其返回值 root = put(root, key, val, 0); } // 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点 private TrieNode\u0026lt;V\u0026gt; put(TrieNode\u0026lt;V\u0026gt; node, String key, V val, int i) { if (node == null) { // 如果树枝不存在，新建 node = new TrieNode\u0026lt;\u0026gt;(); } if (i == key.length()) { // key 的路径已插入完成，将值 val 存入节点 node.val = val; return node; } char c = key.charAt(i); // 递归插入子节点，并接收返回值 node.children[c] = put(node.children[c], key, val, i + 1); return node; } /***** 删 *****/ // 在 Map 中删除 key public void remove(String key) { if (!containsKey(key)) { return; } // 递归修改数据结构要接收函数的返回值 root = remove(root, key, 0); size--; } // 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点 private TrieNode\u0026lt;V\u0026gt; remove(TrieNode\u0026lt;V\u0026gt; node, String key, int i) { if (node == null) { return null; } if (i == key.length()) { // 找到了 key 对应的 TrieNode，删除 val node.val = null; } else { char c = key.charAt(i); // 递归去子树进行删除 node.children[c] = remove(node.children[c], key, i + 1); } // 后序位置，递归路径上的节点可能需要被清理 if (node.val != null) { // 如果该 TireNode 存储着 val，不需要被清理 return node; } // 检查该 TrieNode 是否还有后缀 for (int c = 0; c \u0026lt; R; c++) { if (node.children[c] != null) { // 只要存在一个子节点（后缀树枝），就不需要被清理 return node; } } // 既没有存储 val，也没有后缀树枝，则该节点需要被清理 return null; } /***** 查 *****/ // 搜索 key 对应的值，不存在则返回 null public V get(String key) { // 从 root 开始搜索 key TrieNode\u0026lt;V\u0026gt; x = getNode(root, key); if (x == null || x.val == null) { // x 为空或 x 的 val 字段为空都说明 key 没有对应的值 return null; } return x.val; } // 判断 key 是否存在在 Map 中 public boolean containsKey(String key) { return get(key) != null; } // 判断是和否存在前缀为 prefix 的键 public boolean hasKeyWithPrefix(String prefix) { // 只要能找到一个节点，就是存在前缀 return getNode(root, prefix) != null; } // 在所有键中寻找 query 的最短前缀 public String shortestPrefixOf(String query) { TrieNode\u0026lt;V\u0026gt; p = root; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; query.length(); i++) { if (p == null) { // 无法向下搜索 return \u0026#34;\u0026#34;; } if (p.val != null) { // 找到一个键是 query 的前缀 return query.substring(0, i); } // 向下搜索 char c = query.charAt(i); p = p.children[c]; } if (p != null \u0026amp;\u0026amp; p.val != null) { // 如果 query 本身就是一个键 return query; } return \u0026#34;\u0026#34;; } // 在所有键中寻找 query 的最长前缀 public String longestPrefixOf(String query) { TrieNode\u0026lt;V\u0026gt; p = root; // 记录前缀的最大长度 int max_len = 0; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; query.length(); i++) { if (p == null) { // 无法向下搜索 break; } if (p.val != null) { // 找到一个键是 query 的前缀，更新前缀的最大长度 max_len = i; } // 向下搜索 char c = query.charAt(i); p = p.children[c]; } if (p != null \u0026amp;\u0026amp; p.val != null) { // 如果 query 本身就是一个键 return query; } return query.substring(0, max_len); } // 搜索前缀为 prefix 的所有键 public List\u0026lt;String\u0026gt; keysWithPrefix(String prefix) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); // 找到匹配 prefix 在 Trie 树中的那个节点 TrieNode\u0026lt;V\u0026gt; x = getNode(root, prefix); if (x == null) { return res; } // DFS 遍历以 x 为根的这棵 Trie 树 traverse(x, new StringBuilder(prefix), res); return res; } // 遍历以 node 节点为根的 Trie 树，找到所有键 private void traverse(TrieNode\u0026lt;V\u0026gt; node, StringBuilder path, List\u0026lt;String\u0026gt; res) { if (node == null) { // 到达 Trie 树底部叶子结点 return; } if (node.val != null) { // 找到一个 key，添加到结果列表中 res.add(path.toString()); } // 回溯算法遍历框架 for (char c = 0; c \u0026lt; R; c++) { // 做选择 path.append(c); traverse(node.children[c], path, res); // 撤销选择 path.deleteCharAt(path.length() - 1); } } // 通配符 . 匹配任意字符 public List\u0026lt;String\u0026gt; keysWithPattern(String pattern) { List\u0026lt;String\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); traverse(root, new StringBuilder(), pattern, 0, res); return res; } // 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..] private void traverse(TrieNode\u0026lt;V\u0026gt; node, StringBuilder path, String pattern, int i, List\u0026lt;String\u0026gt; res) { if (node == null) { // 树枝不存在，即匹配失败 return; } if (i == pattern.length()) { // pattern 匹配完成 if (node.val != null) { // 如果这个节点存储着 val，则找到一个匹配的键 res.add(path.toString()); } return; } char c = pattern.charAt(i); if (c == \u0026#39;.\u0026#39;) { // pattern[i] 是通配符，可以变化成任意字符 // 多叉树（回溯算法）遍历框架 for (char j = 0; j \u0026lt; R; j++) { path.append(j); traverse(node.children[j], path, pattern, i + 1, res); path.deleteCharAt(path.length() - 1); } } else { // pattern[i] 是普通字符 c path.append(c); traverse(node.children[c], path, pattern, i + 1, res); path.deleteCharAt(path.length() - 1); } } // 判断是和否存在前缀为 prefix 的键 public boolean hasKeyWithPattern(String pattern) { // 从 root 节点开始匹配 pattern[0..] return hasKeyWithPattern(root, pattern, 0); } // 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配 private boolean hasKeyWithPattern(TrieNode\u0026lt;V\u0026gt; node, String pattern, int i) { if (node == null) { // 树枝不存在，即匹配失败 return false; } if (i == pattern.length()) { // 模式串走到头了，看看匹配到的是否是一个键 return node.val != null; } char c = pattern.charAt(i); // 没有遇到通配符 if (c != \u0026#39;.\u0026#39;) { // 从 node.children[c] 节点开始匹配 pattern[i+1..] return hasKeyWithPattern(node.children[c], pattern, i + 1); } // 遇到通配符 for (int j = 0; j \u0026lt; R; j++) { // pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回 if (hasKeyWithPattern(node.children[j], pattern, i + 1)) { return true; } } // 都没有匹配 return false; } // 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null private TrieNode\u0026lt;V\u0026gt; getNode(TrieNode\u0026lt;V\u0026gt; node, String key) { TrieNode\u0026lt;V\u0026gt; p = node; // 从节点 node 开始搜索 key for (int i = 0; i \u0026lt; key.length(); i++) { if (p == null) { // 无法向下搜索 return null; } // 向下搜索 char c = key.charAt(i); p = p.children[c]; } return p; } public int size() { return size; } } TrieSet模板如下：\nclass TrieSet { // 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用 // 值的类型可以随便设置，我参考 Java 标准库设置成 Object private final TrieMap\u0026lt;Object\u0026gt; map = new TrieMap\u0026lt;\u0026gt;(); /***** 增 *****/ // 在集合中添加元素 key public void add(String key) { map.put(key, new Object()); } /***** 删 *****/ // 从集合中删除元素 key public void remove(String key) { map.remove(key); } /***** 查 *****/ // 判断元素 key 是否存在集合中 public boolean contains(String key) { return map.containsKey(key); } // 在集合中寻找 query 的最短前缀 public String shortestPrefixOf(String query) { return map.shortestPrefixOf(query); } // 在集合中寻找 query 的最长前缀 public String longestPrefixOf(String query) { return map.longestPrefixOf(query); } // 在集合中搜索前缀为 prefix 的所有元素 public List\u0026lt;String\u0026gt; keysWithPrefix(String prefix) { return map.keysWithPrefix(prefix); } // 判断集合中是否存在前缀为 prefix 的元素 public boolean hasKeyWithPrefix(String prefix) { return map.hasKeyWithPrefix(prefix); } // 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素 public List\u0026lt;String\u0026gt; keysWithPattern(String pattern) { return map.keysWithPattern(pattern); } // 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素 public boolean hasKeyWithPattern(String pattern) { return map.hasKeyWithPattern(pattern); } // 返回集合中元素的个数 public int size() { return map.size(); } } 单调栈 就是元素单调递增或递减的栈，比如单减栈，入栈的时候将小于入栈元素的栈顶出栈，就可以保证栈的单调递减，一般可以用在「下一个更大元素」，「上一个更小元素」等问题上，「下一个更大元素」模板如下：\nint[] nextGreaterElement(int[] nums) { int n = nums.length; // 存放答案的数组 int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); // 倒着往栈里放 for (int i = n - 1; i \u0026gt;= 0; i--) { // 判定个子高矮 while (!s.isEmpty() \u0026amp;\u0026amp; s.peek() \u0026lt;= nums[i]) { // 矮个起开，反正也被挡着了。。。 s.pop(); } // nums[i] 身后的更大元素 res[i] = s.isEmpty() ? -1 : s.peek(); s.push(nums[i]); } return res; } 单调队列 就是元素单调递增或递减的队列，比如单减队列，入队的时候将小于入队元素的队尾出队，就可以保证队的单调递减，一般可以用在「滑动窗口最大值」问题上，模板如下：\n/* 单调队列的实现 */ class MonotonicQueue { LinkedList\u0026lt;Integer\u0026gt; maxq = new LinkedList\u0026lt;\u0026gt;(); public void push(int n) { // 将小于 n 的元素全部删除 while (!maxq.isEmpty() \u0026amp;\u0026amp; maxq.getLast() \u0026lt; n) { maxq.pollLast(); } // 然后将 n 加入尾部 maxq.addLast(n); } public int max() { return maxq.getFirst(); } public void poll(int n) { if (n == maxq.getFirst()) { maxq.pollFirst(); } } } 二叉堆 就是最大堆或最小堆，是一颗完全二叉树，所以可以放在数组里面，用简单的计算就能得到结点的父节点和左右孩子，基于二叉堆开发出了优先队列，优先队列插入时将插入结点放到数组最后面然后对该节点执行上浮操作，删除时将堆顶删除，然后将数组最后面的结点放到堆顶的位置，然后对堆顶做下沉操作。模板如下：\npublic class MaxPQ \u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { // 存储元素的数组 private Key[] pq; // 当前 Priority Queue 中的元素个数 private int size = 0; public MaxPQ(int cap) { // 索引 0 不用，所以多分配一个空间 pq = (Key[]) new Comparable[cap + 1]; } /* 返回当前队列中最大元素 */ public Key max() { return pq[1]; } /* 插入元素 e */ public void insert(Key e) { size++; // 先把新元素加到最后 pq[size] = e; // 然后让它上浮到正确的位置 swim(size); } /* 删除并返回当前队列中最大元素 */ public Key delMax() { // 最大堆的堆顶就是最大元素 Key max = pq[1]; // 把这个最大元素换到最后，删除之 swap(1, size); pq[size] = null; size--; // 让 pq[1] 下沉到正确位置 sink(1); return max; } /* 上浮第 x 个元素，以维护最大堆性质 */ private void swim(int x) { // 如果浮到堆顶，就不能再上浮了 while (x \u0026gt; 1 \u0026amp;\u0026amp; less(parent(x), x)) { // 如果第 x 个元素比上层大 // 将 x 换上去 swap(parent(x), x); x = parent(x); } } /* 下沉第 x 个元素，以维护最大堆性质 */ private void sink(int x) { // 如果沉到堆底，就沉不下去了 while (left(x) \u0026lt;= size) { // 先假设左边节点较大 int max = left(x); // 如果右边节点存在，比一下大小 if (right(x) \u0026lt;= size \u0026amp;\u0026amp; less(max, right(x))) max = right(x); // 结点 x 比俩孩子都大，就不必下沉了 if (less(max, x)) break; // 否则，不符合最大堆的结构，下沉 x 结点 swap(x, max); x = max; } } /* 交换数组的两个元素 */ private void swap(int i, int j) { Key temp = pq[i]; pq[i] = pq[j]; pq[j] = temp; } /* pq[i] 是否比 pq[j] 小？ */ private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) \u0026lt; 0; } // 父节点的索引 private int parent(int root) { return root / 2; } // 左孩子的索引 private int left(int root) { return root * 2; } // 右孩子的索引 private int right(int root) { return root * 2 + 1; } } 队列实现栈以及栈实现队列 栈实现队列用两个栈即可，入栈相当于入队，出栈时先将一个栈里的元素出栈到另一个栈中，栈顶就是队头，模板如下：\nclass MyQueue { private Stack\u0026lt;Integer\u0026gt; s1, s2; public MyQueue() { s1 = new Stack\u0026lt;\u0026gt;(); s2 = new Stack\u0026lt;\u0026gt;(); } /** 添加元素到队尾 */ public void push(int x) { s1.push(x); } /** 返回队头元素 */ public int peek() { if (s2.isEmpty()) // 把 s1 元素压入 s2 while (!s1.isEmpty()) s2.push(s1.pop()); return s2.peek(); } /** 删除队头的元素并返回 */ public int pop() { // 先调用 peek 保证 s2 非空 peek(); return s2.pop(); } /** 判断队列是否为空 */ public boolean empty() { return s1.isEmpty() \u0026amp;\u0026amp; s2.isEmpty(); } } 栈实现队列简单粗暴，pop的时候把除了队尾的其他都出队再加入到队尾即可，模板如下：\nclass MyStack { Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); int top_elem = 0; /** 添加元素到栈顶 */ public void push(int x) { // x 是队列的队尾，是栈的栈顶 q.offer(x); top_elem = x; } /** 返回栈顶元素 */ public int top() { return top_elem; } /** 删除栈顶的元素并返回 */ public int pop() { int size = q.size(); // 留下队尾 2 个元素 while (size \u0026gt; 2) { q.offer(q.poll()); size--; } // 记录新的队尾元素 top_elem = q.peek(); q.offer(q.poll()); // 删除之前的队尾元素 return q.poll(); } /** 判断栈是否为空 */ public boolean empty() { return q.isEmpty(); } } 其他 零碎 从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。\n数据结构的物理存储方式就是链式和顺序两种，基本操作就是增删改查，遍历方式无非迭代和递归。\n计算机算法的本质就是枚举，只不过这里枚举需要做到两个方面：无遗漏和无冗余，有时候还可以利用一些定理进行优化（缩小搜索范围），比如剪枝和数学定理\n难点在无遗漏的问题：\n难点在无冗余的问题：递归类问题（动态规划）\n难点在优化的问题：非递归类问题（并查集，贪心，KMP）\nJava里优先队列就是二叉堆，也就是PriorityQueue\nbase case就是最基本的情况，从递归的角度理解就是递归出口，从分解问题(分治)的角度理解就是最基本的问题（不能再分了）\n如果需要通过值找到其在数组的索引，将数组遍历一遍是一种做法，还可以创建一个valToIndex的hashmap\n序列化就是把结构化的数据（比如树）打平（比如转换为字符串）\n序列化和反序列化的目的：以某种特定格式组织数据，使得数据可以独立于编程语言。\n待做 https://labuladong.gitee.io/algo/1/3/的那几个算法框架及之后的几个框架文章都没看\nhttps://labuladong.gitee.io/algo/2/21/41/没看\nhttps://labuladong.gitee.io/algo/2/21/45/没看\nhttps://labuladong.gitee.io/algo/2/22/57/没看\nhttps://labuladong.gitee.io/algo/2/23/67/没看\n技巧 dummy（虚拟头结点)：可以很好的避免第一个节点的特殊性，将第一个节点当作第二个节点，也即是所有节点统一处理\n把 return 语句都放在函数开头，因为一般 return 语句都是 base case，集中放在一起可以让算法结构更清晰。\n将二维坐标映射到一维的常用技巧：将二维坐标 (x,y) 转换成 x * n + y 这个数（m 是棋盘的行数，n 是棋盘的列数）\n方向数组 d 是上下左右搜索的常用手法：int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};\n学习方法 以后做题，先想这道题考察什么知识点。\n","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-note-1/","summary":"链表 合并两个有序链表 解法 略 题目 1. 合并两个有序链表 题解详见：https://blog.zhangmengyang.tk/posts/leetc","title":"LeetCode Note 1"},{"content":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。\n代码 class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1); ListNode p1 = dummy1, p2 = dummy2, p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p1 = p1.next; } else { p2.next = p; p2 = p2.next; } ListNode temp = p.next; p.next = null; p = temp; } p1.next = dummy2.next; return dummy1.next; } References 1. 分隔链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-86/","summary":"思路 从头到尾遍历一遍链表，将小于x的放到一个链表里，将大于等于x的放到一个链表里，最后再拼接这两个链表即可，注意dummy节点的使用。 代码 class","title":"LeetCode 86"},{"content":"思路 不解释\n代码 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2 != null) { p.next = list2; } return dummy.next; } } References 1. 合并两个有序链表 ","permalink":"https://blog.zhangmengyang.tk/posts/leetcode/leetcode-21/","summary":"思路 不解释 代码 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(-1), p = dummy; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) { p.next = list1; } if (list2","title":"LeetCode 21"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://blog.zhangmengyang.tk/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文","title":"🤝友链"},{"content":"关于我\n英文名: ZMY 职业: 研究生在读 爱好: 写代码、玩游戏、网上冲浪 ","permalink":"https://blog.zhangmengyang.tk/about/","summary":"关于我 英文名: ZMY 职业: 研究生在读 爱好: 写代码、玩游戏、网上冲浪","title":"🙋🏻‍♂️关于"}]